<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="en">
<!--<![endif]-->
<head>
		<!-- Basic Page Needs
		================================================== -->
		<meta charset="utf-8">
		<title>Docs | Aurelia</title>
		<meta name="description" content="Learn the ins and outs of all the Aurelia libraries in our docs section.">
		<!-- Mobile Specific Metas
		================================================== -->
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<!-- CSS
		================================================== -->
		<!-- Bootstrap  -->
		<link type="text/css" rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
		
    <!-- web font  -->
		<link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,800" rel="stylesheet" type="text/css">
		
    <!-- plugin css  -->
		<link rel="stylesheet" type="text/css" href="js-plugin/animation-framework/animate.css" />
		<link rel="stylesheet" type="text/css" href="js-plugin/flexslider/flexslider.css" />
		<link rel="stylesheet" type="text/css" href="js-plugin/pageSlide/jquery.pageslide.css" />

		<!-- appear-->
		<link rel="stylesheet" type="text/css" href="js-plugin/appear/nekoAnim.css">
		
    <!-- icon fonts -->
		<link type="text/css" rel="stylesheet" href="font-icons/custom-icons/css/custom-icons.css">
		<link type="text/css" rel="stylesheet" href="font-icons/custom-icons/css/custom-icons-ie7.css">
		
    <!-- Custom css -->
		<link type="text/css" rel="stylesheet" href="css/layout.css">
		<link type="text/css" id="colors" rel="stylesheet" href="css/purple.css">
		
    <!--[if lt IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script> <![endif]-->
		<script src="js/modernizr-2.6.1.min.js"></script>
		
    <!-- Favicons
		================================================== -->
		<link rel="shortcut icon" href="images/favicon.ico">
		<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
		<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="144x144" href="images/apple-touch-icon-144x144.png">
	</head>
	<body data-spy="scroll" data-target="#scrollTarget" data-offset="150" class="activateAppearAnimation">
		<!-- Primary Page Layout 
		================================================== -->
		<!-- globalWrapper -->
		<div id="globalWrapper" class="localscroll">
      
        <header id="mainHeader" class="navbar-fixed-top" role="banner">
  <div class="container">
    <nav class="navbar navbar-default" role="navigation">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button>
        <a class="navbar-brand" href="index.html">
          <img src="images/main-logo.png" alt="Aurelia"/>
        </a> 
      </div>
      <div class="collapse navbar-collapse navbar-ex1-collapse">
        <ul class="nav navbar-nav pull-right">
          <li class=""><a href="index.html#home"><i class="icon-home-outline"></i>Home</a> </li>
          <li class=""><a href="get-started.html"><i class="icon-flash"></i>Get Started</a> </li>
          <li class="active"><a href="docs.html"><i class="icon-doc"></i>Docs</a> </li>
          <li><a href="http://blog.durandal.io/"><i class="icon-star"></i>Blog</a> </li>
        </ul>
      </div>
    </nav>
  </div>
</header>

<link href="css/prism.css" rel="stylesheet" />
<link href="css/markdown.css" rel="stylesheet" />

<section class="slice color1">
  <div class="container">
    <div class="row">
      <h1>Docs</h1>
<p>We&#39;ve got a very rich set of docs planned for Aurelia. Unfortunately, we haven&#39;t quite finished them yet. However, for this early preview period, we&#39;ve put together this document, containing examples of the most common tasks you might want to perform. If you have questions, we hope that you will join us on our <a href="https://gitter.im/aurelia/discuss">gitter channel</a>.</p>
<h2>Startup &amp; Configuration</h2>
<p>Most platforms have a &quot;main&quot; or entry point for code execution. Aurelia is no different. If you&#39;ve read the <a href="/get-started.html">Get Started</a> page, then you&#39;ve seen the <code>aurelia-app</code> attribute. Simply place this on an HTML element and Aurelia&#39;s bootstrapper will load an <em>app.js</em> and <em>app.html</em>, databind them together and inject them into the DOM element on which you placed that attribute. If you don&#39;t want to use that convention, simply provide a value to the attribute indicating which view-model to load. For example <code>&lt;body aurelia-app=&quot;todo&quot;&gt;</code> will result in a <em>todo.js</em> and <em>todo.html</em> being loaded instead.</p>
<p>The <code>aurelia-app</code> attribute is convenient for getting started, but often times you want to configure the framework or run some code prior to displaying anything to the user. So chances are, as your project progresses, you will migrate towards using <code>aurelia-main</code>.</p>
<blockquote>
<p><strong>Note:</strong> If you are using AtScript, add an <code>atscript</code> attribute to the DOM element for your app. If you are using ES5 instead of ES6, add an <code>es5</code> attribute. Doing so will &quot;turn on&quot; functionality with makes using these languages easier.</p>
</blockquote>
<p><strong>What is the difference?</strong></p>
<p><code>aurelia-app</code> instantiates an Aurelia app and pre-configures it with the default set of options for the framework, then loads your application view-model. <code>aurelia-main</code> loads your custom configuration module, <em>main.js</em> by default, then invokes your <code>configure</code> function, passing it the Aurelia object which you can then use to configure the framework yourself and decide what, when and where to display your UI. Here&#39;s an example <em>main.js</em> file:</p>
<pre><code class="language-javascript">import {LogManager} from &#39;aurelia-framework&#39;;
import {ConsoleAppender} from &#39;aurelia-logging-console&#39;;

LogManager.addAppender(new ConsoleAppender());
LogManager.setLevel(LogManager.levels.debug);

export function configure(aurelia) {
  aurelia.use
    .defaultBindingLanguage()
    .defaultResources()
    .router()
    .eventAggregator()
    .plugin(&#39;./path/to/plugin&#39;);

  aurelia.start().then(a =&gt; a.setRoot(&#39;app&#39;, document.body));
}</code></pre>
<p>With the exception of the custom plugin, this code is essentially what <code>aurelia-app</code> normally does for you. When you switch to <code>aurelia-main</code> you need to configure these things yourself, but you can also install custom plugins, set up the depedency injection container with some services and install global resources to be used in view templates.</p>
<blockquote>
<p><strong>Note:</strong> To turn on AtScript when manually configuring, call <code>aurelia.use.atscript()</code> and to turn on ES5, call <code>aurelia.use.es5()</code>.</p>
</blockquote>
<h3>Logging</h3>
<p>Aurelia has a simple logging abstraction that the framework itself uses. By default it is a no-op. The configuration above shows how to install an appender which will take the log data and output it the console. You can also see how to set the log level. Options for this setting include: <code>none</code>, <code>error</code>, <code>warn</code>, <code>info</code> and <code>debug</code>.</p>
<p>You can easily create your own appenders. Simply implement a class that matches the appender interface. The best way to see how to do this is to look at our own <a href="https://github.com/aurelia/logging-console/blob/master/src/index.js">console log appender&#39;s source</a>.</p>
<h3>Plugins</h3>
<p>A <em>plugin</em> is only a module with an exported <code>install</code> function. During startup Aurelia will load all plugin modules and call their <code>install</code> functions, passing to them the Aurelia instance so that they can configure the framework appropriately. Plugins can optionally return a <code>Promise</code> from their <code>install</code> function in order to perform asynchronous configuration tasks. When writing a plugin, be sure to follow these rules:</p>
<ol>
<li>Use a flat directory structure. Do not locate behaviors or views in subdirectories.</li>
<li>Your file name and your behavior name must match.</li>
<li>Explicilty supply all metadata, including a View Strategy for Custom Elements.</li>
</ol>
<blockquote>
<p><strong>Note:</strong> Regarding #2 and #3: Do not rely on naming conventions inside plugins. You do not know how the consumer of your plugin will change Aurelia&#39;s conventions. 3rd party plugins should be explicit in order to ensure that they function correctly in different contexts.</p>
</blockquote>
<h4>Promises</h4>
<p>By default, Aurelia uses ES6 native Promises or a polyfill. However, you can replace this with the excellent <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> Promise library. Simply include it in your page before you reference the other scripts. It will provide its own standards-compliant Promise implementation which is currently faster than native and has better debugging support. Additionally, when used in combination with the 6to5 transpiler, you can use <a href="https://6to5.org/docs/usage/transformers/#bluebird-coroutines">coroutines</a> for improved async code.</p>
<h3>The Aurelia Object</h3>
<p>Since both a custom <em>main</em> module and plugins do their work by interacting with the Aurelia object, we provide a brief explanation of that API in code below:</p>
<pre><code class="language-javascript">export class Aurelia {
  loader:Loader; //the module loader
  container:Container; //the app-level dependency injection container
  use:Plugins; //the plugins api

  withInstance(type, instance):Aurelia; //DI helper method (pass through to container)
  withSingleton(type, implementation):Aurelia; //DI helper method (pass through to container)
  withResources(resources):Aurelia; //resource helper method

  start():Promise; //starts the framework, causing plugins to be installed and resources to be loaded
  setRoot(root, applicationHost):Promise; //set your &quot;root&quot; or &quot;app&quot; view-model and display it
}</code></pre>
<h2>Views and View Models</h2>
<p>In Aurelia, user interface elements are composed of <em>view</em> and <em>view-model</em> pairs. The <em>view</em> is written with HTML and is rendered into the DOM. The <em>view-model</em> is written with JavaScript and provides data and behavior to the <em>view</em>. The templating engine and/or DI are responsible for creating these pairs and enforcing a predictable lifecycle for the process. Once instantiated, Aurelia&#39;s powerful <em>databinding</em> links the two pieces together allowing changes in your data to be reflected in the <em>view</em> and vice versa.</p>
<h3>Dependency Injection (DI)</h3>
<p>View-models and other interface elements, such as Template Controllers and Attached Behaviors, are created as classes which are instantiated by the framework using a dependency injection container. Code written in this style is easy to modularize and test. Rather than creating large classes, you can break things down into small objects that collaborate to achieve a goal. The DI can then put the pieces together for you at runtime.</p>
<p>In order to leverage DI you simply need to add a bit of metadata to your class to tell the framwork what it should pass to its constructor. Here&#39;s an example of a view-model that depends on Aurelia&#39;s HttpClient.</p>
<pre><code class="language-javascript">import {HttpClient} from &#39;aurelia-http-client&#39;;

export class CustomerDetail{
    static inject() { return [HttpClient]; }
    constructor(http){
        this.http = http;
    }
}</code></pre>
<p>Just provide a static method named <code>inject</code> that returns an array of things to inject.</p>
<blockquote>
<p><strong>Note:</strong> If writing in TypeScript or CoffeeScript, you can use a static array property instead of a method. In ES5 you can add the property onto the constructor itself. You can also do this with ES6 but we enable the static method option since it can be located closer to the constructor in Vanilla JS. If you are using AtScript, you can actually take advantage of type annotations by defining your constructor like this: <code>constructor(http:HttpClient)</code>. (Before this will work you need to place the <code>atscript</code> attribute on your application host element or call <code>aurelia.use.atscript()</code> manually.)</p>
</blockquote>
<p>The dependencies in your inject array don&#39;t have to be just constructor types. They can also be instances of <code>resolvers</code>. For example, have a look at this:</p>
<pre><code class="language-javascript">import {Lazy} from &#39;aurelia-framework&#39;;
import {HttpClient} from &#39;aurelia-http-client&#39;;

export class CustomerDetail{
    static inject() { return [Lazy.of(HttpClient)]; }
    constructor(getHTTP){
        this.getHTTP = getHTTP;
    }
}</code></pre>
<p>The <code>Lazy</code> resolver doesn&#39;t actually provide an instance of <code>HttpClient</code>. Instead, it provides a function which, when called, will return you an instance of HttpClient. There are several different resolvers out-of-the-box and you can create your own by authoring a class that inherits from <code>Resolver</code>. Here&#39;s a list of what we provide for you:</p>
<ul>
<li><code>Lazy</code> - Injects a function for lazily evaluating the dependency.<ul>
<li>ex. <code>Lazy.of(HttpClient)</code></li>
</ul>
</li>
<li><code>All</code> - Injects an array of all services registered with the provided key.<ul>
<li>ex. <code>All.of(Plugin)</code></li>
</ul>
</li>
<li><code>Optional</code> - Injects an instance of a class only if it already exists in the container; null otherwise.<ul>
<li>ex. <code>Optional.of(LoggedInUser)</code></li>
</ul>
</li>
<li><code>Parent</code> - Bypasses the current DI container and attempts to inject an instance stored in a parent container.<ul>
<li>ex. <code>Parent.of(Router)</code></li>
</ul>
</li>
</ul>
<p>In addition to these resolvers, you can also use <code>Registration</code> annotations to specify the default registration or lifetime for an instance. By default, the DI container assumes that everything is a singleton instance; one instance per container. However, you can use a registration annotation to change this. Here&#39;s an example:</p>
<pre><code class="language-javascript">import {Metadata} from &#39;aurelia-framework&#39;;
import {HttpClient} from &#39;aurelia-http-client&#39;;

export class CustomerDetail{
    static metadata(){ return Metadata.transient(); }
    static inject() { return [HttpClient]; }
    constructor(http){
        this.http = http;
    }
}</code></pre>
<p>Now, each time the DI container is asked for an instance of <code>CustomerDetail</code> the container will return a new instance, rather than a singleton. <code>Singleton</code> and <code>Transient</code> registrations are provided out-of-the-box, but you can create your own by writing a class that inherits from <code>Registration</code>.</p>
<blockquote>
<p><strong>Note:</strong> This last example introduces <em>metadata</em> to provide contextual information to the framework. You will see metadata again when we talk about behaviors.</p>
</blockquote>
<h2>Templating</h2>
<p>Aurelia&#39;s templating engine is responsible for loading your views and their imported resources, compiling your HTML for optimal performance and rendering your UI to the screen. To create a view, all you need to do is author an HTML file with an <code>HTMLTemplate</code> inside. Here&#39;s a simple view:</p>
<pre><code class="language-markup">&lt;template&gt;
    &lt;div&gt;Hello World!&lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>Everything inside the <code>template</code> tag will be managed by Aurelia. However, since Aurelia uses HTMLImport technology to load views, you can also include links, and they will be properly loaded, including relative resource resolution semantics. In other words, you can do this:</p>
<pre><code class="language-markup">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./hello.css&quot;&gt;

&lt;template&gt;
    &lt;div class=&quot;hello&quot;&gt;Hello World!&lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>This enables you to dynamically load per-view style sheets and even Web Components on the fly.</p>
<p>Any time you want to import an Aurelia-specific resource, such as an Aurelia <em>Custom Element</em>, <em>Attached Behavior</em>, <em>Template Controller</em> or <em>Value Converter</em>, you should use an <code>import</code> element inside your view instead. Here&#39;s an example:</p>
<pre><code class="language-markup">&lt;template&gt;
  &lt;import from=&#39;./nav-bar&#39;&gt;&lt;/import&gt;

  &lt;nav-bar router.bind=&quot;router&quot;&gt;&lt;/nav-bar&gt;

  &lt;div class=&quot;page-host&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>In this case <code>nav-bar</code> is an Aurelia <em>Custom Element</em> which we&#39;ve imported for use. Using Aurelia&#39;s <code>import</code> element causes the framework&#39;s resource pipeline to process the imported item, which has the following advantages:</p>
<ul>
<li>Deduping - The resource is downloaded once in the app. Even if other views import the same element, it will not be downloaded again.</li>
<li>One-time Compilation - Templates for Custom Elements imported this way are compiled once for the entire application.</li>
<li>Local Scope - The imported resource is only visible inside the view that imports it, reducing the likelihood of name conflicts.</li>
<li>Renaming - Resources can be renamed upon import if two 3rd party resources with the same name need to be used in the same view.<ul>
<li>ex. <code>&lt;import from=&quot;./nav-bar&quot; as=&quot;foo-bar&quot;&gt;&lt;/import&gt;</code> - Now instead of using a <code>nav-bar</code> element you can use a <code>foo-bar</code> element. (This is based on ES6 where renaming is considered a replacement for using an Alias because it strictly renames the type.)</li>
</ul>
</li>
<li>Packages - The import can point to a module with multiple resources which will all be imported into the same view.</li>
<li>Extensibility - You can define new types of resources which, when imported in this way, can execute custom loading (async one-time) and registration (once per-view).</li>
<li>ES6 - Code is loaded by the ES6 loader rather than the HTMLImport mechanism, enabling all the features and extensibility of your loader.</li>
</ul>
<p>In your view you will often leverage the different types of resources mentioned above as well as databinding.</p>
<blockquote>
<p><strong>Note:</strong> You may be concerned about the tediousness of having to import things into each view. Remember, during the bootstrapping phase you can configure Aurelia with global resources to be available in every view.</p>
</blockquote>
<h3>Databinding</h3>
<p>Databinding allows you to link the state and behavior in a JavaScript object to an HTML view. When this link is established, any changes in linked properties can be synced in one or both directions. Changes in the JavaScript object can be reflected in the view and changes in the view can be reflected in the JavaScript object. To establish this link, you will leverage &quot;binding commands&quot; in your HTML. Binding commands are clearly identifiable via their use of the &quot;.&quot; as a kind of binding operator. Whenever an HTML attribute contains a &quot;.&quot;, the compiler will pass the attribute name and value off to the binding language for interpretation. The result is one or more binding expressions that are capable of establishing the linkage when the view is created.</p>
<p>You can extend the system with your own binding commands, but Aurelia provides a collection to cover the most common use cases.</p>
<h4>bind, one-way, two-way &amp; one-time</h4>
<p>The most common binding command is <code>.bind</code>. This will cause the property to be bound using a &quot;one-way&quot; binding for all attributes, except form element values, which are bound with a &quot;two-way&quot; binding.</p>
<p><em>What does this mean though?</em></p>
<p>One-way binding means that changes flow from your JavaScript view-models into the view, not from the view into the view-model. Two-way binding means that changes flow in both directions. <code>.bind</code> attempts to use a sensible default by assuming that if you are binding to a form element&#39;s value property then you probably wish the changes made in the form to flow into your view-model. For everything else it uses one-way binding, especially since, in many cases, two-way binding to non-form elements would be nonsensical. Here&#39;s a small binding example using <code>.bind</code>:</p>
<pre><code class="language-markup">&lt;input type=&quot;text&quot; value.bind=&quot;firstName&quot;&gt;
&lt;a href.bind=&quot;url&quot;&gt;Aurelia&lt;/a&gt;</code></pre>
<p>In the above example, the <code>input</code> will have its <code>value</code> bound to the <code>firstName</code> property on the view-model. Changes in the <code>firstName</code> property will update the <code>input.value</code> and changes in the <code>input.value</code> will update the <code>firstName</code> property. On the other hand, the <code>a</code> tag will have its <code>href</code> bound to the <code>url</code> property on the view-model. Only changes in the <code>url</code> property will flow into the <code>href</code> of the <code>a</code> tag, not the other way.</p>
<p>You can always be explicit and use <code>.one-way</code> or <code>.two-way</code> in place of <code>.bind</code>though. A common case where this is required is with Web Components that function as input-type controls. So, you can imagine doing something like this:</p>
<pre><code class="language-markup">&lt;markdown-editor value.two-way=&quot;markdown&quot;&gt;&lt;/markdown-editor&gt;</code></pre>
<p>In order to optimize performance and minimize CPU and memory usage, you can alternatively leverage the <code>.one-time</code> binding command to flow data from the view-model into the view &quot;one time&quot;. This will happen during the initial binding phase, after which no synchronization will occur.</p>
<h4>delegate, trigger &amp; call</h4>
<p>Binding commands don&#39;t only connect properties and attributes, but can be used to trigger behavior. For example, if you want to invoke a method on the view-model when a button is clicked, you would use the <code>trigger</code> command like this:</p>
<pre><code class="language-markup">&lt;button click.trigger=&quot;sayHello()&quot;&gt;Say Hello&lt;/button&gt;</code></pre>
<p>When the button is clicked, the <code>sayHello</code> method on the view-model will be invoked. That said, adding event handlers to every single element like this isn&#39;t very efficient, so often times you will want to use event delegation. To do that, use the <code>.delegate</code> command. Here&#39;s the same example but with event delegation instead:</p>
<pre><code class="language-markup">&lt;button click.delegate=&quot;sayHello()&quot;&gt;Say Hello&lt;/button&gt;</code></pre>
<blockquote>
<p><strong>Note:</strong> If you aren&#39;t familiar with event delegation, it&#39;s a technique that uses the bubbling nature of DOM events. When using <code>.delegete</code> a single event handler is attached to the document, rather than on each element. When the element&#39;s event is fired, it bubbles up the DOM until it reaches the document, where it is handled. This is a more memory efficient way of handling events and it&#39;s recommended to use this as your default mechanism.</p>
</blockquote>
<p>All of this works against DOM events in some way or another. Occasionally you may have a custom Aurelia behavior that wants a reference to your function directly so that it can invoke it manually at a later time. To pass a function reference, use the <code>.call</code> binding (since the behavior will <em>call</em> it later):</p>
<pre><code class="language-markup">&lt;div touch.call=&quot;sayHello()&quot;&gt;Say Hello&lt;/button&gt;</code></pre>
<p>Now the attached behavior will get a function that it can call to invoke your <code>sayHello()</code> code.</p>
<h4>string interpolation</h4>
<p>Sometimes you need to bind properties directly into the content of the document or interleave them within an attribute value. For this, you can use the string interpolation syntax <code>${expression}</code>. String interpolation is a one-way binding, the output of which is converted to a string. Here&#39;s an example:</p>
<pre><code class="language-markup">&lt;span&gt;${fullName}&lt;/span&gt;</code></pre>
<p>The <code>fullName</code> property will be interpolated directly into the span&#39;s content. You can also use this to handle css class bindings like so:</p>
<pre><code class="language-markup">&lt;div class=&quot;dot ${color} ${isHappy ? &#39;green&#39; : &#39;red&#39;}&quot;&gt;&lt;/div&gt;</code></pre>
<p>In this snippet &quot;dot&quot; is a statically present class and &quot;green&quot; is present only if <code>isHappy</code> is true, otherwise the &quot;red&quot; class is present. Additionally, whatever the value of <code>color</code> is...that is added as class.</p>
<blockquote>
<p><strong>Note:</strong> You can use simple expressions inside your bindings. Don&#39;t try to do anything too fancy. You don&#39;t want code in your view. You only want to establish the linkage between the view and its view-model.</p>
</blockquote>
<h4>ref</h4>
<p>In addition to commands and interpolation, the binding language recognizes the use of a special attribute: <code>ref</code>. By using <code>ref</code> you can create a local name for an element which can then be referenced in another binding expression. It will also be set as a property on the view-model, so you can access it through code. Here&#39;s a neat example of using <code>ref</code>:</p>
<pre><code class="language-markup">&lt;input type=&quot;text&quot; ref=&quot;name&quot;&gt; ${name.value}</code></pre>
<p>You can also use the special <code>.view-model</code> binding in conjuction with <code>ref</code> to get the view-model instance that backs an Aurelia Custom Element. By using this technique, you can connect different components to each other like so:</p>
<pre><code class="language-markup">&lt;i-produce-a-value ref.view-model=&quot;producer&quot;&gt;&lt;/i-produce-a-value&gt;
&lt;i-consume-a-value input.bind=&quot;producer.output&quot;&gt;&lt;/i-consume-a-value&gt;</code></pre>
<h3>Behaviors</h3>
<p>In addition to databinding, you also have the power of Aurelia behaviors to use in your views. There are three types of behaviors provided out of the box:</p>
<ul>
<li>Custom Elements - Extend HTML with new tags! Your custom elements can have their own views (which use databinding and other behaviors) and optionally leverage <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">ShadowDOM</a> (even if the browser doesn&#39;t support it).</li>
<li>Attached Behaviors - Extend HTML with new attributes which can be added to existing or custom elements. These attributes &quot;attach&quot; new behavior to the elements.</li>
<li>Template Controllers - Create new mechanisms for rendering templates. A template controller is a class that can dynamically create UI and inject it into the DOM.</li>
</ul>
<p>Naturally, all of this works seemlessly with databinding. Let&#39;s look at the behaviors that Aurelia provides for you and which are available globally in every view.</p>
<h4>show</h4>
<p>The <code>show</code> Attached Behavior allows you to conditionally display an HTML element. If the value of show is <code>true</code> the element will be displayed, otherwise it will be hidden. This behavior does not add/remove the element from the DOM, but only changes its visibility. Here&#39;s an example:</p>
<pre><code class="language-markup">&lt;div show.bind=&quot;isSaving&quot; class=&quot;spinner&quot;&gt;&lt;/div&gt;</code></pre>
<p>When the <code>isSaving</code> property is true, the <code>div</code> will be visible, otherwise it will be hidden.</p>
<h4>if</h4>
<p>The <code>if</code> Template Controller allows you to conditionally add/remove an HTML element. If the value is true, the element will also be present in the DOM, otherwise it will not.</p>
<pre><code class="language-markup">&lt;div if.bind=&quot;isSaving&quot; class=&quot;spinner&quot;&gt;&lt;/div&gt;</code></pre>
<p>This example looks similar to that of <code>show</code> above. The difference is that if the binding expression evaluates to false, the <code>div</code> will be removed from the DOM, rather than just hidden.</p>
<p>If you need to conditionally add/remove a group of elements and you cannot place the <code>if</code> behavior on a parent element, then you can wrap those elements in a template tag which has the <code>if</code> behavior. Here&#39;s what that would look like:</p>
<pre><code class="language-markup">&lt;template if.bind=&quot;hasErrors&quot;&gt;
    &lt;i class=&quot;icon error&quot;&gt;&lt;/i&gt;
    ${errorMessage}
&lt;/template&gt;</code></pre>
<h4>repeat</h4>
<p>The <code>repeat</code> Template Controller allows you to render a template multiple times, once for each item in an array. Here&#39;s an example that renders out a list of customer names:</p>
<pre><code class="language-markup">&lt;ul&gt;
    &lt;li repeat.for=&quot;customer of customers&quot;&gt;${customer.fullName}&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>An important note about the repeat behavior is that it works in conjuction with the <code>.for</code> binding command. This binding command interprets a special syntax in the form &quot;item of array&quot; where &quot;item&quot; is the local name you will use in the template and &quot;array&quot; is a normal binding expression that evaluates to an array.</p>
<blockquote>
<p><strong>Note:</strong>: Like the <code>if</code> behavior, you can also use a <code>template</code> tag to group a collection of elements that don&#39;t have a parent element. In fact this is true of all Template Controllers. When you place a Template Controller on an element, it transforms it into an HTMLTemplate during compilation, so you can always explicitly add the template in your markup if you want or need to.</p>
</blockquote>
<h4>compose</h4>
<p>The <code>compose</code> Custom Element enables you to dynamically render UI into the DOM. Imagine you have a heterogeneous array of items, but each has a type property which tells you what it is. You can then do something like this:</p>
<pre><code class="language-markup">&lt;template repeat.for=&quot;item of items&quot;&gt;
    &lt;compose
      model.bind=&quot;item&quot;
      view-model=&quot;widgets/${item.type}&quot;&gt;
    &lt;/compose&gt;
&lt;/template&gt;</code></pre>
<p>Now, depending on the <em>type</em> of the item, the <code>compose</code> element will load a different view-model (and view) and render it into the DOM. If the view-model has an <code>activate</code> method, the <code>compose</code> element will call it and pass in the <code>model</code> as a parameter. The <code>activate</code> method can even return a <code>Promise</code> to cause the composition process to wait until after some async work is done before actually databinding and rendering into the DOM.</p>
<p>The <code>compose</code> element also has a <code>view</code> attribute which can be used in the same way as <code>view-model</code> if you don&#39;t wish to leverage the standard view/view-model convention.</p>
<p>What if you want to determine the view dynamically based on data though? or runtime conditions? You can do that too by implementing a <code>getViewStrategy()</code> method on your view-model. It can return a relative path to the view or an instance of a <code>ViewStrategy</code> for custom view loading behavior. The nice part is that this method is executed after the <code>activate</code> callback, so you have access to the model data when determining the view.</p>
<h4>selected-item</h4>
<p>HTMLSelectElement is an interesting beast. Usually, you can databind these by combining a <code>repeat</code> for the options with a binding on the value, like this:</p>
<pre><code class="language-markup">&lt;select value.bind=&quot;favoriteNumber&quot;&gt;
    &lt;option&gt;Select A Number&lt;/option&gt;
    &lt;option repeat.for=&quot;number of numbers&quot; value.bind=&quot;number&quot;&gt;${number}&lt;/option&gt;
&lt;/select&gt;</code></pre>
<p>But sometimes you want to work with selecting object instances rather than primitives. For that you can use the <code>selected-item</code> attached behavior. Here&#39;s how you would configure that for a theoretical list of employees:</p>
<pre><code class="language-markup">&lt;select selected-item.bind=&quot;employeeOfTheMonth&quot;&gt;
  &lt;option&gt;Select An Employee&lt;/option&gt;
  &lt;option repeat.for=&quot;employee of employees&quot; value.bind=&quot;employee.id&quot; model.bind=&quot;employee&quot;&gt;${employee.fullName}&lt;/option&gt;
&lt;/select&gt;</code></pre>
<p>First, we specify the <code>.bind</code> binding command on <code>selected-item</code>. We then use a repeater as normal, being sure to bind <code>value</code> to some primitive. We also add a second property named <code>model</code> which the <code>selected-item</code> behavior will use to correlate selection with an object instance. In other words, when an option is selected the <code>employeeOfTheMonth</code> property will be set to the value of the <code>model</code> property on that option. When the <code>employeeOfTheMonth</code> property is set in the view-model, the option with the corresponding <code>model</code> value will be selected in the view.</p>
<blockquote>
<p><strong>Note:</strong> We said earlier that only form element values bind two-way by default, but in this case our custom attribute <code>selected-item</code> is also bound with a two-way mode by default. How did that work? It turns out that when you define Aurelia behaviors, you can optionally specify the default binding mode on properties.</p>
</blockquote>
<h4>global-behavior</h4>
<p>This is not an Attached Behavior that you will use directly. Rather, it works in conjunction with a custom binding command to dynamically enable the use of jQuery plugins and similar APIs declaratively in HTML. Let&#39;s look at an example in order to help clarify the idea:</p>
<pre><code class="language-markup">&lt;div jquery.modal=&quot;show: true; keyboard.bind: allowKeyboard&quot;&gt;...&lt;/div&gt;</code></pre>
<p>This sample is based on the <a href="http://getbootstrap.com/javascript/#modals">Bootstrap modal widget</a>. In this case, the <code>modal</code> jQuery widget will be attached to the <code>div</code> and it will be configured with its <code>show</code> option set to <code>true</code> and its <code>keyboard</code> option set to the value of the <code>allowKeyboard</code> property on the view-model. When the containing view is unbound, the jQuery widget will be destroyed.</p>
<p>This capability combines the special <code>global-behavior</code> Attached Behavior with custom syntax to enable these dynamic capabilities. The syntax you see here is based on the syntax of the native <code>style</code> attribute which lists properties and values separated in the same fashion as above. Note that you can use binding commands such as <code>.bind</code> to pass data from your view-model directly to the plugin or <code>.call</code> to pass a callback function directly to the plugin.</p>
<p>Here&#39;s how it works:</p>
<p>When the binding system sees a binding command that it doesn&#39;t recognize, it dynamically interprets it. The attribute name is mapped to a global binding handler which interprets the binding command. The handler can use the values to create an options object which it can pass to the plugin. When the view is unbound, the handler can also cleanup after itself. In this case the jQuery handler knows the pattern for instantiating plugins and using the <code>destroy</code> method to cleanup.</p>
<blockquote>
<p><strong>Note:</strong> The <code>global-behavior</code> has a handlers list you must configure. It is only configured with jQuery by default. You can turn all of this off, if you desire, but it makes it easy to take advantage of basic jQuery plugins without any work on your part.</p>
</blockquote>
<h2>Routing</h2>
<p>There are many different application styles you could be called upon to create. From navigation apps, to dashboards, to MDI interfaces, Aurelia can handle them all. In many of these cases a key component of your architecture is a client-side router, capable of translating url changes into application state.</p>
<p>If you&#39;ve read the getting started guide, you know that there are two parts to routing. First, there&#39;s the <code>Router</code> which lives in your view-model. It&#39;s configured with route information and controls navigation. Then, there&#39;s the <code>router-view</code> which lives in the view and is responsible for displaying whatever the router identifies as the current state.</p>
<p>Let&#39;s look at an example configuration.</p>
<pre><code class="language-javascript">import {Router} from &#39;aurelia-router&#39;;

export class App {
  static inject() { return [Router]; }
  constructor(router) {
    this.router = router;
    this.router.configure(config =&gt; {
      config.title = &#39;Aurelia&#39;;
      config.map([
        { route: [&#39;&#39;, &#39;home&#39;],               moduleId: &#39;home/index&#39; },
        { route: &#39;users&#39;,                    moduleId: &#39;users/index&#39;,                      nav: true },
        { route: &#39;users/:id/detail&#39;,         moduleId: &#39;users/detail&#39; },
        { route: &#39;files*path&#39;,               moduleId: &#39;files/index&#39;,     href:&#39;#files&#39;,   nav: true }
      ]);
    });
  }
}</code></pre>
<p>We begin by asking for a <code>Router</code> to be injected. We then set this instance to a <code>router</code> property on the view-model. <em>You must name the property <strong>router</strong></em>. Then we call the <code>configure</code> api. We pass it a function and it passes us a configuration object.</p>
<p>We can optionally set a <code>title</code> property to be used in constructing the document&#39;s title. But the most important part is setting up the routes. The router&#39;s <code>map</code> method takes a simple JSON data structure representing your route table. The two most important properties are <code>route</code> (a string or array of strings), which defines the route pattern, and <code>moduleId</code>, which has the relative module Id path to your view-model. You can also set a <code>title</code> property, to be used when generating the document&#39;s title, a <code>nav</code> property indicating whether or not the route should be included in the navigation model (it can also be a number indicating order) and an <code>href</code> property which you can use to bind to in the <em>navigation model</em>.</p>
<blockquote>
<p><strong>Note:</strong> Any properties that you leave off will be conventionally determined by the framework based on what you have provided.</p>
</blockquote>
<p>So, what options to you have for the route pattern?</p>
<ul>
<li>static routes<ul>
<li>ie &#39;home&#39; - Matches the string exactly.</li>
</ul>
</li>
<li>parameterized routes<ul>
<li>ie  &#39;users/:id/detail&#39; - Matches the string and then parses an <code>id</code> parameter. Your view-model&#39;s <code>activate</code> callback will be called with an object that has an <code>id</code> parameter set to the value that was extracted from the url.</li>
</ul>
</li>
<li>wildcard routes<ul>
<li>ie &#39;files*path&#39; - Matches the string and then anything that follows it. Your view-model&#39;s <code>activate</code> callback will be called with an object that has a <code>path</code> parameter set to the wildcard&#39;s value.</li>
</ul>
</li>
</ul>
<p>All routes with a truthy <code>nav</code> property are assembled into a <code>navigation</code> array. This makes it really easy to use databinding to generate a menu structure. Another important property for binding is the <code>isNavigating</code> property. Here&#39;s some simple markup that shows what you might pair with the view-model shown above:</p>
<pre><code class="language-markup">&lt;template&gt;
  &lt;ul&gt;
    &lt;li class=&quot;loader&quot; if.bind=&quot;router.isNavigating&quot;&gt;
      &lt;i class=&quot;fa fa-spinner fa-spin fa-2x&quot;&gt;&lt;/i&gt;
    &lt;/li&gt;
    &lt;li repeat.for=&quot;item of router.navigation&quot;&gt;
      &lt;a href.bind=&quot;item.href&quot;&gt;${item.title}&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/template&gt;</code></pre>
<h3>The Screen Activation Lifecycle</h3>
<p>Whenever the router processes a navigation, it enforces a strict lifecycle on the view-models that it is navigating to and from. There are four stages in the lifecycle. You can opt-in to any of them by implementing the appropriate method on your view-model&#39;s class. Here&#39;s a list of the lifecycle callbacks:</p>
<ul>
<li><code>canActivate(params, queryString, routeConfig)</code> - Implement this hook if you want to control whether or not vour view-model <em>can be navigated to</em>. Return a boolean value, a promise for a boolean value, or a navigation command.</li>
<li><code>activate(params, queryString, routeConfig)</code> - Implement this hook if you want to perform custom logic just before your view-model is displayed. You can optionally return a promise to tell the router to wait to bind and attach the view until after you finish your work.</li>
<li><code>canDeactivate()</code> - Implement this hook if you want to control whether or not the router <em>can navigate away</em> from your view-model when moving to a new route. Return a boolean value, a promise for a boolean value, or a navigation command.</li>
<li><code>deactivate()</code> - Implement this hook if you want to perform custom logic when your view-model is being navigated away from. You can optionally return a promise to tell the router to wait until after your finish your work.</li>
</ul>
<p>The <code>params</code> object will have a property for each parameter of the route that was parsed, <code>queryString</code> will have a property for each query string value and <code>routeConfig</code> will be the original route configuration object that you set up.</p>
<blockquote>
<p><strong>Note:</strong> A <em>Navigation Command</em> is any object with a <code>navigate(router)</code> method. When one is encountered, the navigation will be cancelled and control will be passed to the navigation command. One navigation command is provided out of the box: <code>Redirect</code>.</p>
</blockquote>
<h3>Child Routers</h3>
<p>If you haven&#39;t read the &quot;Get Started&quot; guide, we recommend that you do that now and pay special attention to the section titled &quot;Bonus: Leveraging Child Routers&quot;.</p>
<p>Whenever you set up a route to map to a view-model, that view-model can actually contain its own router...and when you set up routes with that...those view-models can have their own routers...and so on. The route patterns are relative to the parent router and the module and view ids are relative to the view-model itself. This allows you to easily encapsulate features or child applications as well as handle complex hierarchical state.</p>
<p>A child router is just a router like any other. So, everything we&#39;ve discussed above applies. To add a child router, just ask for a <code>Router</code> to be injected and configure it with your child routes. The screen activation lifecycle discussed above applies to child routers as well. Each phase of the lifecycle is run against the entire router hierarchy before moving on to the next phase. The activate hooks run from top to bottom and the deactivate hooks run from bottom to top.</p>
<h3>Conventional Routing</h3>
<p>As with everything in Aurelia, we have strong support for conventions. So, you can actually choose to dynamically route rather than pre-configuring all your routes up front. Here&#39;s how you configure a router to do that:</p>
<pre><code class="language-javascript">router.configure(config =&gt; {
  config.mapUnknownRoutes(instruction =&gt; {
    //check instruction.fragment
    //set instruction.config.moduleId
  });
});</code></pre>
<p>All you have to do is set the <code>config.moduleId</code> property and you are good to go. You can also return a promise from <code>mapUnknownRoutes</code> in order to asynchronously determine the destination.</p>
<blockquote>
<p><strong>Note:</strong> Though not necessarily related to conventional routing, you may sometimes have a need to asynchronously configure your router. For example, you may need to call a web service to get user permissions before setting up routes. To do this, implement a callback on your router&#39;s view-model named <code>configureRouter</code>. In this callback you can configure your router and optionally return a Promise if necessary.</p>
</blockquote>
<h2>Extending HTML</h2>
<p>Aurelia has a powerful and extensible HTML template compiler. The compiler itself is just an algorithm for interacting with various <em>behavior types</em> which contain the logic for manipulating HTML. Out of the box, Aurelia provides three core behavior type implementations, which we believe cover the bulk of scenarios you will encounter from day to day. The tree types are <em>Attached Behaviors</em>, <em>Custom Elements</em> and <em>Template Controllers</em>.</p>
<p>Behaviors are not visible to the compiler by default. There are three main ways to plug them in:</p>
<ul>
<li>Use the <code>import</code> element to import a behavior into a view. The <code>from</code> attribute specifies the relative path to the behavior&#39;s module. The behavior will be locally defined.</li>
<li>Use the Aurelia object during your bootstrapping phase to call <code>.withResources(resources)</code> to register behaviors with global visibility in your application.</li>
<li>Install a plugin that registers behaviors with global visibility in your application.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> A reccommended practice for your own apps is to place all your app-specific behaviors, value converters, etc. into a <em>resources</em> folder. Then create an <em>index.js</em> file that turns them all into an internal plugin. Finally, install that plugin during your app&#39;s bootstrapping phase. This will keep your resources located in a known location, along with their registration code. It will also keep your <em>main.js</em> file clean and simple.</p>
</blockquote>
<p>All behaviors can opt into the view lifecycle by implementing any of the followinging hooks:</p>
<ul>
<li><code>bind(bindingContext)</code> - Invoked when the databinding engine binds the view. The binding context is the instance that the view is databound to.</li>
<li><code>unbind()</code> - Invoked when the databinding engine unbinds the view.</li>
<li><code>attached()</code> - Invoked when the view that contains the behavior is attached to the DOM.</li>
<li><code>detached()</code> - Invoked whtn the view that contains the behavior is detached from the DOM.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> If you choose to implement the <code>bind</code> callback, the initial binding of your behavior will flow a little differently. Usually, if you have callbacks for your Behavior Properties, these are each individually called during the bind phase. However, if you add the <code>bind</code> callback, they will not be called during initialization. Rather, the <code>bind</code> callback will be called once all properties have their initial bound values set. This is an important and useful characteristic, particularly for complex behaviors which may not want to &quot;act&quot; until they have all evaluated values available.</p>
</blockquote>
<h3>Attached Behaviors</h3>
<p>Attached behaviors &quot;attach&quot; new behavior or functionality to existing HTML elements by adding a custom attribute to your markup. Common uses for attached behaviors include:</p>
<ul>
<li>Wrapping jQuery and similar plugins (when the <code>global-behavior</code> is insufficient).</li>
<li>Shortcuts for common style, class or attribute bindings.</li>
<li>Just about anything that needs to change an existing HTML element or even a Custom Element which you cannot directly alter.</li>
</ul>
<p>Attached Behaviors tend to represent cross-cutting concerns. For example you might create a custom tooltip behavior that you can then attach to any element. This is a better idea than building tooltip functionality directly into every custom element you create.</p>
<p>Let&#39;s look at one of Aurelia&#39;s own Attached Behavior implementations: <code>show</code>. Here&#39;s how it is used:</p>
<pre><code class="language-markup">&lt;div show.bind=&quot;isSaving&quot; class=&quot;spinner&quot;&gt;&lt;/div&gt;</code></pre>
<p>The <code>show</code> behavior will conditionally apply a class to an element based on the falsiness of its value. (The class, when applied, hides the element.) Here&#39;s the implementation:</p>
<pre><code class="language-javascript">import {Behavior} from &#39;aurelia-templating&#39;;

export class Show {
  static metadata(){
    return Behavior
      .attachedBehavior(&#39;show&#39;)
      .withProperty(&#39;value&#39;, &#39;valueChanged&#39;, &#39;show&#39;);
  }

  static inject() { return [Element]; }
  constructor(element) {
    this.element = element;
  }

  valueChanged(newValue){
    if (newValue) {
      this.element.classList.remove(&#39;aurelia-hide&#39;);
    } else {
      this.element.classList.add(&#39;aurelia-hide&#39;);
    }
  }
}</code></pre>
<p>The first thing to note is that Attached Behaviors are classes and follow the same patterns we&#39;ve already seen. Notice that the <code>metadata</code> plays an important role in defining a behavior. Here&#39;s what the metadata is doing:</p>
<ul>
<li><code>.attachedBehavior(&#39;show&#39;)</code> - Creates an <code>AttachedBehavior</code> metadata instance to tell the HTML compiler how this class &quot;plugs in&quot;. The behavior will be recognized by the compiler any time it sees an attribute named &quot;show&quot;. In Aurelia, Attached Behaviors always map to a single HTML Attribute. There&#39;s a one-to-one relationship.</li>
<li><code>.withProperty(&#39;value&#39;, &#39;valueChanged&#39;, &#39;show&#39;)</code> - Creates a <code>BehaviorProperty</code> that tells the HTML compiler that there&#39;s a specific property on your class that maps to an attribute in HTML. The first parameter of this method is your class&#39;s property name. The last parameter is the attribute name, which is only required if it is different from the property name. The second parameter optionally indicates a callback on the class which will be invoked whenever the property changes.</li>
</ul>
<p>Ok. Let&#39;s talk about conventions.</p>
<ul>
<li>If your callback function is named {propertyName}Changed, then you don&#39;t need to specify it. So, in the above case, we could omit the value of the second parameter.</li>
<li>If your property name and attribute name are the same, then you don&#39;t need to specify it. In the above case, they are different, so we need to specify it.</li>
<li>Attached behaviors always map to a single attribute. This allows us to optmize a simple usage pattern. If you name your property &quot;value&quot;, then you don&#39;t need to include the property metadata at all. We will autommatically map an attribute with the same name as your behavior to the <code>value</code> property.</li>
<li>If you name your class {BehaviorName}AttachedProperty, then you don&#39;t need to indlude the attached behavior metadata at all. The attribute name will be inferred from the class name by stripping off &quot;AttachedBehavior&quot; and lowercasing and hyphenating the remaining part of the name. ie. behavior-name</li>
</ul>
<p>These conventions mean that we can actually define our <code>show</code> behavior like this:</p>
<pre><code class="language-javascript">export class ShowAttachedBehavior {
  static inject() { return [Element]; }
  constructor(element) {
    this.element = element;
  }

  valueChanged(newValue){
    if (newValue) {
      this.element.classList.remove(&#39;aurelia-hide&#39;);
    } else {
      this.element.classList.add(&#39;aurelia-hide&#39;);
    }
  }
}</code></pre>
<blockquote>
<p><strong>Note:</strong> So, why doesn&#39;t Aurelia itself leverage these conventions internally? Any time you are creating a 3rd party library of behaviors, it&#39;s best to be explicit. You don&#39;t know whether or not developers consuming your library will have changed Aurelia&#39;s conventions, thus breaking your library. In order to prevent this, always explicitly state the metadata for behaviors intended to be used in other apps. Inside your own apps though, you can use the conventions all you want to simplify development.</p>
</blockquote>
<p>Next, let&#39;s look at the constructor.</p>
<p>AttachedBehaviors can easily gain access to the HTML element they are attached to by specifying it in the <code>inject</code> array. The <code>show</code> behavior stores the reference so that it can update the <code>classList</code> at a later time.</p>
<p>Finally, let&#39;s look at the <code>valueChanged</code> callback. We said previously that this is configured through the property metadata so that it is called whenever the value changes. The binding system will automatically update properties thus triggering the callback. So, all the implementation has to do is add/remove the appropriate class based on the value.</p>
<blockquote>
<p><strong>Note:</strong> You may be wondering what to do if you want to create an Attached Behavior with multiple properties...since Attached Behaviors always map to a single attribute. For this scenario, we use an <code>OptionsProperty</code> which enables your single attribute to work like the native <code>style</code> attribute, with multiple properties embedded within. Docs on that are forthcoming...</p>
</blockquote>
<h3>Custom Elements</h3>
<p>Custom Elements add new tags to your HTML markup. Each Custom Element can have its own view template which can be rendered into the Light DOM or the Shadow DOM. Custom Elements can also have any number of properties which they surface as attributes in HTML for databinding support and which they can databind to inside their view template.</p>
<p>Why don&#39;t we create a simple custom element so that we can see how that works? We&#39;ll make an element that says hello to someone, called <code>say-hello</code>. Here&#39;s how we want to be able to use it when we&#39;re done:</p>
<pre><code class="language-markup">&lt;template&gt;
    &lt;import from=&quot;./say-hello&quot;&gt;&lt;/import&gt;

    &lt;input type=&quot;text&quot; ref=&quot;name&quot;&gt;
    &lt;say-hello to.bind=&quot;name.value&quot;&gt;&lt;/say-hello&gt;
&lt;/template&gt;</code></pre>
<p>So, how do we build this? Well, we&#39;re going to start with a class, just like we did with the Attached Behavior. Here&#39;s what it looks like:</p>
<h4>say-hello.js</h4>
<pre><code class="language-javascript">import {Behavior} from &#39;aurelia-templating&#39;;

export class SayHello {
  static metadata(){
    return Behavior
      .customElement(&#39;say-hello&#39;)
      .withProperty(&#39;to&#39;);
  }

  speak(){
    alert(&#39;Hello ${this.to}!&#39;);
  }
}</code></pre>
<p>If you read the section on AttachedBehaviors, then you know what this does. There&#39;s some conventions too, which means we can do this if we want:</p>
<h4>say-hello.js (with conventions)</h4>
<pre><code class="language-javascript">import {Behavior} from &#39;aurelia-templating&#39;;

export class SayHelloCustomElement {
  static metadata(){
    return Behavior.withProperty(&#39;to&#39;);
  }

  speak(){
    alert(&#39;Hello ${this.to}!&#39;);
  }
}</code></pre>
<p>Be default, Custom Elements have a view. Here&#39;s the view for ours:</p>
<h4>say-hello.html</h4>
<pre><code class="language-markup">&lt;template&gt;
    &lt;button click.delegate=&quot;speak()&quot;&gt;Say Hello To ${to}&lt;/button&gt;
&lt;/template&gt;</code></pre>
<p>As you can see, we&#39;ve got access to our class&#39;s properties and methods. It&#39;s important to note that you don&#39;t need to declare property metadata for every property you want to bind to in your template. You only need to declare it for properties you want to exist as attribute on your custom element.</p>
<p>That&#39;s really all there is to it. You follow the same view-model/view naming conventions and all the same patterns for custom elements. There are a few unique metadata options for custom elements you should know about:</p>
<ul>
<li><code>.useShadowDOM()</code> - This causes your component&#39;s view to be rendered in the ShadowDOM rather than in the Light DOM. If you aren&#39;t familiar with these terms, have a read through of <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">this article</a>. When using Shadow DOM, you can use <em>content selectors</em> in your view template.</li>
<li><code>.noView()</code> - If your custom element doesn&#39;t have a view, because all its behavior is implemented in code, then use this option.</li>
<li><code>.useView(relativePath)</code> - If you want to use a different view than the one that would be conventionally used, you can use this metadata option to specify a relative path to the view you want to use.</li>
</ul>
<h3>Template Controllers</h3>
<p>Template Controllers convert DOM into an inert HTML template. The controller can then decided when and where (or how many times) to instantiate the template in the DOM. Examples of this are the <code>if</code> and <code>repeat</code> behaviors. Simply place one of these behavior on a DOM node and it becomes a template, controlled by the behavior.</p>
<p>Let&#39;s take a look at the implementation of the <code>if</code> behavior to see how one of these is put together. Here&#39;s the full source code:</p>
<pre><code class="language-javascript">import {Behavior, BoundViewFactory, ViewSlot} from &#39;aurelia-templating&#39;;

export class If {
  static metadata(){
    return Behavior
      .templateController(&#39;if&#39;)
      .withProperty(&#39;value&#39;, &#39;valueChanged&#39;, &#39;if&#39;);
  }

  static inject() { return [BoundViewFactory, ViewSlot]; }
  constructor(viewFactory, viewSlot){
    this.viewFactory = viewFactory;
    this.viewSlot = viewSlot;
    this.showing = false;
  }

  valueChanged(newValue){
    if (!newValue) {
      if(this.view){
        this.viewSlot.remove(this.view);
        this.view.unbind();
      }

      this.showing = false;
      return;
    }

    if(!this.view){
      this.view = this.viewFactory.create();
    }

    if (!this.showing) {
      this.showing = true;

      if(!this.view.bound){
        this.view.bind();
      }

      this.viewSlot.add(this.view);
    }
  }
}</code></pre>
<p>Before we dig into the unique aspects of Template Controllers, let me remind you of what you see here that is simlar. First, we have a simple class with metadata. Our metadata is declared the same as in the two previous behavior types. The conventions work the same as well. So, you could name this class <code>IfTemplateController</code> and you wouldn&#39;t need to specify it in the metadata. Also, you can leave off the property metadata when you declare the <code>valueChanged</code> callback. It follows the same pattern as AttachedBehaviors.</p>
<p>Ok, what&#39;s different? Take a look at the constructor. Our Template Controller has two unique items being injected: <code>BoundViewFactory</code> and <code>ViewSlot</code>.</p>
<p>The <code>BoundViewFactory</code> is capable of generating instances of the the HTML template that the controller is attached to. No need to worry about compiling, etc. That&#39;s taken care of for you. Why is it called &quot;Bound&quot; View Factory though? Well, it&#39;s already referencing the parent binding context. It&#39;s &quot;bound&quot; in a sense. So, if you call its <code>create</code> method it will instantiate a new View from the template which will be bound to that context. This is what you want with an <code>if</code> behavior. It&#39;s not what you want with a <code>repeat</code> behavior. In that case, each time you call <code>create</code> you want a view bound to a particular array item. To achieve this, simply pass any object you want the view to be bound against into the <code>create</code> method.</p>
<p>The <code>ViewSlot</code> represents the slot or location within the DOM that the template was extracted from. This is usually the location that you want to add View instances to.</p>
<blockquote>
<p><strong>Note</strong>: Unlike previous behaviors, the Template Controller works more directly with the <em>primitives</em> of the framework. Views, ViewFactories and ViewSlots are all low level parts of the templating engine.</p>
</blockquote>
<p>Take a close look at the <code>valueChanged</code> callback. Here you can see where the <code>if</code> behavior is creating the view and adding it to the slot, based on the truthiness of the value. There are a few important details of this:</p>
<ul>
<li>The behavior always calls <code>bind</code> on the View <em>before</em> adding it to the ViewSlot. This ensures that all internal bindings are initially evaluated outside of the live DOM. This is important for performance.</li>
<li>Similarly, always call <code>unbind</code> <em>after</em> removing the View from the DOM.</li>
<li>After the View is initially created, the <code>if</code> behavior does not throw it away even when the value becomes false. It caches the instance. Aurelia can re-use Views and even re-target them at different binding contexts. Again, this is important for performance, since it eliminates needless re-creation of Views.</li>
</ul>
<h2>Eventing</h2>
<p>Eventing is a powerful tool when you need decoupled components of your application to talk to one another. Aurelia supports both standard DOM events as well as more application-specific events via the <code>EventAggregator</code>.</p>
<h3>DOM Events</h3>
<p>DOM events should be used when UI-specific messages need to be sent. They should not be used for application-specific messages. Aurelia doesn&#39;t add any functionality beyond the DOM for UI events. Any behavior can have its associated <code>Element</code> injected into its constructor. You can then use the <code>Element</code> to trigger events. To learn more about creating and triggering custom DOM events, <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events">please read this article</a>.</p>
<h3>The Event Aggregator</h3>
<p>If you need loosely coupled application-events, you want to use the <code>EventAggregator</code>. Its streamlined pub/sub interface makes it ideal for a wide range of messaging scenarios.</p>
<p>The Event Aggregator can publish events to a message channel or it can publish strongly-typed messages. Let&#39;s look at publishing to channels first:</p>
<pre><code class="language-javascript">import {EventAggregator} from &#39;aurelia-event-aggregator&#39;;

export class APublisher{
    static inject(){ return [EventAggregator]; }
    constructor(eventAggregator){
        this.eventAggregator = eventAggregator;
    }

    publish(){
        var payload = {}; //any object
        this.eventAggregator.publish(&#39;channel name here&#39;, payload);
    }
}</code></pre>
<p>We begin by having the DI provide us with the singleton Event Aggregator. Next we call its <code>publish</code> method, passing it the message channel name and the data payload to send on that channel. Here&#39;s how a subscriber would set themselvs up to receive this:</p>
<pre><code class="language-javascript">import {EventAggregator} from &#39;aurelia-event-aggregator&#39;;

export class ASubscriber{
    static inject(){ return [EventAggregator]; }
    constructor(eventAggregator){
        this.eventAggregator = eventAggregator;
    }

    subscribe(){
        this.eventAggregator.subscribe(&#39;channel name here&#39;, payload =&gt; {
            //do something with the payload here
        });
    }
}</code></pre>
<p>As you can see, they use the same channel name, but provide a callback, which will be invoked for every message sent on the channel.</p>
<p>Alternatively, you can publish and subscribe to strongly-typed messages. Here&#39;s an example publisher:</p>
<pre><code class="language-javascript">export class SomeMessage{ }</code></pre>
<pre><code class="language-javascript">import {EventAggregator} from &#39;aurelia-event-aggregator&#39;;
import {SomeMessage} from &#39;./some-message&#39;;

export class APublisher{
    static inject(){ return [EventAggregator]; }
    constructor(eventAggregator){
        this.eventAggregator = eventAggregator;
    }

    publish(){
        this.eventAggregator.publish(new SomeMessage());
    }
}</code></pre>
<p>In this case, we publish an instance of a particular message type. Here&#39;s a sample subscriber:</p>
<pre><code class="language-javascript">import {EventAggregator} from &#39;aurelia-event-aggregator&#39;;
import {SomeMessage} from &#39;./some-message&#39;;

export class ASubscriber{
    static inject(){ return [EventAggregator]; }
    constructor(eventAggregator){
        this.eventAggregator = eventAggregator;
    }

    subscribe(){
        this.eventAggregator.subscribe(SomeMessage, message =&gt; {
            //do something with the message here
        });
    }
}</code></pre>
<p>The subscriber will be called any time an instance of <code>SomeMessage</code> is published. Subscription is polymorphic, so if a subclass of SomeMessage is published, this subscriber will be notified as well.</p>
<blockquote>
<p><strong>Note:</strong> All forms of the <code>subscribe</code> method return a <em>dispose function</em>. You can call this function to dispose of the subscription and discontinue receiving messages. A good place to dispose is either in a view-model&#39;s <code>deactivate</code> callback, if it is managed by a router, or in its <code>detached</code> callback, if it is any other view-model.</p>
</blockquote>
<h2>HTTP Client</h2>
<p>As a convenience, Aurelia includes a basic <code>HttpClient</code> to provide a comfortable interface to the browser&#39;s XMLHttpRequest object. <code>HttpClient</code> is not included in the modules that Aurelia&#39;s bootstrapper installs, since its completely optional and many apps may choose to use a different strategy for data retrieval. So, if you want to use it, first you must install it with the following command:</p>
<pre><code class="language-shell">jspm install aurelia-http-client</code></pre>
<p>Then you can use it like this:</p>
<pre><code class="language-javascript">import {HttpClient} from &#39;aurelia-http-client&#39;;

export class WebAPI {
    static inject() { return [HttpClient]; }
    constructor(http){
        this.http = http;
    }

    return getAllContacts(){
        return this.http.get(&#39;uri goes here&#39;);
    }
}</code></pre>
<p>The <code>HttpClient</code> has the following implementation:</p>
<pre><code class="language-javascript">export class HttpClient {
  constructor(baseUrl = null, defaultRequestHeaders = new Headers()){
    this.baseUrl = baseUrl;
    this.defaultRequestHeaders = defaultRequestHeaders;
  }

  send(requestMessage, progressCallback){
    return requestMessage.send(this, progressCallback);
  }

  get(uri){
    return this.send(new HttpRequestMessage(&#39;GET&#39;, join(this.baseUrl, uri))
        .withHeaders(this.defaultRequestHeaders));
  }

  put(uri, content, replacer){
    return this.send(new HttpRequestMessage(&#39;PUT&#39;, join(this.baseUrl, uri), content, replacer || this.replacer)
        .withHeaders(this.defaultRequestHeaders));
  }

  patch(uri, content, replacer){
    return this.send(new HttpRequestMessage(&#39;PATCH&#39;, join(this.baseUrl, uri), content, replacer || this.replacer)
        .withHeaders(this.defaultRequestHeaders));
  }

  post(uri, content, replacer){
    return this.send(new HttpRequestMessage(&#39;POST&#39;, join(this.baseUrl, uri), content, replacer || this.replacer)
        .withHeaders(this.defaultRequestHeaders));
  }

  delete(uri){
    return this.send(new HttpRequestMessage(&#39;DELETE&#39;, join(this.baseUrl, uri))
        .withHeaders(this.defaultRequestHeaders));
  }

  jsonp(uri, callbackParameterName=&#39;jsoncallback&#39;){
    return this.send(new JSONPRequestMessage(join(this.baseUrl, uri), callbackParameterName));
  }
}</code></pre>
<p>As you can see, it provides convenience methods for <code>get</code>, <code>put</code>, <code>patch</code>, <code>post</code>, <code>delete</code> and <code>jsonp</code>. Each of these methods sends an <code>HttpRequestMessage</code> except <code>jsonp</code> which sends a <code>JSONPRequestMessage</code>. The result of sending a message is a <code>Promise</code> for an <code>HttpResponseMessage</code>.</p>
<p>The <code>HttpResponseMessage</code> has the followingn properties:</p>
<ul>
<li><code>response</code> - Returns the raw conent sent from the server.</li>
<li><code>responseType</code> - The expected response type.</li>
<li><code>content</code> - Formats the raw <code>response</code> content based on the <code>responseType</code> and returns it.</li>
<li><code>headers</code> - Returns a <code>Headers</code> object with the parsed header data.</li>
<li><code>statusCode</code> - The server&#39;s response status code.</li>
<li><code>statusText</code> - The server&#39;s textual status message.</li>
<li><code>isSuccess</code> - Indicates whether or not the status code falls within the success range.</li>
<li><code>reviver</code> - A function used to transform the raw <code>response</code> content.</li>
<li><code>requestMessage</code> - A reference to the original request message.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> By default, the <code>HttpClient</code> assumes you are expecting a JSON responseType.</p>
</blockquote>

    </div>
  </div>
</section>

<script src="js/prism.js"></script>
      

      <footer>
        <section id="mainFooter">
          <div class="container" id="footer">
            <div class="row">
              <div class="col-sm-6">
                <p>Copyright © 2015 <a href="http://durandal.io" target="blank">Durandal Inc.</a> / All rights reserved.</p>
              </div>
            </div>
          </div>
        </section>
      </footer>
		</div>

		<!-- End Document 
		================================================== -->
		<script type="text/javascript" src="js-plugin/respond/respond.min.js"></script>
		<script type="text/javascript" src="js-plugin/jquery/jquery.1.10.2.min.js"></script>
		
    <!-- third party plugins  -->
		<script type="text/javascript" src="bootstrap/js/bootstrap.js"></script>
		<script type="text/javascript" src="js-plugin/easing/jquery.easing.1.3.js"></script>
		<script type="text/javascript" src="js-plugin/flexslider/jquery.flexslider-min.js"></script>
		
    <!-- appear -->
		<script type="text/javascript" src="js-plugin/appear/jquery.appear.js"></script>
		<script type="text/javascript" src="js-plugin/pageSlide/jquery.pageslide-custom.js"></script>

		<!-- Custom  -->
		<script type="text/javascript" src="js/custom.js"></script>
    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-38441871-6', 'auto');
      ga('send', 'pageview');
    </script>
	</body>
</html>