{"name":"The Aurelia CLI","description":"Learn how to get setup with the Aurelia CLI and use its basic capabilities.","author":{"name":"Rob Eisenberg","url":"http://robeisenberg.com"},"links":{"static":"docs/build-systems/aurelia-cli","html":"docs/build-systems/aurelia-cli/index.html","fragment":"docs/build-systems/aurelia-cli/index-fragment.html","self":"docs/build-systems/aurelia-cli/index.json"},"content":"\n## Machine Setup\n\nThe CLI itself has a couple of prerequisites that you must install first:\n\n* Install NodeJS version 4.x or above.\n    * You can [download it here](https://nodejs.org/en/).\n* Install a Git Client\n    * Here's [a nice GUI client](https://desktop.github.com).\n    * Here's [a standard client](https://git-scm.com).\n\nOnce you have the prerequisites installed, you can install the Aurelia CLI itself. From the command line, use npm to install the CLI globally:\n\n```Shell\nnpm install aurelia-cli -g\n```\n\n> Info\n> Always run commands from a Bash prompt. Depending on your environment, you may need to use `sudo` when executing npm global installs.\n\n> Warning\n> While creating a new project doesn't require NPM 3, front-end development, in general, requires a flat-package structure, which is not available with NPM versions prior to 3. It is recommended that you update to NPM 3, which will be able to manage this structural requirement. You can check your NPM version with `npm -v`. If you need to update, run `npm install npm -g`.\n\n## Creating A New Aurelia Project\n\nTo create a new project, you can run `au new`. You will be presented with a number of options. If you aren't sure what you want, you can select one of the defaults. Otherwise, you can create a custom project. Simply follow the prompts.\n\nOnce you've made your choice, the CLI will show you your selections and ask if you'd like to create the file structure. After that, you'll be asked if you would like to install your new project's dependencies.\n\nOnce the dependencies are installed, your project is ready to go.\n\n### ASP.NET Core\n\nIf you would like to use ASP.NET Core, first begin by using Visual Studio to create your ASP.NET Core project. Select whatever options make the most sense based on your .NET project plans. After you have created the project, open a command line and change directory into your web project's project folder. This is the folder that contains the `.xproj` file. From within this folder, you can execute the following command `au new --here` which will setup Aurelia \"here\" inside this project folder. You will be prompted to choose the platform you want. Simply select \"ASP.NET Core\". Follow the prompts for the rest of the process, just like above.\n\nSince the Aurelia-CLI should be in charge of building your client side code, make sure that before running the `new` command from **Aurelia-CLI** you add the following to your .xproj file inside the first `PropertyGroup` you find.\n\n<code-listing>\n  <source-code lang=\"XML\">\n    <PropertyGroup>\n      <TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>\n    </PropertyGroup>\n  </source-code>\n</code-listing>\n\nThis will stop Visual Studio from compiling the `.ts` files in your project. If you build your solution before doing this, Visual Studio will compile your `.ts` files, breaking some of the **Aurelia-CLI** commands.\n\n## Running Your Aurelia App\n\nFrom inside your project folder, simply execute `au run`. This will build your app, creating all bundles in the process. It will start a minimal web server and serve your application. If you would like to develop, with auto-refresh of the browser, simply specify the `--watch` flag like this: `au run --watch`.\n\n### Environments\n\nThe CLI build system understands that you might run your code in different environments. By default, you are set up with three: `dev`, `stage` and `prod`. You can use the `--env` flag to specify what environment you want to run under. For example: `au run --env prod --watch`.\n\n## Building Your App\n\nAurelia CLI apps always run in bundled mode, even during development. To build your app, simply run `au build`. You can also specify an environment to build for. For example: `au build --env stage`.\n\n## Deploying Your App\n\nRun the following build command:\n\n```Shell\nau build --env prod\n```\n\nThen copy the file `index.html` and the folder `/scripts`  to the main deployment folder on your server.\n\n## Unit Testing\n\nIf you selected a project setup that includes unit tests, you can run your tests with `au test`. If you would like to adopt a tdd-based workflow, writing code and tests with continual test evaluation, you can use the `--watch` flag. For example: `au test --watch`.\n\n## Generators\n\nExecuting `au generate resource` runs a generator to scaffold out typical Aurelia constructs. Options for *resource* are: element, attribute, value-converter, binding-behavior, task and generator. That's right...there's a generator generator so you can write your own. Ex. `au generate element`\n\n## Build Revisions\n\nTo create builds with revision numbers, you must set `rev` to be `true` under the build options. This will cause a unique revision number to be added to the bundled files. For example:\n\n```JSON\n\"options\": {\n  \"minify\": \"stage & prod\",\n  \"sourcemaps\": \"dev & stage\",\n  \"rev\": true\n}\n```\n\nYou are also able to set specific flags so that build revisions only take place while staging or in production. For example:\n\n```JSON\n\"options\": {\n  \"minify\": \"stage & prod\",\n  \"sourcemaps\": \"dev & stage\",\n  \"rev\": \"stage & prod\"\n}\n```  \n\nNow, if you were to run `au build --env prod`, the output would contain build revisions, while `au build --env dev` would not. Setting the build revisions to only compile while in production can help the development process, since it keeps your workspace clean of various build revisions.\n\n### Modifying The Index File\n\nIn order for your `index.html` file to be updated to load up the correct revisioned bundle, you must ensure that the `\"index\"` property located in `build/targets` section is correctly pointing to the `index.html` (or starting page) for your project. For example:\n\n``` JSON\n\"build\": {\n  \"targets\": [\n    {\n      \"id\": \"web\",\n      \"displayName\": \"Web\",\n      \"output\": \"scripts\",\n      \"index\": \"index.html\"\n    }\n  ]\n}\n```\n\n## Bundling Your Project\n\nBy default, the Aurelia CLI creates two bundles, an `app-bundle.js`, and a `vendor-bundle.js`. An example of the default `app-bundle.js` looks like this:  \n\n```JSON\n{\n  \"name\": \"app-bundle.js\",\n  \"source\": [\n    \"[**/*.js]\",\n    \"**/*.{css,html}\"\n  ]\n}\n```  \n\nIn this setup, we've named the bundle `app-bundle.js`, and have defined what's included by setting the `source` property to be an array of patterns that match to file paths (the patterns are using glob patterns, [minimatch](https://github.com/isaacs/minimatch) to be specific, to find files that match).  \nOptionally, you can define an `exclude` list by setting the `source` property to be an object containing both an `include` and `exclude` array of patterns. This is helpful when you're trying to define multiple bundles from your source code.  \n\n```JSON\n{\n  \"name\": \"app-bundle.js\",\n  \"source\": {\n    \"include\": [\n      \"[**/*.js]\",\n      \"**/*.{css,html}\"\n    ],\n    \"exclude\": [\n      \"**/sub-module/**/*\",\n    ]\n  }\n},\n{\n  \"name\": \"sub-module-bundle.js\",\n  \"source\": [\n    \"**/sub-module/**/*\",\n  ]\n}\n```\n\n## Adding Client Libraries to Your Project\n\nThe CLI provides two commands to help you add 3rd party client libraries, `au install <library>` and `au import <library>`. The `install` command will download, install and add the library to the configuration file `aurelia_project/aurelia.json`. The `import` command will add a library that you've previously installed with npm to the configuration file. Finally, both commands will give you instructions on how to access the library from your code.\n\n### Manual configuration\n\nUnfortunately, not all 3rd party libraries can be successfully configured automatically by the `install` and `import` commands. In order the remedy this by manual configuration, open the `aurelia_project/aurelia.json` file and scroll down to the `build.bundles` section. You'll need to add the library into one of your bundle's `dependencies` sections.\n\nBelow is some guidance for how to manually configure several different common 3rd party library scenarios:\n\n### A Single-File Module\n\nIf the library you have installed is a single CommonJS or AMD file, you can add an entry similar to the following to the dependencies of your bundle:\n\n<code-listing heading=\"A Single File Module Dependency\">\n  <source-code lang=\"JSON\">\n    \"dependencies\": [\n      {\n        \"name\": \"library-name\",\n        \"path\": \"../node_modules/library-name/dist/library-name\"\n      }\n    ]\n  </source-code>\n</code-listing>\n\n* `name` - This is the name of the library as you will import it in your JavaScript or TypeScript code.\n* `path` - This is a path to the single module file itself. This path is relative to your application's `src` folder. Also, you should not include the file extension. `.js` will be appended automatically.\n\nIf the `main` field of the library's `package.json` points to the single file that you need to bundle, then you can opt for a simplified configuration by just adding the package name to your dependencies directly:\n\n<code-listing heading=\"A Single File Module Dependency via Main\">\n  <source-code lang=\"JSON\">\n    \"dependencies\": [\n      \"library-name\"\n    ]\n  </source-code>\n</code-listing>\n\n\n### A CommonJS Package\n\nMany modules installed through NPM are packages made up of multiple source files. Configuring a library like this is a bit different than the single-file scenario above. Here's an example configuration for a multi-file package:\n\n<code-listing heading=\"A CommonJS Package Dependency\">\n  <source-code lang=\"JSON\">\n    \"dependencies\": [\n      {\n        \"name\": \"aurelia-testing\",\n        \"path\": \"../node_modules/aurelia-testing/dist/amd\",\n        \"main\": \"aurelia-testing\",\n        \"env\": \"dev\"\n      }\n    ]\n  </source-code>\n</code-listing>\n\n\n* `name` - This is the name of the library as you will import it in your JavaScript or TypeScript code.\n* `path` - This is a path to the folder where the package's source is located. This path is relative to your application's `src` folder.\n* `main` - This is the main module (entry point) of the package, relative to the `path`. You should not include the file extension. `.js` will be appended automatically. Set `main` to `false` when the package does not have a main file.\n\n> Info: Environment-Specific Dependencies\n> We've also shown how to use the `env` setting on a dependency. This can be used on any dependency in the bundle to indicate what environment builds the dependency should be included in. By default, dependencies are included in all builds. The example above shows how to include the library only in builds targeting the \"dev\" environment. You can also specify multiple environments like `dev & stage`.\n\n### A Legacy Library\n\nLibraries that predate module systems can be a pain because they often rely on global scripts which must be loaded before the library. These libraries also add their own global variables. An example of one such library is [bootstrap](http://getbootstrap.com/css/). Let's take a look at how to handle a legacy library like that.\n\n<code-listing heading=\"A Legacy Library Dependency\">\n  <source-code lang=\"JSON\">\n    \"dependencies\": [\n      {\n        \"name\":\"jquery\",\n        \"path\":\"../node_modules/jquery/dist\",\n        \"main\":\"jquery.min\",\n        \"exports\": \"$\"\n      },\n      {\n          \"name\": \"bootstrap\",\n          \"path\": \"../node_modules/bootstrap/dist\",\n          \"main\": \"js/bootstrap.min\",\n          \"deps\": [\"jquery\"]\n      }\n    ]\n  </source-code>\n</code-listing>\n\n* `name` - This is the name of the library as you will import it in your JavaScript or TypeScript code.\n* `path` - This is a path to the folder where the package's source is located. This path is relative to your application's `src` folder.\n* `main` - This is the main module (entry point) of the package, relative to the `path`. You should not include the file extension. `.js` will be appended automatically.  Set `main` to `false` when the package does not have a main file.\n* `deps` - This is an array of dependencies which must be loaded and available before the legacy library can be evaluated.\n* `exports` - This is the name of the global variable that should be used as the exported value of the module.\n\nNotice first that we've included \"jquery\" as one of our dependencies, *and specifically at the beginning of the dependency list*.  \nWe are using the `exports` property to export the jQuery object since jQuery plugin, like Bootstrap, attach their APIs to the jQuery object itself.  (This could be any global variable, though.)  Finally, below that we configure `bootstrap`. The first three properties are the same as in our package example above. However, now we have a `deps` list. We've included `jquery` since Bootstrap needs it to be present before it can load.\n\n### A Library with Additional Resources\n\nThe Bootstrap example above results in the bundling of the JavaScript portions of the library. But, as you probably know, Bootstrap is mostly about CSS. The CSS files distributed with Bootstrap aren't traceable through the module system so this still doesn't result in the Bootstrap CSS being bundled. Here's how we solve that problem:\n\n<code-listing heading=\"A Library with Additional Resources\">\n  <source-code lang=\"JSON\">\n    \"dependencies\": [\n      {\n        \"name\":\"jquery\",\n        \"path\":\"../node_modules/jquery/dist\",\n        \"main\":\"jquery.min\",\n        \"exports\": \"$\"\n      },\n      {\n          \"name\": \"bootstrap\",\n          \"path\": \"../node_modules/bootstrap/dist\",\n          \"main\": \"js/bootstrap.min\",\n          \"deps\": [\"jquery\"],\n          \"resources\": [\n            \"css/bootstrap.css\"\n          ]\n      }\n    ]\n  </source-code>\n</code-listing>\n\nNotice that we've added a `resources` array. Here we can provide a list of additional files to be included with the bundle. These files are relative to the `path` designated above and must include the file extension. You can also use glob patterns in place of exact file names.\n\nThe final step to make Bootstrap work is to copy the necessary font files to the `bootstrap/fonts` folder, which by default is where Bootstrap will look for the font files. To do this, we should declare these files in the `copyFiles` property, after the `bundles` property.\n\n```JSON\n\"bundles\": [ ... ],\n\"copyFiles\": {\n    \"node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.woff2\": \"bootstrap/fonts\",\n    \"node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.woff\": \"bootstrap/fonts\",\n    \"node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.ttf\": \"bootstrap/fonts\"\n  }\n```\n\nNow, the font files will be copied to the `bootstrap/fonts` folder when building the application.\n\n> Info: Setup for copying files\n> The `copyFiles` works as a 'from':'to' setup, where 'from' is the location of the file you want to copy, and 'to' is the destination folder. Both paths are relative to project folder. The sintax is:\n>\n```JSON\n\"bundles\": [ ... ],\n\"copyFiles\": {\n  FILE_YOU_WANT_TO_COPY_BASED_ON_PROJECT_FOLDER: DESTINATION_FOLDER_BASED_ON_PROJECT_FOLDER\n}\n```\n\n> Warning\n> If you run the application providing the `--watch` flag, the files will be recopied when changed.\n\n> Info\n> Remember that CSS bundled in this way is bundled as a text resource designed to be required in your view. To load the Bootstrap css file in a view, use `<require from=\"bootstrap/css/bootstrap.css\"></require>`. Notice that the module name derives from combining the `name` property with the resource.\n\n### A Very Stubborn Legacy Library\n\nSometimes you can't get a library to work with the module loading system. That's ok. You can still include it in the bundle, using traditional concatenation techniques. In fact, this is how the CLI bundles up the loader and promise polyfills. These items don't go into the `dependencies` section but instead go into the `prepend` section. This is because they aren't module dependencies. They also aren't relative to the `src`, but relative to the project folder. Using the `prepend` section causes the scripts to be prepended to the beginning of the bundle, using normal script concatenation techniques. Here's a full vendor bundle example, showing this and the rest of the techniques listed above.\n\n<code-listing heading=\"A Sample Bundle\">\n  <source-code lang=\"JSON\">\n    {\n      \"name\": \"vendor-bundle.js\",\n      \"prepend\": [\n        \"node_modules/bluebird/js/browser/bluebird.core.js\",\n        \"scripts/require.js\"\n      ],\n      \"dependencies\": [\n        \"aurelia-binding\",\n        \"aurelia-bootstrapper\",\n        \"aurelia-dependency-injection\",\n        \"aurelia-event-aggregator\",\n        \"aurelia-framework\",\n        \"aurelia-history\",\n        \"aurelia-history-browser\",\n        \"aurelia-loader\",\n        \"aurelia-loader-default\",\n        \"aurelia-logging\",\n        \"aurelia-logging-console\",\n        \"aurelia-metadata\",\n        \"aurelia-pal\",\n        \"aurelia-pal-browser\",\n        \"aurelia-path\",\n        \"aurelia-polyfills\",\n        \"aurelia-route-recognizer\",\n        \"aurelia-router\",\n        \"aurelia-task-queue\",\n        \"aurelia-templating\",\n        \"aurelia-templating-binding\",\n        \"nprogress\",\n        \"jquery\",\n        {\n          \"name\": \"bootstrap\",\n          \"path\": \"../node_modules/bootstrap/dist\",\n          \"main\": \"js/bootstrap.min\",\n          \"deps\": [\"jquery\"],\n          \"exports\": \"$\",\n          \"resources\": [\n            \"css/bootstrap.css\"\n          ]\n        },\n        {\n          \"name\": \"text\",\n          \"path\": \"../scripts/text\"\n        },\n        {\n          \"name\": \"aurelia-templating-resources\",\n          \"path\": \"../node_modules/aurelia-templating-resources/dist/amd\",\n          \"main\": \"aurelia-templating-resources\"\n        },\n        {\n          \"name\": \"aurelia-templating-router\",\n          \"path\": \"../node_modules/aurelia-templating-router/dist/amd\",\n          \"main\": \"aurelia-templating-router\"\n        },\n        {\n          \"name\": \"aurelia-testing\",\n          \"path\": \"../node_modules/aurelia-testing/dist/amd\",\n          \"main\": \"aurelia-testing\",\n          \"env\": \"dev\"\n        }\n      ]\n    }\n  </source-code>\n</code-listing>\n\n### A Very Stubborn Legacy Library With Plugins\n\nSome legacy libraries may support plugins which you also want included in your bundle. In some cases these plugins depend on a global object defined by the main library, so it is important that the plugins exist later in the bundle than the main library scripts. These plugins can go in the `append` section, which works exactly the same as the `prepend` section but the scripts are appended to the end of the bundle, after all other items.  Like the `prepend` section all items are relative to the project folder, not the `src`.\n\n### A note on NPM's scoped packages\n\nThe CLI treats [scoped packages](https://docs.npmjs.com/misc/scope) in the same way as unscoped ones, you just need to remember that the scope is always part of its name.\n\nSo, for example, if you need to consume a scoped package in a CLI project, you need the following in your `aurelia.json`:\n\n```JSON\n\"dependencies\": [\n  {\n    \"name\": \"@scope/packagename\",\n    \"path\": \"../node_modules/@scope/packagename/dist/amd\",\n    \"main\": \"packagename\"\n  }\n]\n```\n\nYour imports must be scoped too:\n\n```JavaScript\nimport { SomeClass } from '@scope/packagename';\n```\n\nAnd this is an example of loading a `@scope/packagename` plugin during app startup:\n\n```JavaScript\naurelia.use.standardConfiguration().plugin('@scope/packagename');\n```\n\n### Reference packages outside of the node_modules folder\n\nIt is possible to use packages outside of the node_modules folder. The only difference is that you need to define what the `packageRoot` is. In `aurelia.json`, you can define a package that lives outside of the node_modules folder as follows:\n\n<code-listing heading=\"Package outside of node_modules\">\n  <source-code lang=\"JSON\">\n    \"dependencies\": [{\n      \"name\": \"my-standalone-folder\",\n      \"path\": \"../my-standalone-folder/dist/amd\",\n      \"main\": \"index\",\n      \"packageRoot\": \"../my-standalone-folder\"\n    }]\n  </source-code>\n</code-listing>\n\nThe `packageRoot` is the root folder of the package. This is often the folder which contains the `package.json` file of the package.\n\n## Configuring the Loader\n\nYou can configure the loader by adding a `config` key to `build.loader` with the options you want to add. For instance, if you want to increase the timeout for requirejs, you would do this:\n\n```JSON\n\"build\": {\n  \"loader\": {\n    \"type\": \"require\",\n    \"configTarget\": \"vendor-bundle.js\",\n    \"includeBundleMetadataInConfig\": \"auto\",\n    \"config\": {\n      \"waitSeconds\": 60\n    }\n  }\n}\n```\n\n**Setting the baseUrl**\n\nSometimes you may want to keep the scripts folder somewhere other than the default location, or move the index.html file a few folders up from the project root. In that case it is possible to set the `baseUrl` property so that the build system uses the correct paths and that bundles get loaded correctly in the browser. The `baseUrl` property should be set in both the `platform` object as well as the `build.targets` object:\n\n<code-listing heading=\"baseUrl\">\n  <source-code lang=\"JSON\">\n    \"targets\": [\n      {\n        \"id\": \"web\",\n        \"displayName\": \"Web\",\n        \"output\": \"some/dir/scripts\",\n        \"index\": \"index.html\",\n        \"baseUrl\": \"some/dir/scripts\"\n      }\n  </source-code>\n</code-listing>\n\nThe script tag for the bundle in `index.html` file needs to point to the modified location of the scripts folder as well: `<script src=\"some/dir/scripts/vendor-bundle.js\" data-main=\"aurelia-bootstrapper\"></script>`\n\n## Styling your Application\n\nThere are many ways to style components in Aurelia. The CLI sets up your project to only process styles inside your application's `src` folder. Those styles can then be imported into a view using Aurelia's `require` element.\n\n* If you aren't using any CSS preprocessor, you write css and then simply require it in the view like this:\n\n<code-listing heading=\"Requiring styles.css\">\n  <source-code lang=\"HTML\">\n    <require from=\"./styles.css\"></require>\n  </source-code>\n</code-listing>\n\n* For projects that use a CSS preprocessor (chosen from the cli setup questions):\n  * Write your styles in the format you chose (styl, sass, less ...).\n  * Require the style by `[filename].css` instead of `[filename].[extension]`. This is because\n      your style file is transpiled into a module that encodes the resulting `css` file extension.\n\n<code-listing heading=\"Requiring main.sass\">\n  <source-code lang=\"HTML\">\n    <require from =\"./main.css\"></require>\n  </source-code>\n</code-listing>\n\nBear in mind that you can always configure things any way you want by modifying the tasks in the `aurelia_project/tasks` folder.\nFor styling purposes, you can modify the `process-css.js` file.\n\n\n## What if I forget this stuff?\n\nIf you need your memory refreshed as to what the available options are, at any time you can execute `au help`. If you aren't sure what version of the CLI you are running, you can run `au -v`;\n\n## Troubleshooting\n\n_**I updated aurelia-cli and now executing `au run` returns `\"Invalid Command: run\"`**_\n\nThere appears to be an ongoing issue with npm's cache that can affect the upgrade of the aurelia-cli. Clearing the npm-cache appears to resolve the issue.\nSteps:\n * `npm uninstall aurelia-cli -g`\n * delete the contents under c:/Users/NAME/AppData/Roaming/npm-cache\n * `npm install aurelia-cli -g`\n\n## Updating A Single Library\n\nTo update a single library use the command `npm install library-name` where library-name is the library that you wish to update.  \n\n## Updating Multiple Libraries\n\n* Add the following section to the project's package.json file\n\n```JSON\n\"scripts\": {\n  \"au-update\": \"npm install aurelia-binding@latest aurelia-bootstrapper@latest ...\"\n}\n```\n\n* List the libraries on a single line separated by a space.\n* Include all of the libraries from the dependencies section of aurelia.json that you want to update.\n* Use the command `npm run au-update` to update all of the libraries in the au-update list above.\n\n## Javascript Minification\n\nThe CLI will minify Javascript out of the box for the staging and production environments:\n\n<code-listing heading=\"Default minification settings\">\n  <source-code lang=\"JSON\">\n    \"options\": {\n      \"minify\": \"stage & prod\",\n      \"sourcemaps\": \"dev & stage\"\n    },\n  </source-code>\n</code-listing>\n\nThese options can be found in the `\"build\".\"options\"` section of `aurelia.json`. If you wish to specify the options that are used in the minification process, then replace `\"minify\": \"stage & prod\"` with:\n\n<code-listing heading=\"Default minification settings\">\n  <source-code lang=\"JSON\">\n    \"minify\": {\n      \"dev\": false,\n      \"default\": {\n        \"indent_level\": 2\n      },\n      \"stage & prod\": {\n        \"max-line-len\": 100000\n      }\n    },\n  </source-code>\n</code-listing>\n\nThe Aurelia-CLI uses [UglifyJS2](https://github.com/mishoo/UglifyJS2) for minification, so any option that UglifyJS2 supports is also supported by the Aurelia-CLI. With the above configuration, minification will occur for the `stage` and `prod` environments, but not for the `dev` environment. For the `stage` and `prod` environments, both the `indent_level` as well as the `max-line-len` option are passed to the minifier. The `default` key is optional, but allows you to reduce code duplication when multiple environments have similar options.\n"}