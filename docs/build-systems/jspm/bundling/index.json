{"name":"JSPM Bundling","description":"Before deploying your app to production, you'll want to bundle the assets for efficient use of the network.","author":{"name":"Shuhel Ahmed","url":"https://github.com/ahmedshuhel"},"links":{"static":"docs/build-systems/jspm/bundling","html":"docs/build-systems/jspm/bundling/index.html","fragment":"docs/build-systems/jspm/bundling/index-fragment.html","self":"docs/build-systems/jspm/bundling/index.json"},"content":"\n## Introduction\n\nMost of the current major browsers limit the number of simultaneous connections per hostname to six. This means that while six requests are being processed, additional requests for assets on a host will be queued by the browser. In the image below, the Chrome F12 developer tools network tab shows the timing for assets required by the `welcome view` of the skeleton-navigation application.\n\n![No of requests made by unbundled application](img/unbundled-aurelia-application.jpg)\n\nAs we can see, there are over 95 requests being made to load the first view. While the first few requests are being processed the others are waiting, ultimately taking almost 2.39s on a local machine.\n\nIn the past, the most common browser limit has been 2 connections. This may have been sufficient in the beginning of the web when most of the content was delivered in a single page load. However, it can soon become the bottleneck when building rich client applications with frameworks like Aurelia and others.\n\nYou may wonder: If this limit can have such a great impact on performance, then why don't browsers give us a higher limit? Most well-known browsers choose not to grant this wish in order to prevent the server from being overloaded by a small number of browsers. Such activity would be similar in nature to a DDOS attack.\n\n## Bundling & Minification\n\nThis connection limit will not cause slowness in our application if we can manage resources well enough to avoid it. When the page is first loaded, this is the initial request that returns HTML content. When the browser processes the HTML content, it spawns more requests to load resources like JS, CSS and images. It also executes JavaScript and sends AJAX requests to the server.\n\nTo make this process efficient, we need to compress the assets and make fewer (possibly less than 6) requests to load everything we need. Fortunately, static resources can be cached and only downloaded the first time. If they cause slowness, it happens on the first page load only and may be tolerable.\n\nBundling along with minification are techniques that can also be used to improve load time. Bundling and minification improve load time by reducing the number of requests to the server as well as reducing the size of requested assets such as views, view-models and CSS.\n\n## Bundling an Aurelia JSPM Application\n\nWe can  use [Aurelia Bundler](http://github.com/aurelia/bundler) to create a gulp task for bundling our JSPM app. Let's jump right into it. We will use the `skeleton-navigation` as our app to bundle. If you don't have that set up. Follow [these steps](https://github.com/aurelia/skeleton-navigation#running-the-app).\n\nNow that we have our app running, let's start by installing `aurelia-bundler`. To do so `cd` into `skeleton-navigation` and run the following command:\n\n```Shell\nnpm install aurelia-bundler --save-dev\n```\n\nNow, let's create a `bundle.js` file in `build/tasks/bundle.js` as follows:\n\n<code-listing heading=\"bundle.js\">\n  <source-code lang=\"JavaScript\">\n    var gulp = require('gulp');\n    var bundle = require('aurelia-bundler').bundle;\n\n    var config = {\n      force: true,\n      baseURL: '.',                   // baseURL of the application\n      configPath: './config.js',      // config.js file. Must be within `baseURL`\n      bundles: {\n        \"dist/app-build\": {           // bundle name/path. Must be within `baseURL`. Final path is: `baseURL/dist/app-build.js`.\n          includes: [\n            '[*.js]',\n            '*.html!text',\n            '*.css!text'        \n          ],\n          options: {\n            inject: true,\n            minify: true\n          }\n        },\n        \"dist/vendor-build\": {\n          includes: [\n            'aurelia-bootstrapper',\n            'aurelia-fetch-client',\n            'aurelia-router',\n            'aurelia-animator-css',\n            'github:aurelia/templating-binding',\n            'github:aurelia/templating-resources',\n            'github:aurelia/templating-router',\n            'github:aurelia/loader-default',\n            'github:aurelia/history-browser',\n            'github:aurelia/logging-console',\n            'bootstrap/css/bootstrap.css!text'\n          ],\n          options: {\n            inject: true,\n            minify: true\n          }\n        }\n      }\n    };\n\n    gulp.task('bundle', function() {\n      return bundle(config);\n    });\n  </source-code>\n</code-listing>\n\n\n> Info\n> The bundle function returns a Promise for proper integration into async task engines like Gulp.\n\nWith that file in place, let's run the command below:\n\n```Shell\ngulp bundle\n```\n\nHere are the things that should have happened after Gulp is finished executing the bundle task:\n\n* A file, `dist/app-build.js` is created.\n* A file, `dist/vendor-build.js` is created.\n* `config.js` is updated.\n\nNow, if we refresh/reload the app from the browser, we will see much less network traffic. This means that our app is properly bundled.\n\n![No of requests made by bundled application](img/bundled-aurelia-application.jpg)\n\nJust 9 requests tells the story. We have also managed to minimize the size from 1.2MB to just 773KB here.\n\n## Multiple Bundles\n\nWe can create as many bundles as we want. Here we have created two: one for our application code and another for Aurelia and third-party libraries.\n\nWe can create just a single bundle, if we want, that combines both application code and third-party libraries. The number of bundles we would like to have mostly depends on our application structure and the usage patterns of our app. For example, if our app was built in a modular fashion, such that it is a collection of child-app/sections, then a `common` bundle for third-party libraries and a `bundle per section` makes much more sense and performs better than a huge single bundle that needs to be loaded up front.\n\n## Bundling a JSPM v0.17 App\n\nIn a JSPM v0.17 style app, we have two separate config files: `jspm.browser.js` and `jspm.config.js`. In such case the `configPath` in the bundle config should look like: `configPath: ['./jspm.browser.js', './jspm.config.js']`. We also have to add another `injectionConfigPath` to indicate which config file should host the bundle and depCache injection. Here is a typical bundle configuration for a `JSPM v0.17` app.\n\n<code-listing heading=\"bundle.js\">\n  <source-code lang=\"JavaScript\">\n    var config = {\n      force: true,\n      baseURL: '.',             // baseURL of the application\n      configPath: [             // SystemJS/JSPM configuration files\n        './jspm.browser.js',\n        './jspm.config.js'\n      ],        \n      injectionConfigPath: './jspm.config.js',  // Configuration file path where bundle and depCache meta will be injected.\n      bundles: {\n        \"dist/app-build\": {     // bundle name/path. Must be within `baseURL`. Output path will look like: `baseURL/dist/app-build.js`.\n          includes: [\n            '[*.js]',\n            '*.html!text',\n            '*.css!text'        \n          ],\n          options: {\n            inject: true,\n            minify: true\n          }\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n\n## Duplicate Modules in Multiple Bundles\n\nCreating multiple bundles requires us to be extra careful because multiple bundles may contain duplicate modules. Before explaining that, we need to understand how bundling works behind the scenes a bit. Let's consider the example modules `A` and `B` below:\n\n<code-listing heading=\"a.js\">\n  <source-code lang=\"JavaScript\">\n    import b from './b';\n    console.log('Hi, I am module A');\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"b.js\">\n  <source-code lang=\"JavaScript\">\n    console.log('Hi, I am module B');\n  </source-code>\n</code-listing>\n\nWhen we want to bundle `a.js`, the bundler will analyze the source code of the module and find the dependencies by tracing the `import` statements. In this case, the bundler will yield `b.js` as the dependency of `a.js` and ultimately place `b.js` in the bundle.\n\nLet us now take a closer look at the `config` object. We will skip `force` and `packagePath` for the moment. `bundles` is where we will focus now, specifically the `includes`.\n\n<code-listing heading=\"Includes\">\n  <source-code lang=\"JavaScript\">\n    bundles: {\n      \"dist/app-build\": {\n        includes: [\n          '[*.js]',\n          '*.html!text',\n          '*.css!text'        \n        ],\n  </source-code>\n</code-listing>\n\nPlease pay attention to the pattern `[*.js]`. The bundler supports some glob patterns like `*.js`, `*/**/*.js` etc. `*.js` here means, we are interested in bundling all the `js` assets in the `dist` folder (considering the `path` in `config.js`). So what does `[*.js]` mean here? Well, as we know, the bundler will trace the module dependencies from the import statements. Lot's of our code refers to the modules of `Aurelia` via `import` statements. For example:\n\n<code-listing heading=\"users.js\">\n  <source-code lang=\"JavaScript\">\n    import {inject} from 'aurelia-framework';\n    import {HttpClient} from 'aurelia-fetch-client';\n    import 'fetch';\n\n    @inject(HttpClient)\n    export class Users{\n      heading = 'Github Users';\n      users = [];\n\n      constructor(http){\n        http.configure(config => {\n          config\n            .useStandardConfiguration()\n            .withBaseUrl('https://api.github.com/');\n        });\n\n        this.http = http;\n      }\n\n      activate(){\n        return this.http.fetch('users')\n          .then(response => response.json())\n          .then(users => this.users = users);\n      }\n    }\n  </source-code>\n</code-listing>\n\nWhen the bundler analyzes this file it will find `aurelia-framework` and `aurelia-fetch-client` as it's dependencies and include them in the bundle. But the bundler does not stop there. It will recursively find the dependencies of `aurelia-framework` and `aurelia-fetch-client` and will go on until there is nothing left.\n\n<code-listing heading=\"Includes\">\n  <source-code lang=\"JavaScript\">\n    bundles: {\n      \"dist/app-build\": {\n        includes: [\n          '*.js',\n          '*.html!text',\n          '*.css!text'        \n        ],\n  </source-code>\n</code-listing>\n\nHaving `*.js` in the above config will create a bundle containing lots of `Aurelia` libraries including `aurelia-framework` and `aurelia-fetch-client`. If we consider the second bundle config `dist/vendor-build`, we have 'aurelia-bootstrapper' and 'aurelia-fetch-client'. `aurelia-bootstrapper` will yield `aurelia-framework`. Ultimately, we will end up with duplicate modules in both the bundles.\n\nOur goal is to create a bundle of our application code only. We have to somehow instruct the bundler not to recursively trace the dependencies. Guess what? `[*.js]` is how we do it.   \n\n`[*.js]` will exclude the dependencies of each module that the glob pattern `*.js` yields. In the above case it will exclude `aurelia-framework`, `aurelia-fetch-client` and so on.\n\n## Bundle Configuration\n\nHere is a typical bundle configuration in all its glory:\n\n<code-listing heading=\"Typical Bundle Configuration\">\n  <source-code lang=\"JavaScript\">\n    \"dist/app-build\": {\n      includes: [\n        '[*.js]',\n        '*.html!text',\n        '*.css!text',\n        'bootstrap/css/bootstrap.css!text'\n      ],\n      excludes: [\n        'npm:core-js',\n        'github:jspm/nodelibs-process'\n      ],\n      options: {\n        inject: true,\n        minify: true,\n        rev: true\n      }\n    }\n  </source-code>\n</code-listing>\n\n- **dist/app-build** : This is the name of the bundle and also where the bundle file will be placed. The name of the bundle file will be `app-build.js`. As the `baseURL` for `skeleton-navigation` pointed to `dist` folder, we named it `dist/app-build`.\n- **includes** : We will specify all the modules/files that we want to include here. Since all our JavaScript is in the `dist` folder and we have the `path` rule configured in `config.js` that points to the `dist` folder. If we simply specify `*` all our `js` modules will be included. We can specify `*/**/*` here if we want to include all the subfolders.\n- **`*.html!text`**: This includes all the templates/views in the bundle. The `!text` tells the Bundler and Loader that these files will be bundled and loaded using the `text` plugin.   \n- **`*.css!text`**: Like html templates, we are including all the css here. If you have previously used `plugin-css`, note that we are not using `!css` here. The Aurelia Loader uses `text` plugin for loading css to analyze and do other interesting things like `scoping` etc.\n- **excludes**: This is where we specify what we want to exclude from the bundle. For example, `*` includes all the JS files in the `dist` folder. For example, if for some reason we want `app.js` to be excluded from the bundle, we would write:\n\n<code-listing heading=\"Excludes\">\n  <source-code lang=\"JavaScript\">\n    excludes : [\n       'app'\n    ]\n  </source-code>\n</code-listing>\n\n> Warning\n> Exclusion of files that are being used in the project but are not part of it (e.g. CDN URLs, URLs relative to the host, etc.) is done automatically. For bundling to work, do not add them to the **excludes** section. It will cause an error.\n\n- **inject**: If set to `true`, this will inject the bundle in `config.js`, so whenever the application needs a file within that bundle, the loader will load the entire bundle the first time. This is how we can achieve lazy bundle loading. For a large app with multiple sub sections, this will help us avoid loading everything upfront.\n- **minify**: As the name suggests, if this is set to `true`, the the source files will be minified as well.\n- **rev**: If this is set to `true`, an unique revision number will be appended to the bundle file name.\n- **force** : If this is set to `true` the task will overwrite any existing file/bundle with the same name. Set it to false if you are not sure about it.\n- **packagePath** : By default it is `'.'`, You can change this if your `package.json` file is somewhere else other than the base of your app. `aurelia-bundler` uses this file to find `config.js`, `baseURL`, the `jspm_packages` folder and other important project configuration.\n\n## Bundling HTML Imports\n\nAt this point, if you are thinking: \"Well, this is all good but we have already developed an application that uses Polymer and  `HTML Imports` extensively. We want to bundle them as well.\" As you may already know, we have created a separate plugin [aurelia-html-import-template-loader](https://github.com/aurelia/html-import-template-loader) exclusively for this use case. We have bundling support for that too. This is how we can do it. It's actually a two part process. First let's install the `aurelia-html-import-template-loader` plugin with the command below:\n\n```Shell\n jspm install aurelia-html-import-template-loader\n```\n\nNow, let's open `src/main.js` and add this line:\n\n```JavaScript\naurelia.use.plugin('aurelia-html-import-template-loader')\n```\n\nAfter the change `main.js` should look like this:\n\n<code-listing heading=\"main.js\">\n  <source-code lang=\"JavaScript\">\n    import 'bootstrap';\n\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      aurelia.use.plugin('aurelia-html-import-template-loader')\n\n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nWith this little change Aurelia Loader will now use `HTML Imports` to load all the views. Now, back in our bundle task, we will add a `config` like this:\n\n<code-listing heading=\"HTML Import Config\">\n  <source-code lang=\"JavaScript\">\n    \"dist/view-bundle\": {\n      htmlimports: true,\n      includes: 'dist/*.html',\n      options: {\n        inject: {\n          indexFile : 'index.html',\n          destFile : 'dest_index.html'\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n\nWe will also change the first bundle a little bit to exclude all the `html` and `css` files. Finally our `bundle.js` file should look like this:\n\n<code-listing heading=\"Full HTML Import Bundle Config\">\n  <source-code lang=\"JavaScript\">\n    var gulp = require('gulp');\n    var bundle = require('aurelia-bundler').bundle;\n\n    var config = {\n      force: true,\n      packagePath: '.',\n      bundles: {\n        \"dist/app-build\": {\n          includes: [\n            '[*.js]'\n          ],\n          options: {\n            inject: true,\n            minify: true\n          }\n        },\n        \"dist/aurelia\": {\n          includes: [\n            'aurelia-bootstrapper',\n            'aurelia-fetch-client',\n            'aurelia-router',\n            'aurelia-animator-css',\n            'github:aurelia/templating-binding',\n            'github:aurelia/templating-resources',\n            'github:aurelia/templating-router',\n            'github:aurelia/loader-default',\n            'github:aurelia/history-browser',\n            'github:aurelia/logging-console'\n          ],\n          options: {\n            inject: true,\n            minify: true\n          }\n        },\n        \"dist/view-bundle\": {\n          htmlimport: true,\n          includes: 'dist/*.html',\n          options: {\n            inject: {\n              indexFile : 'index.html',\n              destFile : 'dest_index.html'\n            }\n          }\n        }\n      }\n    };\n  </source-code>\n</code-listing>\n\nWe have changed the source code (src/main.js), so we need to rebuild our app. The command below should do that:\n\n```Shell\n gulp serve\n```\n\n> Info\n> The `serve` task is already configured in such a way that it runs the `build` task first.\n\nNow, let's run `gulp bundle` from another console/tab. If we now refresh/reload our app from the browser, keeping the developer tools open, we should see the difference.\n\n> Warning\n> The order in which the tasks are run is important. The `build` removes all the files in `dist` folder. As a result, any bundle file in that folder will be deleted too. This is why we always have to run the `gulp bundle` after the `build` task is finished. If you are using `watch` you will have to be extra careful here. Every change you make in the source file will trigger a `build` task that clears the `dist` folder and any bundles as well.\n\nLet's examine the configuration one property at a time:\n\n- **dist/view-bundle** : The name of the bundle file is `view-bundle.html` and will be placed in `dist` folder.\n- **htmlimport** : This is what makes it different from other bundles. If this is set to `true` the bundler will treat it as a html import based bundle and Aurelia loader will give it a different treatment as well.\n- **includes**: This is where we will specify what goes in the bundle. All the glob patterns are supported here including arrays of patterns and `!` based exclusion. For example:\n\n<code-listing heading=\"Glob Patterns\">\n  <source-code lang=\"JavaScript\">\n    includes : ['dist/**/*.html', '!dist/movie/*.html']\n  </source-code>\n</code-listing>\n\nThe above pattern will bundle all the views in `dist` and its child folders except everything in the `dist/movie` folder.\n\n- **options** : if `inject` is set to `true` then a `<link rel=\"import\" href=\"path/of/bundle.html\" >` will be injected in the body of `index.html`. If you would like to keep your `index.html` clean and create a separate index file then you have to set `indexFile` and `destFile`.\n\n<code-listing heading=\"HTML Import Injection Options\">\n  <source-code lang=\"JavaScript\">\n    indexFile: 'index.html',\n    destFile : 'dest_index.html'\n  </source-code>\n</code-listing>\n\n## Conclusion\n\nIn this article, you've learned both the why and how of bundling. We've covered the `bundler` library, how to configure it for use with Gulp and demonstrated several different scenarios. To bundle your own app, we recommend that you begin with one of the configurations above and customize it. You may have a small app that makes sense as a single bundle or a larger one that can be broken down into features. Each application is different, but the bundler will help you to create the optimal deployment for your unique scenarios.\n"}