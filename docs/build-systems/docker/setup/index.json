{"name":"Setup Docker","description":"If you're interested in getting started with Docker to build projects, this article will take you through setting up both your machine and a production quality starter project.","author":{"name":"Saeed Ganji","url":"http://shahabganji.me"},"featured":false,"links":{"static":"docs/build-systems/docker/setup","html":"docs/build-systems/docker/setup/index.html","fragment":"docs/build-systems/docker/setup/index-fragment.html","self":"docs/build-systems/docker/setup/index.json"},"content":"\n## Introduction\n\nThe emergence of containers has been changing the software culture; developers and companies are embracing DevOps and CI/CD to automate build, test, and deployment of their products. If you're interested in how you can containerize your Aurelia application, you are in the right place.\n\nThe tendency towards [microservices](https://martinfowler.com/articles/microservices.html) and the culture of [DevOps](https://martinfowler.com/bliki/DevOpsCulture.html) brings collaboration to development and operational teams, breaking down a huge system into lightweight, independently-deployable parts. Besides, it helps us to run our applications on the production, stage, and test machines the same way we run them on our very own laptop or computer. Moreover, it would be desirable to be able to deliver releases of our services, back or front-end, with ease and confidence by taking advantage of `CI/CD` pipelines.\n\nLet's deep dive into Aurelia and containerization.\n\n## Configuring Your Environment\n\nThus far you may have learned how to build your application using Webpack and the CLI-Bundler. To build an Aurelia application inside a Docker container, you first need to have Docker installed on your machine. Please [see the Docker docs](https://docs.docker.com/v18.03/install/) to get Docker installed on your machine before proceeding to the next section.\n\n## Basic Sample\n\nTo start let's create an Aurelia application. Then inside the root folder create a Dockerfile with the name `Dockerfile` like the following:\n\n```Dockerfile\n# use latest version of nodejs\nFROM node:lts-alpine\n\n# install aurelia-cli to build the app & http-server to serve static contents\nRUN npm i -g http-server\nRUN npm i -g aurelia-cli\n\n# set working directory to app\n# henceforth all commands will run inside this folder\nWORKDIR /app\n\n# copy package.json related files first and install all required dependencies\nCOPY package*.json ./\nRUN npm install\n\n# copy the rest of the files and folders & install dependencies\nCOPY . ./\nRUN npm run build\n\n# by default http-server will serve contents on port 8080\n# so we expose this port to host machine\nEXPOSE 8080\n\nCMD [ \"http-server\" , \"dist\" ]\n```\n\nIf you are new to Docker, hopefully the comments above each step help explain what is happening. However, you might have a question regarding why we have separated the `copy` steps into two separate steps. That's due mainly to the cache mechanism of the docker engine. Read [this](https://blog.docker.com/2019/07/intro-guide-to-dockerfile-best-practices/) article and [the documentation](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) for a better understanding.\n\nWell, it's time to build our first Aurelia application image by running a `docker` command:\n\n```Shell\ndocker build -t aurelia-basic-docker-app:1 .\n```\n\nAfter the image is built successfully, it's time to run our application inside a container:\n\n```Shell\ndocker run -it --rm -p 8080:8080 aurelia-basic-docker-app:1\n```\n\nOpen a browser and navigate to [http://localhost:8080](http://localhost:8080). Awesome! You now have a running app.\n\n## A More Real World Scenario\n\nThere are some flaws with the previous approach. It is too simple for production; no one uses `http-server` for their production environment, hopefully. Also, it is recommended that you separate the build stage and the publish stage in order to reduce both the dependency count and the final image size. If you are interested in Multi-staged builds with docker, checkout the documentation [here](https://docs.docker.com/develop/develop-images/multistage-build/).\n\nLet's change our `Dockerfile` a bit. Ready?\n\n```Dockerfile\n# use latest version of nodejs\nFROM node:lts-alpine as build-stage\n\n# install aurelia-cli to build the app & http-server to serve static contents\nRUN npm i -g http-server\nRUN npm i -g aurelia-cli\n\n# set working directory to app\n# henceforth all commands will run inside this folder\nWORKDIR /app\n\n# copy package.json related files first and install all required dependencies\nCOPY package*.json ./\nRUN npm install\n\n# copy the rest of files and folders & install dependencies\nCOPY . ./\nRUN npm run build\n\n# use nginx as the http server to serve contents\nFROM nginx:alpine as production-stage\nWORKDIR /usr/share/nginx/html\n# copy files from previous container/stage into the new one\n# from /app/dist to working directory\nCOPY --from=build-stage /app/dist ./\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\" ]\n```\n\nYou already know how to create your docker image. As a reminder, it's this command:\n\n```Shell\ndocker build -t aurelia-prod-docker-app:1 .\n```\n\nAfter the image is built successfully, it's time to run our application inside a container:\n\n```Shell\ndocker run -it --rm -p 8080:80 aurelia-prod-docker-app:1\n```\n\nUsing separation of concerns, we give each stage/step its own responsibility: the first stage will build our application and has its own dependencies and the second one uses the output provided by the previous one to serve the requests coming to the http server, in this case nginx. In your browser, navigate to [http://localhost:8080](http://localhost:8080) to see the result.\n\n> Info\n> Don't forget to read the official documentation of docker for [multi-staged builds](https://docs.docker.com/develop/develop-images/multistage-build/) and the [docker file best practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/). You'll find a wealth of fruitful articles around the subject matter.\n\nThe most intriguing thing to know is that the `aurelia-cli` will generate a `Dockerfile` based on your chosen configuration, if you go through the `Custom App` installation. If you do so, there is a simple command to build an image:\n\n```Shell\nnpm run docker:build\n```\n\nThat will build a production-ready docker image for you and you can bring up a container on your local machine by simply running:\n\n```Shell\nnpm run docker:start\n```\n\nHere's the command to stop the container:\n\n```bash\nnpm run docker:stop\n```\n\nNow, your front-end Aurelia applications, not only can be deployed to production easier and with more confidence, but at a rapid pace and frequency."}