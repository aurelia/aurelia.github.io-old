{"name":"I18N","description":"Getting Started with I18N in your Aurelia App.","author":{"name":"Vildan Softic","url":"http://pragmatic-coder.net"},"featured":false,"links":{"static":"docs/plugins/i18n","html":"docs/plugins/i18n/index.html","fragment":"docs/plugins/i18n/index-fragment.html","self":"docs/plugins/i18n/index.json"},"content":"\n\n## Introduction\n\nThis documentation explains how to get up and running with Aurelia-I18N\nin order to provide localization and internationalization features with your app.\n\nUnder the hood it uses [i18next](http://i18next.com/), which is a generalized\nopen source library with an extensive set of features. By building on top of it\nnot only can you reuse your work across various other platforms and frameworks\nbut you are able to use an extensive eco-system full of various packages.\n\n## Installing the Plugin\n\nThere are various ways to setup your Aurelia app. It not only boils down\nto the question whether you use JavaScript or TypeScript but also which module loader\nand bundler is in use.\n\nAurelia-I18N is tested and optimized to support both JS and TS, as well as the following loader/bundler scenarios:\n\n* Aurelia CLI\n* JSPM\n* Webpack\n\nPlease continue with the section which suites your setup. In addition to this, you must\npick your own backend service. For this guide we're going to leverage the [XHR backend plugin](https://github.com/i18next/i18next-xhr-backend),\nor a variation of this plugin — `aurelia-i18n-loader` — that uses the aurelia loader, which is bundled with the aurelia-i18n plugin.\nWe'll discuss TypeScript specifics in a later section.\n\n### Aurelia CLI\n\nIn order to install the Plugin with a CLI Project, first install the plugin via npm, from within the root folder of your project:\n\n```Shell\nnpm install aurelia-i18n --save\n```\n\nSince Aurelia-I18N is backed by i18next, you should install it and a backend plugin of your choice. You can use the built-in backend that uses aurelia's loader or any of your choice.\nAs an example we're going to leverage the i18next-xhr-backend:\n\n```Shell\nnpm install i18next i18next-xhr-backend --save\n```\n\n### JSPM\n\nIn your project install the plugin via `jspm` using the following command:\n\n```Shell\njspm install aurelia-i18n\n```\n\nAnd optionally install the backend service using:\n\n```Shell\njspm install npm:i18next-xhr-backend\n```\n\n> Info\n> You can skip this part if you're planning to use the built-in aurelia-i18n-loader\n\n### Webpack\n\nInstall the `aurelia-i18n` plugin in your project using `npm` and the following command:\n\n```Shell\nnpm install aurelia-i18n --save\n```\n\nor if you prefer yarn\n\n```Shell\nyarn add aurelia-i18n\n```\n\nAlso optionally install the `i18next-xhr-backend` plugin:\n\n```Shell\nnpm install i18next-xhr-backend --save\n```\n\nor using yarn\n\n```Shell\nyarn add i18next-xhr-backend\n```\n\n> Info\n> You can skip this part if you're planning to use the built-in aurelia-i18n-loader\n\nOptionally, but recommended, add `aurelia-i18n` to your project's `Aurelia` bundles list in the `webpack.config.babel.js` (assuming you used the `skeleton-navigation` webpack build as your base). This will put the plugin in the `Aurelia` chunk, not the `App` chunk.\n\nAn example based directly on `skeleton-navigation`:\n\n```JavaScript\nconst coreBundles = {\n  bootstrap: [/* snip (to keep example short) */],\n  aurelia: [\n    /* snip (to keep example short) */\n    'aurelia-i18n' // add aurelia-i18n to the array\n  ]\n}\n```\n\n## Setting up the Plugin\n\nNow that you have installed and configured your loader, these are the steps to get started with the plugin.\n\nFirst, use Manual Boostrapping. Open your `index.html` and locate the element with the attribute aurelia-app. Change it to look like this:\n\n```HTML Setting up Aurelia Bootstrapping\n<body aurelia-app=\"main\">\n  ...\n</body>\n```\n\n> Info\n> If you're using one of the [Aurelia Skeletons](https://github.com/aurelia/skeleton-navigation) as your base this is already done and you can safely skip this step. [See here to learn more about manual bootstrapping.](http://aurelia.io/hub.html#/doc/article/aurelia/framework/latest/cheat-sheet/1).\n\nSecond, create a folder named `locales` in your project's src folder.\n\nThird, for each locale, create a new folder with it's name (e.g. `en`, `de`, ...).\n\nFourth, in those subfolders create a file named `translation.json` which contains your language specific translations. Below you can find a sample `en-EN` translation file. The full potential of i18next is achieved through a specific translation-file schema. Consult the [i18next docs](http://i18next.com/docs/) to find out more about it.\n\n```JSON\n{\n  \"score\": \"Score: {{score}}\",\n  \"lives\": \"{{count}} life remaining\",\n  \"lives_plural\": \"{{count}} lives remaining\",\n  \"friend\": \"A friend\",\n  \"friend_male\": \"A boyfriend\",\n  \"friend_female\": \"A girlfriend\"\n}\n```\n\nFifth, create (if you haven't already) a file `main.js` in your `src` folder to configure the plugin. Depending on which backend you've chosen there might\nbe slight differences. The following listings show the configuration for first the built-in aurelia loader, the second using i18next-xhr-backend.\n\n> Info\n> Notice that Aurelia I18N makes use of a non-standard attributes option, which is used to define custom aliases besides the default ones, being `t` and `i18n`. Calling `TCustomAttribute.configureAliases` is currently necessary in order make sure that the aliases are defined before view templates are fully processed.\n\n```JavaScript Registering the Plugin - using the built-in aurelia loader backed\nimport {I18N, Backend, TCustomAttribute} from 'aurelia-i18n';\n\nexport function configure(aurelia) {\n  aurelia.use\n    .standardConfiguration()\n    .developmentLogging()\n    .plugin('aurelia-i18n', (instance) => {\n      let aliases = ['t', 'i18n'];\n      // add aliases for 't' attribute\n      TCustomAttribute.configureAliases(aliases);\n\n      // register backend plugin\n      instance.i18next.use(Backend.with(aurelia.loader));\n\n      // adapt options to your needs (see http://i18next.com/docs/options/)\n      // make sure to return the promise of the setup method, in order to guarantee proper loading\n      return instance.setup({\n        backend: {                                  // <-- configure backend settings\n          loadPath: './locales/{{lng}}/{{ns}}.json', // <-- XHR settings for where to get the files from\n        },\n        attributes: aliases,\n        lng : 'de',\n        fallbackLng : 'en',\n        debug : false\n      });\n    });\n\n  aurelia.start().then(a => a.setRoot());\n}\n```\n\n```JavaScript Registering the Plugin - using the i18next-xhr-backend\nimport {I18N, TCustomAttribute} from 'aurelia-i18n';\nimport Backend from 'i18next-xhr-backend'; // <-- your previously installed backend plugin\n\n// if you use TypeScript and target ES5 you might need to import it like this instead\n// import * as Backend from 'i18next-xhr-backend';\n// otherwise add \"allowSyntheticDefaultImports\": true, to your tsconfig\n\nexport function configure(aurelia) {\n  aurelia.use\n    .standardConfiguration()\n    .developmentLogging()\n    .plugin('aurelia-i18n', (instance) => {\n      let aliases = ['t', 'i18n'];\n      // add aliases for 't' attribute\n      TCustomAttribute.configureAliases(aliases);\n\n      // register backend plugin\n      instance.i18next.use(Backend);\n\n      // adapt options to your needs (see http://i18next.com/docs/options/)\n      // make sure to return the promise of the setup method, in order to guarantee proper loading\n      return instance.setup({\n        backend: {                                  // <-- configure backend settings\n          loadPath: './locales/{{lng}}/{{ns}}.json', // <-- XHR settings for where to get the files from\n        },\n        attributes: aliases,\n        lng : 'de',\n        fallbackLng : 'en',\n        debug : false\n      });\n    });\n\n  aurelia.start().then(a => a.setRoot());\n}\n```\n\nTo have `webpack` serving your translation files for `i18next-xhr-backend`, they need to be copied into the virtual (development) or actual (production) output directory. To copy them from `src/locales/` to `$outputDir$/locales/`, add the following entry under the plugins section of your `webpack.config.js`.\n\n```JavaScript Copy translation files for webpack and i18next-xhr-backend\nplugins: [\n  // ...\n  new CopyWebpackPlugin([\n    { from: 'src/locales/', to: 'locales/' }\n  ]),\n  // ...\n]\n```\n\nYou may also group your translations by namespaces, spread across multiple files. Say you have the standard translation.json and an additional `nav.json` for the navigation items, you can configure aurelia-i18n by passing the `ns` setting in the config object containing the different namespaces as well as the default namespace.\nWhen using namespaces, you will need to prepend string references with `ns:` for those strings that are not in the\ndefaultNS. For example `t='nav:profile'` would access the `profile` string in `nav.json`.\n\n```JavaScript Setting up Multiple Namespaces\ninstance.setup({\n  ...\n  ns: ['translation','nav'],\n  defaultNS: 'translation'\n});\n```\n\n### Reflect-Metadata Compatibility\n\nIf you are using [`reflect-metadata`](https://www.npmjs.com/package/reflect-metadata), there is an outstanding [compatibility issue](https://github.com/aurelia/i18n/issues/209) which is resolved by ensuring `reflect-metadata` is loaded before Aurelia is initialized. If you are using SystemJS, this can be achieved in your `index.html` as follows:\n\n```HTML Ensuring reflect-metadata is loaded first\n<script>\n  System.import('reflect-metadata').then( () => {\n    System.import('aurelia-bootstrapper');\n  });\n</script>\n```\n\n## TypeScript Support\n\nIn order to get proper support for autocompletion and typesafety you should install\nthe necessary type definitions (d.ts) for the plugins dependencies.\nHere we show how you can do that for i18next and the i18next-xhr-backend, but this\nshould be applicable to every other backend choice.\n\nThe way to get hold of those is using using npm or perhaps Yarn as with other packages.\nIn this case the typings are at [@types/i18next](https://www.npmjs.com/package/@types/i18next),\nalong with the instructions. The command is\n\n```Shell\nnpm install --save-dev @types/i18next\n```\n\nor if you are using Yarn\n\n```Shell\nyarn add --dev @types/i18next\n```\n\nbut in case of yarn there might be a complication as described at https://github.com/yarnpkg/yarn/issues/4226\nwith a solution proposed to fix complications should they arise.\n\n> Info\n> Alternatively, you can find this file in the plugins repository doc folder: `doc/i18next.d.ts`\n\nAs for the XHR-Backend you'll be using:\n\n```Shell\nnpm install --save-dev @types/i18next-xhr-backend\n```\n\nor for yarn\n\n```Shell\nyarn add --dev @types/i18next-xhr-backend\n```\n\n> Info\n> Alternative, you can find this file in the plugins repository doc folder: `doc/i18next-xhr-backend.d.ts`\n\nNote: if you decide to use the `doc/*.d.ts` files, you should copy them to another folder, e.g. `custom_typings`.\n\nIf you're running a JSPM setup, in order to properly find the `aurelia-i18n.d.ts` file, you can alternatively install it via npm:\n\n```Shell\nnpm install --save-dev github:aurelia/i18n\n```\n\nThe next step is to let the compiler know about your `*.d.ts` files. Add the following section to your `tsconfig.json` file.\n\n```JavaScript Configuring custom typings in tsconfig.json\n... existing configuration code\n\"filesGlob\": [\n    \"./typings/browser.d.ts\",\n    \"./your_custom_typings_folder_path/**/*.d.ts\", // if you use both typings files from this repository (`doc/*.d.ts`)\n  ],\n... other existing configuration code\n```\n\nor if you are using TypeScript 2.0 or later, you can add them to the types section like\n\n```JavaScript Configuring custom typings in tsconfig.json\n... existing configuration code\n\"types\": [ \"i18next\", \"i18next-xhr-backend\" ]\n  ],\n... other existing configuration code\n```\n\n> Warning\n> TypeScript will throw errors like `Module xxx not found` either for aurelia-i18n or one of the backends. This is due to the fact that TypeScript does not see proper ES6 exported defaults. So you can now either switch to alias imports `import * as Backend from 'i18next-xhr-backend'` or update your tsconfig with `\"allowSyntheticDefaultImports\": true` to maintain the same import style.\n\n## Using the Plugin\n\ni18next translations work by setting up an active locale, which you've setup above in the init phase with the property `lng`.\n\n### Setting the active locale\n\nIn order to change the active language you'd have to call the function `setLocale(localeName)` via code.\n\n```JavaScript Setting the active locale with setLocale\nimport {I18N} from 'aurelia-i18n';\n\nexport class MyDemoVM {\n  static inject = [I18N];\n  constructor(i18n) {\n    this.i18n = i18n;\n    this.i18n\n        .setLocale('de-DE')\n        .then( () => {\n      // locale is loaded\n    });\n  }\n  ...\n}\n```\n\n### Getting the active locale\n\nTo get the active locale you'd go with `getLocale()`:\n\n```JavaScript Getting the active locale using getLocale\nimport {I18N} from 'aurelia-i18n';\n\nexport class MyDemoVM {\n  static inject = [I18N];\n  constructor(i18n) {\n    this.i18n = i18n;\n    console.log(this.i18n.getLocale());\n  }\n  ...\n}\n```\n\n### Translating via code\n\nTranslating stuff via code works by using the method `tr`. You pass in the `key` as its first parameter, followed by the optional second parameter `options` to specify in detail how the translations should be performed. Please consult the [i18next docs](http://i18next.com/translate/#overrideoptions) for a detailed list of those:\n\n```JavaScript Translating using the i18n.tr function\nimport {I18N} from 'aurelia-i18n';\n\nexport class MyDemoVM {\n  static inject = [I18N];\n  constructor(i18n) {\n    this.i18n = i18n;\n    console.log(this.i18n.tr('mykey'));\n  }\n  ...\n}\n```\n\n### Translating via html attributes\n\nTranslation in html can be done alternatively using attributes. By default the plugin is configured to use the `t` and `i18n` attributes.\nThis can be configured during the plugin registration using the `TCustomAttribute.configureAliases` function and also the `attributes`\nproperty plugin `instance.setup` function parameter.\n\n```JavaScript Configuring translation attributes\n...\n.plugin(\"aurelia-i18n\", (instance) => {\n  ...\n  let aliases = ['t','i18n'];\n  TCustomAttribute.configureAliases(aliases);\n  ...\n  instance.setup({\n  ...\n    attributes : aliases,\n  ...\n  });\n  ...\n});\n...\n```\n\n> Passing the option `skipTranslationOnMissingKey` during plugin initialization, will keep your original contents in place and instead add a warning in the console\nabout trying to update an element without a matching key.\n\nAny element in your views that has one of those attributes, will be translated when the locale is changed.\n\n```HTML Attribute based translation with the TCustomAttribute\n<span t=\"title\">Title</span>\n```\n\nThe plugin will use the `title` as the key when translating that element.\nOther attributes, specified in the `attributes` option, may be used as well.\n\n```HTML Attribute based translation with optionally registered I18NCustomAttribute\n<span i18n=\"home.title\">Title</span>\n```\n\nNotice in the above example that the key was set to `home.title`. This will make the plugin look for a translation with nested objects in your translation json, ie:\n\n```JavaScript Nested object translation\n{\n  \"home\": {\n    \"title\": \"Title\",\n  }\n}\n```\n\nUse `i18n.updateTranslations()` to update all translations within the children of the element that is passed to it.\n\n#### Specifying attributes\n\nBy default the plugin will set the `textContent` property of an element.\n\n```HTML\n//translation\n{\n  \"title\": \"Title <b>bold</b>\"\n}\n\n//markup\n<span t=\"title\">Title</span>\n```\n\nSo in above example the html tags will be escaped and the output will be `&lt;b&gt;bold&lt;/b&gt;`.\nTo allow html-markup to be used, the `[html]` attribute needs to be added before the translation key.\n\n```HTML\n<span t=\"[html]title\">Title</span>\n```\n\nThis will set the `innerHTML` of the element instead of the `textContent` property, so html-markup won't be escaped.\nThere are 4 special attributes including the shown `[html]`:\n\n* `[text]`:  Sets the `textContent` property (default)\n* `[html]`:  Sets the `innerHTML` property\n* `[append]`:  appends the translation to the current content already present in the element (allows html).\n* `[prepend]`: prepends the translation to the current content already present in the element (allows html).\n\nIf the element is a custom element and the value relates to a bindable property of that, then the properties value itself will\nbe updated.\n\n```HTML\n// Custom Element ViewModel\nexport class Foo {\n  @bindable() mybindable = \"abc\";\n}\n\n// Custom Element View\n<template>\n  <span>${'mybindable'}</span>\n</template>\n\n// Rendering the Custom Element and passing validations to custom bindable properties\n<foo t=\"[mybindable]bar\"></foo>\n\n// Result\n<foo>\n  <span>[TRANSLATED VALUE OF BAR KEY]</span>\n</foo>\n```\n\nAny other values will be used as actual attributes on the element itself.\nThe following example will not change the content of the element, but will set its `alt` attribute to the translated value of `title` when the locale changes.\n\n```HTML\n<span t=\"[alt]title\">Title</span>\n```\n\n> Keep in mind that using the CustomAttribute approach can lead to full re-renders of your DOM, since the whole element is reconstructed in order to avoid side-effects with using multiple attributes - as explained in the next section. This might be especially important in the case of using translations within repeated sections with large amounts of data. In these cases prefer either the TBindingBehavior or TValueConverter, as discussed a bit later.\n\n#### Specifying multiple attributes\n\nMultiple attributes for the same key can be specified by separating them with a comma.\n\n```HTML\n<input t=\"[placeholder,aria-placeholder]placeholder\">\n```\n\nWhen the locale changes it will set the `placeholder` and the `aria-placeholder` of the input element to the translated value of `placeholder`.\n\nMultiple attributes for different keys can be specified by separating them with a semicolon.\n\n```HTML\n<span t=\"[html]title;[class]title-class\">Title</span>\n```\n\nWhen the locale changes it will set the `innerHTML` to the translated value of `title` due to the `[html]` attribute and the `class` property to the translated value of `title-class`.\n\n#### Using nested and combined translations\n\nIn order to combine two or more translations, just include them with the `$t(yourkey)` markup\n\n```HTML\n<span t=\"$t(title) $t(subtitle)\">Title subtitle</span>\n```\n\nNested keys may also be referenced and will be properly translated:\n\n```JavaScript Nested combined translations\n{\n  \"translation\": {\n    \"title\": \"Title\",\n    \"nested_referencing\": 'The $t(title) is the header',\n    ...\n  }\n}\n```\n\n```HTML\n<span t=\"nested_referencing\">Nested text</span>\n```\n\n#### Translating images\n\nImages can be translated as well, for when a different image needs to be displayed in another language.\n\n```HTML\n<img t=\"home.image\">\n```\n\nThe plugin will automatically change the `src` attribute of the image when the locale changes.\n\nYou may specify a default value for images as well. In order to do so just define an attribute called `data-src` with the default value.\n\n```HTML\n<img data-src=\"path/to/image.jpg\" t=\"home.image\">\n```\n\nThis will be picked up by the CLI when translations are extracted from the source files. (see the section on [CLI Integration](#cli-integration))\n\n#### Passing parameters to the attribute\n\nIn order to use parameters for replaceable parts in your translation key, you can provide an additional `t-params` attribute and bind it to the object containing the replacement values.\nAlso note that for whatever attribute you registered, the corresponding \\*-params attribute will get registered as well automatically.\n\n```JavaScript\n// Translation file\n{\n  \"paramstest\": \"Some text with <strong>{{content}}</strong>\"\n}\n```\n\n```HTML View for parameter passing to attributes\n<!-- View -->\n<span t=\"[html]paramstest\" t-params.bind=\"params\"></span>\n```\n\n```JavaScript\n// ViewModel\nclass MyVM {\n  params = { content: 'ABC' }\n\n  [...]\n}\n```\n\n> Info\n> The object passed to `t-params` is a complex object explained [in the next section](/doc/article/aurelia/i18n/latest/i18n-with-aurelia/5). To use it via code, see [Complex objects for variables via code](/doc/article/en-US/i18n-with-aurelia.md#complex-objects-for-variables).\n\n### Translating with the TValueConverter\n\nIn order to do translations in a more declarative way from within your HTML markup you can use a custom ValueConverter named `t`. It takes exactly the same `options` as the code translation method `tr` but of course provides the key automatically. Performance-wise this is the cheapest binding, together with `one-time`, and thus suitable for large amounts of once rendered data.\n\nYou will find below a few examples of the available [i18next features](http://i18next.com/translate/)\n\n```HTML Declarative translation using the TValueConverter\n<template>\n  <section>\n    <div class=\"row\">\n      <div class=\"col-md-3\">\n        <h3>ValueConverter Examples</h3>\n        <ul class=\"list-group\">\n          <li class=\"list-group-item\">\n            Translation with Variables: <br>\n            ${ 'score' | t: {'score': userScore}}\n          </li>\n\n          <li class=\"list-group-item\">\n            Translation singular: <br>\n            ${ 'lives' | t: { 'count': 1 } }\n          </li>\n\n          <li class=\"list-group-item\">\n            Translation plural: <br>\n            ${ 'lives' | t: { 'count': 2 } }\n          </li>\n\n          <li class=\"list-group-item\">\n            Translation without/with context: <br>\n            ${ 'friend' | t } <br>\n            ${ 'friend' | t: { context: 'male' } } <br>\n            ${ 'friend' | t: { context: 'female' } }\n          </li>\n        </ul>\n      </div>\n    </div>\n  </section>\n</template>\n```\n\n### Translating with the TBindingBehavior\n\nThe TValueConverter is pretty useful if you prefer a declarative way to enhance DOM elements with i18n support. But it has a lack when it comes to automatically updating itself when changes happen outside, like locale switches. This is what the TBindingBehavior can do. Essentially you do the same thing like with the TValueConverter but use the `&` sign instead of `|` to indicate usage of the binding behavior.\n\n```HTML TBindingBehavior Example\n<li class=\"list-group-item\">\n  Translation with Variables: <br>\n  ${ 'score' & t: {'score': userScore}}\n</li>\n```\n\nNow aurelia-i18n will automatically emit signals when internal changes happen and you can do so as well by emiting a `aurelia-translation-signal`. The following example depicts how this is done internally when the current locale changes. First you need to get hold of the `BindingSignaler` exported by the `aurelia-templating-resources` module and inject it either in your constructor or via the static `$inject` property. Next when you want to trigger the signal just use the signalers `signal` method and pass it the predefined string.\n\n```JavaScript Signaling a change to the TBindingBehavior\nimport {BindingSignaler} from 'aurelia-templating-resources';\n// inject signaler to constructor ...\n...\n\nsetLocale(locale) {\n  return new Promise( resolve => {\n    let oldLocale = this.getLocale();\n    this.i18next.setLng(locale, tr => {\n      this.ea.publish('i18n:locale:changed', { oldValue: oldLocale, newValue: locale });\n      this.signaler.signal('aurelia-translation-signal');\n      resolve(tr);\n    });\n  });\n}\n```\n\n> Info\n> If you want to only update your relative time binding behaviors, you may use the signal `aurelia-relativetime-signal` which will only trigger those and safe unnecessary update roundtrips\n\n### Complex objects for variables via code\n\nIn some cases it might be useful to define variables via complex objects. Let's take a look at below example. It shows a validation message to hint the user that a given field should be in range of min and max.\nNow we could easily pass min and max as separate variables but on the other hand that involves more work you'd have to do manually if the source is a object.\n\n```JavaScript Complex objects for variables\nvar resources = {\n  en: {\n    translation: {\n      \"complex\": '{{field}} should be between {{threshold.min}} and {{threshold.max}}'\n    }\n  }\n};\n```\n\nSo in order to avoid that you may simply pass in the object as a whole and the library will pickup all the necessary information and create the proper options object.\nYou can also mix and match it with simple variables.\n\n```JavaScript Mixing complex and simple variables\nvar options = {\n  'threshold': {\n    'min': 1,\n    'max': 10\n  },\n  'field': 'Age'\n};\n\ni18n.tr('complex', options);\n// --> Age should be between 1 and 10\n```\n\n### Formatting numbers via code\n\nFor displaying numbers in different formats, this plugin makes use of the [Internationalization API NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat). It leverages the same locales used for the translation methods mentioned in the install process of the plugin.\n\nThe API provides access to the `Intl NumberFormat` with the method `NumberFormat`. This function takes the an options object representing the formatting options as the first and the locale as the second parameter.\n\nBelow is an example how to access the NumberFormat via code:\n\n```JavaScript Number formatting via Code\nimport {I18N} from 'aurelia-i18n';\n\nexport class MyDemoVM {\n  static inject = [I18N];\n  constructor(i18n) {\n    this.i18n = i18n;\n\n    // create a NumberFormat with German locale\n    var nf = this.i18n.nf(undefined, 'de');\n    var result = nf.format(123456.123);\n\n    console.log(result);\n    // output => 123.456,123\n\n\n    // create a NumberFormat with currency options\n    var nf = this.i18n.NumberFormat({ style: 'currency', currency: 'EUR' }, 'de');\n\n    var result = nf.format(123456.123);\n\n    console.log(result);\n    // output => 123.456,123 €\n  }\n  ...\n}\n```\n\n### Formatting numbers with NfValueConverter\n\nA more declarative way is to use the `nf` ValueConverter from within your HTML markup. It essentially works the same way as the code version. Take a look at the following example:\n\n```HTML Declarative formatting of numbers with the NfValueConverter\n<div class=\"col-md-3\">\n  <h3>ValueConverter Number Examples</h3>\n  <ul class=\"list-group\">\n    <li class=\"list-group-item\">\n      Numberformat with default locale/format:\n      ${ 1234567.890 | nf : undefined : selectedLocale}\n    </li>\n    <li class=\"list-group-item\">\n      Numberformat with different locale default format:\n      ${ 1234567.890 | nf : undefined : 'de'}\n    </li>\n    <li class=\"list-group-item\">\n      Numberformat with different locale/format:\n      ${ 1234567.890 | nf : { style: 'currency', currency: 'EUR' } : 'de'}\n    </li>\n  </ul>\n</div>\n```\n\n> Info\n> If you provide the active locale as a bound VM property, the ValueConverter will be re-evaluated as soon as the property value changes, resulting in automatic re-formatting of your number.\n\n\n### Formatting dates via code\n\nThe Intl. API provides means to [format DateTimes](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat) as well. Use the method `df` to access that feature with the same arguments used for NumberFormat\nBelow you'll find an example how to use those via code:\n\n```JavaScript Formatting Dates via Code\nimport {I18N} from 'aurelia-i18n';\n\nexport class MyDemoVM {\n  static inject = [I18N];\n  constructor(i18n) {\n    this.i18n = i18n;\n\n    // create a DateTimeFormat with German locale\n    var df = this.i18n.df(undefined, 'de');\n    var result = df.format(new Date(2000, 0, 1, 0,0,1))\n\n    console.log(result);\n    // output => 1.1.2000\n\n\n    // create a DateTime with time and 2-digit display\n    var options = {\n      year: 'numeric', month: '2-digit', day: '2-digit',\n      hour: '2-digit', minute: '2-digit', second: '2-digit',\n      hour12: false\n    };\n    var df = this.i18n.df(options, 'de');\n\n    var result = df.format(new Date(2000, 0, 1, 0,0,1));\n\n    console.log(result);\n    // output => 01.01.2000 00:00:01\n  }\n  ...\n}\n```\n\n> Info\n> Remember that if you pass in `undefined` for the options parameter you'll get the default formatting options\n\n### Formatting dates with DfValueConverter\n\nA more declarative way is to use the `df` ValueConverter from within your HTML markup. It essentially works the same way as the code version. Take a look at the following example, which defines a VM property myDate:\n\n```HTML Declarative formatting of dates with the DfValueConverter\n<div class=\"col-md-3\">\n  <h3>ValueConverter Date Examples</h3>\n  <ul class=\"list-group\">\n    <li class=\"list-group-item\">\n      DateFormat with default locale/format:\n      ${ myDate | df : undefined : selectedLocale}\n    </li>\n    <li class=\"list-group-item\">\n      DateFormat with different locale default format:\n      ${ myDate | df : undefined : 'de'}\n    </li>\n    <li class=\"list-group-item\">\n      DateFormat with different locale/format:\n      ${ myDate | df : { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' } : 'de'}\n    </li>\n  </ul>\n</div>\n```\n\n### Rendering relative time\n\nIn order to create a representation of relative time like `x days ago` or `in x days` you can leverage the Service relativeTime. This exposes a method `getRelativeTime` which accepts a valid JS date.\nTo use it via code get hold of the service via injection and call the method as needed:\n\n```JavaScript Rendering relative time via Code\nimport {RelativeTime} from 'aurelia-i18n';\n\nexport class MyDemoVM {\n  static inject = [RelativeTime];\n  constructor(relativeTime) {\n    this.rt = relativeTime;\n\n    var myDate = new Date();\n    myDate.setHours(myDate.getHours() - 2);\n\n    var result = relativeTime.getRelativeTime(myDate);\n\n    console.log(result);\n    // output => 2 hours ago\n  }\n  ...\n}\n```\n\nThis is also tied in to the currentLocale of the library so changing that one will also translate relative time messages. Take a look at the file `src/defaultTranslations/relative.time.js` for available\ntranslations. If you're missing yours, I welcome you to provide a PR so everybody can benefit from it.\n\nA more declarative approach is to use the RtValueConverter directly in your HTML markup. It doesn't take any additional parameters, so just drop it in and you're good to go:\n\n```HTML Declarative relative time using the RtValueConverter\n<div class=\"col-md-3\">\n  <h3>ValueConverter Relative Time Examples</h3>\n  <ul class=\"list-group\">\n    <li class=\"list-group-item\">\n      2 hours ago:\n      ${ myDate | rt }\n    </li>\n  </ul>\n</div>\n```\n\n## Bundle Translation Files\n\nWhen bundling is used, the built-in backend will read the translations from the bundle with the aurelia loader. Make sure that the `translation.json` files are packed in the bundle using the text module, by changing the `aurelia.json` and adding `.json` as an extension for the text plugin:\n\n```JSON\n\"loader\": {\n\t\"type\": \"require\",\n\t\"configTarget\": \"vendor-bundle.js\",\n\t\"includeBundleMetadataInConfig\": \"auto\",\n\t\"plugins\": [\n\t\t{\n\t\t\t\"name\": \"text\",\n\t\t\t\"extensions\": [\n\t\t\t\t\".html\",\n\t\t\t\t\".css\",\n\t\t\t\t\".json\"\n\t\t\t],\n\t\t\t\"stub\": true\n\t\t}\n\t]\n},\n```\n\n### Using JSPM\n\nIf you're using JSPM as your module loader, the bundle configuration might look like.\n\n```JSON\n\"bundles\": {\n  \"dist/app-build\": {\n   \"includes\": [\n     \"[*.js]\",\n     \"*.html!text\",\n     \"*.css!text\",\n     \"*.json!text\"\n   ],\n```\n\n### Using Aurelia CLI\n\nLatest aurelia-cli has built-in support of loading locale (json) files. If you use latest aurelia-cli to create your app, there is nothing you need to do.\n\n### Using Webpack\n\nAs an easy starting point for getting aurelia-i18n to work with webpack or if you don't want your translations files split into several chunks, you might refrain from lazy loading them and instead bundle them all with your app.bundle. With all locales included into the app.bundle, it's size and upfront loading time will increase, but for a small amount of translations, that might not be much of an issue. To do this, you can use the [i18next-resource-store-loader](https://github.com/atroo/i18next-resource-store-loader).\n\nFirst install the module from within the root folder of your project:\n\n```Shell\nnpm install i18next-resource-store-loader --save\n```\n\nGiven following file structure:\n\n```\n└── src\n      ├── assets\n      │   └── i18n\n      │       ├── index.js // Add an empty index.js as root pointer here.\n      │       ├── de\n      │       │   └── translation.json\n      │       └── en\n      │           └── translation.json\n      └── main.js/ts\n```\n\nConfigure aurelia-i18n as follows:\n\n```JavaScript Configuring the i18next-resource-store-loader\nimport {PLATFORM} from 'aurelia-pal';\n// Pass the path to the root pointer relative to main to the loader\nimport resBundle from 'i18next-resource-store-loader!./assets/i18n/index.js';\n\nexport function configure(aurelia) {\n  aurelia.use\n    .standardConfiguration()\n    .developmentLogging()\n    .plugin(PLATFORM.moduleName('aurelia-i18n'), instance => {\n      return instance.setup({\n        resources  : resBundle, //<-- configure aurelia-i18n to use your bundled translations\n        lng        : 'de',\n        attributes : ['t'],\n        fallbackLng: 'en',\n        debug      : false,\n      });\n    });\n\n  aurelia.start().then(() => aurelia.setRoot(PLATFORM.moduleName('app')));\n}\n```\n\nFor additional information about the resource store loader please take a look at the [official repos information](https://github.com/atroo/i18next-resource-store-loader).\n\n## Internationalization API Polyfill\n\nThe plugin leverages the JavaScript Internationalization API to perform certain tasks. Since not all browsers do fully support it ([compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Browser_compatibility)) the aurelia-i18n conditionally loads the Polyfill if needed.\n\nIn case of bundling your app you should thus keep in mind that it will not be automatically included into the bundle. That means you have to manually adjust the bundle config to include the polyfill as well, if you intend to have your application run on browsers without full support. [related GitHub issue](https://github.com/aurelia/i18n/issues/61#issuecomment-178801842)\n\n### Bundling the Intl Polyfill with Aurelia CLI\n\nAurelia-I18N uses a polyfill to provide Intl.API support for browsers currently not implementing the feature.\nAmongst those are Safari for Mac and iOS. The Polyfill will be lazy loaded in dev mode as needed but won't be included\nautomatically as part of the bundle. The reason is the decent file size of ~50k in minified mode, as such you as the developer\nhave to opt-in and bundle the Polyfill manually.\n\nTo do so first install the Polyfill as part of your project using npm:\n\n```Shell\nnpm install intl --save\n```\n\nThen loaded it at the beginning of your `main.js` or `main.ts`\n\n```JavaScript\nimport 'intl';\n```\n\n### Use Internationalization API Polyfill with Webpack\n\nIn order to use the Polyfill with Webpack, you will have to adapt your `bootstrap` function.\n\n```JavaScript Using the polyfill with Webpack\nbootstrap(aurelia => {\n  if (!global.Intl) {\n    console.log('Intl not present')\n    require.ensure([\n      'intl',\n      'intl/locale-data/jsonp/en.js'\n    ], function (require) {\n      require('intl');\n      require('intl/locale-data/jsonp/en.js');\n      boot(aurelia);\n    });\n  } else {\n    boot(aurelia);\n  }\n});\n\nfunction boot(aurelia) {\n  aurelia.use\n    .standardConfiguration()\n    .developmentLogging()\n    .plugin('aurelia-i18n', (instance) => {\n        // code to setup aurelia-i18n\n    });\n\n  aurelia.start().then(() => aurelia.setRoot('app', document.body));\n}\n```\n\nWhen using WebPack, one needs to add `PLATFORM.modulename` to enable [aurelia-webpack-plugin](https://www.npmjs.com/package/aurelia-webpack-plugin)\nto properly recognize the plugins. With that change, the example code looks like so:\n\n```JavaScript Using the polyfill with Webpack\nbootstrap(aurelia => {\n  if (!global.Intl) {\n    console.log('Intl not present')\n    require.ensure([\n      'intl',\n      'intl/locale-data/jsonp/en.js'\n    ], function (require) {\n      require('intl');\n      require('intl/locale-data/jsonp/en.js');\n      boot(aurelia);\n    });\n  } else {\n    boot(aurelia);\n  }\n});\n\nfunction boot(aurelia) {\n  aurelia.use\n    .standardConfiguration()\n    .developmentLogging()\n    .plugin(PLATFORM.modulename('aurelia-i18n'), (instance) => {\n        // code to setup aurelia-i18n\n    });\n\n  aurelia.start().then(() => aurelia.setRoot(PLATFORM.modulename('app'), document.body));\n}\n```\n\nOr using TypeScript\n\n```TypeScript Using the polyfill with Webpack\naurelia.use\n  .standardConfiguration()\n  .developmentLogging()\n  .plugin(PLATFORM.moduleName('aurelia-i18n'), (instance: I18N) =>\n      // code to setup aurelia-i18n\n  });\n\nawait aurelia.start();\nawait aurelia.setRoot('app', document.body);\n```\n\nMore information [in the README of the Intl.js polyfill](https://github.com/andyearnshaw/Intl.js/#intljs-and-browserifywebpack).\n\nOn top of that if you need the Intl polyfill included you have to manually require and bundle it. To do so add the following import statement at the begin of your `main.js/ts` file:\n\n```JavaScript Manually requiring the Intl Polyfill\n//main.js\nimport 'intl';\n```\n\nFor additional information about Intl.js and Webpack please take a look at this [official repos information](https://github.com/andyearnshaw/Intl.js#intljs-and-browserifywebpack)\n"}