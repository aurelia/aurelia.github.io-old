{"name":"Animation","description":"The basics of using the animation plugin for Aurelia.","author":{"name":"Avraham Essoudry","url":"https://github.com/avrahamcool"},"featured":false,"links":{"static":"docs/plugins/animation","html":"docs/plugins/animation/index.html","fragment":"docs/plugins/animation/index-fragment.html","self":"docs/plugins/animation/index.json"},"content":"\n\n## Introduction\n\nAnimations are the way we bring our applications to life. An animation lets an element gradually change from one style to another, giving it the ability to smoothly alter its size, color, etc. over time.\n\nA key goal in building animation support for Aurelia was to enable a flexible solution that allows you to choose whatever animation library you like. As a result, you're neither limited to a proprietary API nor to a certain style for how to implement your animations. To enable this flexibility, Aurelia's animation system is built around [a simple animation interface](https://github.com/aurelia/templating/blob/master/src/animator.js), which is part of its templating library.\n\nIn this article we'll cover the official CSS animation plugin for Aurelia, `aurelia-animator-css`. This plugin is one concrete implementation of the interface mentioned above. However, you can also use our official `aurelia-animator-velocity` plugin if you prefer the Velocity library, or you can write your own plugin based on the interface above, for example if you prefer to use something like Greensock.\n\nMany kinds of animation can be applied to your elements, but in this article we'll demonstrate the common cases by using simple CSS animations; mainly, animation when navigating between views with the router, and animating incoming and outgoing elements of a repeater.\n\n## Installing The Plugin\n\nIf you are using the CLI or Webpack, you can install the plugin from NPM:\n\n```Shell\nnpm install aurelia-animator-css --save\n```\n\nor\n\n```Shell\nyarn add aurelia-animator-css\n```\n\nIf you are using JSPM for client dependencies, then you can use this command:\n\n```Shell\njspm install aurelia-animator-css\n```\n\n> Info\n> If you created your app with the **Aurelia CLI**, chances are you already have the plugin installed as a dependency.\n\n> Warning\n> If you are using an older version of **Aurelia CLI**, prior to 1.0, with RequireJS/SystemJS loaders, you should add `aurelia-animator-css` in the dependencies part of the bundle in your `aurelia.json` file.\n\n## Configuring The Plugin\n\nIn your `main.js` within your `src` folder, simply call the plugin API with the animation plugin's name:\n\n```JavaScript main.js\nimport {PLATFORM} from 'aurelia-pal';\n\nexport function configure(aurelia) {\n  aurelia.use\n    .standardConfiguration()\n    .developmentLogging()\n    .plugin(PLATFORM.moduleName(\"aurelia-animator-css\")); //<-- add this\n\n  aurelia.start().then(a => a.setRoot());\n}\n```\n\n> Warning\n> `PLATFORM.moduleName` should *not* be omitted if you are using *Webpack*.\n\n## Demo\n\nBefore we get started setting up the animations themselves, take a look at a demo of what we'll build out.\n\n[Animation Demo](https://codesandbox.io/embed/x93zy0m8mp?autoresize=1&codemirror=1&fontsize=18&hidenavigation=1&module=%2Fsrc%2Fmain.js&view=preview)\n\n## Using The Plugin\n\nFirst we need to declare some `keyframes` animations that we can later hook on our elements.\n\n> Warning\n> Don't forget to add the appropriate vendor prefixes if you target old browsers.\n\n```CSS animations.css\n@keyframes SlideInRight {\n  0% {\n    transform: translateX(100%);\n  }\n\n  100% {\n    transform: translateX(0);\n  }\n}\n\n@keyframes SlideOutRight {\n  0% {\n    transform: translateX(0);\n  }\n\n  100% {\n    transform: translateX(100%);\n  }\n}\n\n@keyframes SlideInLeft {\n  0% {\n    transform: translateX(-100%);\n  }\n\n  100% {\n    transform: translateX(0);\n  }\n}\n\n@keyframes SlideOutLeft {\n  0% {\n    transform: translateX(0);\n  }\n\n  100% {\n    transform: translateX(-100%);\n  }\n}\n\n@keyframes FadeIn {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n\n@keyframes FadeOut {\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n```\n\nThese are pretty typical, standard CSS animations. There's nothing really special to note about them. You may not need them all, or you may add new ones according to your needs, but they should give you a solid start.\n\nNow we also need CSS classes that use those animations, so we can later add those classes on our elements to activate the animations.\n\n```CSS animations.css\n.animate-slide-in-right.au-enter {\n  transform: translateX(100%);\n}\n\n.animate-slide-in-right.au-enter-active {\n  animation: SlideInRight 1s;\n}\n\n.animate-slide-out-right.au-leave-active {\n  animation: SlideOutRight 1s;\n}\n\n.animate-slide-in-left.au-enter {\n  transform: translateX(-100%);\n}\n\n.animate-slide-in-left.au-enter-active {\n  animation: SlideInLeft 1s;\n}\n\n.animate-slide-out-left.au-leave-active {\n  animation: SlideOutLeft 1s;\n}\n\n.animate-fade-in.au-enter {\n  opacity: 0;\n}\n\n.animate-fade-in.au-enter-active {\n  animation: FadeIn 1s;\n}\n\n.animate-fade-out.au-leave-active {\n  animation: FadeOut 1s;\n}\n```\n\nEssentially, all that is needed to make an animation work is to define CSS classes with special predefined suffixes. You get the chance to use preparation classes, added before the actual animation starts, as well as activation classes, used to trigger the actual animation. Take a look at the following table for all available options.\n\n<table>\n  <tr>\n    <th>Method</th>\n    <th>Description</th>\n    <th>Preparation</th>\n    <th>Activation</th>\n  </tr>\n  <tr>\n    <td>Enter</td>\n    <td>Element enters the DOM</td>\n    <td>au-enter</td>\n    <td>au-enter-active</td>\n  </tr>\n  <tr>\n    <td>Leave</td>\n    <td>Element leaves the DOM</td>\n    <td>au-leave</td>\n    <td>au-leave-active</td>\n  </tr>\n  <tr>\n    <td>addClass</td>\n    <td>Adds a CSS class</td>\n    <td>n/a</td>\n    <td>[className]-add</td>\n  </tr>\n  <tr>\n    <td>removeClass</td>\n    <td>Removes a CSS class</td>\n    <td>n/a</td>\n    <td>[className]-remove</td>\n  </tr>\n</table>\n\n## Working with Default Animation Triggers\n\nWe need to give our elements the class `au-animate` to tell Aurelia that those elements can be animated. Additionally, we should apply a specific animation from the ones we have created above (i.e `animate-fade-in`). Once that's done, every time the element enters or leaves the DOM, the animation will kick-in.\n\nAs an example, we may have multiple `li` elements rendering in a repeater and we would like them to animate in and out using the fading effect we declared above. We can declare that like this:\n\n```HTML todos.html\n<ul class=\"au-stagger\">\n  <li\n    repeat.for=\"todo of todos\"\n    class=\"au-animate animate-fade-in animate-fade-out\"\n  >\n    <input type=\"checkbox\" checked.bind=\"todo.done\">\n    <span css=\"text-decoration: ${todo.done ? 'line-through' : 'none'}\">\n      ${todo.description}\n    </span>\n    <button click.trigger=\"removeTodo(todo)\">Remove</button>\n  </li>\n</ul>\n```\n\nNotice the `au-stagger` class on the `ul` container. It is used to delay the animation between each one of the `li`s so they don't animate in simultaneously.\n\n```CSS animations.css\n.au-stagger {\n  animation-delay: 500ms;\n}\n```\n\nIf we would like to animate the views that are rendered in a `router-view`, we can use the same method. We need to add the `au-animate` class on the first child of the view and add the desired entering/exiting animations.\n\n```HTML todos.html\n<template>\n  <div class=\"au-animate animate-slide-in-right animate-slide-out-left\">\n    ...\n  </div>\n</template>\n```\n\nWe'll also want to set the `swap-order` attribute of the `router-view` element. This controls how the animations between the old view and the new view are ordered in time. More information on the available options can be read about [here](docs/routing/configuration#view-swapping-and-animation) and you can play with their effects in the demo above.\n\n## Summary\n\nBy adopting the `aurelia-animator-css` plugin, adding animations to your app is as simple as including a few standard CSS animations and applying a few classes to selected HTML elements. However, this just scratches the surface of animation in Aurelia. If you need more power, you can implement your own animation system by creating a class that implements the standard Aurelia interface and plugging it in, opening up endless possibilities.\n"}