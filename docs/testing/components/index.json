{"name":"Testing Components","description":"An overview of how to unit test Custom Elements and Custom Attributes.","author":{"name":"Martin Gustafsson","url":"http://github.com/martingust"},"keywords":["JavaScript","Unit Testing","Custom Elements","Custom Attributes"],"contributors":[],"translators":[],"links":{"static":"docs/testing/components","html":"docs/testing/components/index.html","fragment":"docs/testing/components/index-fragment.html","self":"docs/testing/components/index.json"},"content":"\n## [Introduction](aurelia-doc://section/1/version/1.0.0)\n\nWith the Component Tester you can easily stage a custom element or custom attribute in isolation inside a mini Aurelia application, assert how it responds to data-binding and assert its behavior throughout the component's lifecycle (bind, attached etc).\n\n## [Getting Started](aurelia-doc://section/2/version/1.0.0)\n\nIf you are using JSPM:\n\n```shell\njspm install aurelia-testing\n```\n\nIf you are using NPM:\n\n```shell\nnpm install aurelia-testing\n```\n\nOnce you've got the library installed, you can use it in a unit test. In the following examples we will be using Jasmine, but any testing framework would work.\n\n## [Testing a Custom Element](aurelia-doc://section/3/version/1.0.0)\n\nLet's start with a simple custom element that we want to test:\n\n<code-listing heading=\"A Custom Element's View\">\n  <source-code lang=\"HTML\">\n    <template>\n      <div class=\"firstName\">${firstName}</div>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"A Custom Element's View-Model\">\n  <source-code lang=\"JavaScript\">\n    import {bindable} from 'aurelia-framework';\n\n    export class MyComponent {\n      @bindable firstName;\n    }\n  </source-code>\n</code-listing>\n\nIn order to test that the component renders expected HTML, based on what the view is bound to, we can write following test:\n\n<code-listing heading=\"A Custom Element Test\">\n  <source-code lang=\"JavaScript\">\n    import {StageComponent} from 'aurelia-testing';\n    import {bootstrap} from 'aurelia-bootstrapper';\n\n    describe('MyComponent', () => {\n      let component;\n\n      beforeEach(() => {\n        component = StageComponent\n          .withResources('my-component')\n          .inView('<my-component first-name.bind=\"firstName\"></my-component>')\n          .boundTo({ firstName: 'Bob' });\n      });\n\n      it('should render first name', done => {\n        component.create(bootstrap).then(() => {\n          const nameElement = document.querySelector('.firstName');\n          expect(nameElement.innerHTML).toBe('Bob');\n          done();\n        }).catch(e => { console.log(e.toString()) });\n      });\n\n      afterEach(() => {\n        component.dispose();\n      });\n    });\n  </source-code>\n</code-listing>\n\nRunning the test should result in the following html should be rendered `<div class=\"firstName\">Bob</div>` and the test should pass. But let's take a step back and see what is going on here. First, we import `StageComponent` from `aurelia-testing`:\n\n<code-listing heading=\"Importing StageComponent\">\n  <source-code lang=\"JavaScript\">\n    import {StageComponent} from 'aurelia-testing';\n  </source-code>\n</code-listing>\n\n`StageComponent` is just a convenience factory that creates a new instance of the `ComponentTester` class. `ComponentTester` is the actual class doing all the work. Next we use the `StageComponent` factory to stage our component:\n\n<code-listing heading=\"Staging The Element\">\n  <source-code lang=\"JavaScript\">\n    component = StageComponent\n      .withResources('src/my-component')\n      .inView('<my-component first-name.bind=\"firstName\"></my-component>')\n      .boundTo({ firstName: 'Bob' });\n  </source-code>\n</code-listing>\n\n`StageComponent` comes with one property, `withResources`, that lets you start off the staging with a fluent API. `withResources` lets you specify which resource or resources for Aurelia to register.  It takes either a string for registering one single resource or an Array of strings for registering multiple resources. `inView` lets you provide the html markup to be run. This is just a standard Aurelia view where you can do all the data binding you are used to in a full-blown Aurelia application. `boundTo` lets you provide a test `viewModel` with the data that the view will get bound to. In this example, the staging of the component is done in Jasmine's `beforeEach` method in order to reuse the same setup for multiple tests.\n\n> Info\n> If you are using `karma` and your configuration already has a path for `'*': 'src/*'` set you may not need to use `src/`, and just `my-component`.\n\nNext, we come to the actual test where we call `create` on the `ComponentTester`. Create will kick everything off and bootstrap the mini Aurelia application, configure it with `standardConfiguration` (we will take a look later at how you can run with your own configuration), register provided resources as global resources, start the application and finally render your component so you can assert the expected behavior. In this case, we want to make sure our `firstName` property gets rendered correctly in the HTML by selecting the `div` tag via it's class name. We use `document.querySelector('.firstName');` to grab that and then check that its innerHTML is `Bob`. Next we call Jasmine's `done` function to tell Jasmine that the test is complete. Calling `done` is needed since the `create` method is asynchronous and returns a Promise.\n\nFinally, we call `dispose` on our `ComponentTester` instance. This will clean up the DOM so our next test will start out with a clean document. That's pretty much all there is to it. Easy right? Imagine doing the same assert with stand alone unit tests that run outside of Aurelia. It would be pretty difficult, especially for a more complex component.\n\n\n## [Manually handling lifecycle](aurelia-doc://section/4/version/1.0.0)\n\nWhen testing a component sometimes you want to have tests run at certain points of the lifecycle.  To do this we can tell the component we created that we will manually handle the lifecycle methods -\n\n<code-listing heading=\"Manually handling lifecycle\">\n  <source-code lang=\"JavaScript\">\n    import {StageComponent} from 'aurelia-testing';\n    import {bootstrap} from 'aurelia-bootstrapper';\n\n    describe('MyComponent', () => {\n      let component;\n\n      beforeEach(() => {\n        component = StageComponent\n          .withResources('src/my-component')\n          .inView('<my-component first-name.bind=\"firstName\"></my-component>')\n          .boundTo({ firstName: 'Bob' });\n      });\n\n      it('can manually handle lifecycle', done => {\n        let nameElement;\n\n        component.manuallyHandleLifecycle().create()\n          .then(() => {\n            nameElement = document.querySelector('.name');\n            expect(nameElement.innerHTML).toBe(' ');\n          })\n          .then(() => component.bind())\n          .then(() => {\n            expect(nameElement.innerHTML).toBe('Foo bind');\n          })\n          .then(() => component.attached())\n          .then(() => {\n            expect(nameElement.innerHTML).toBe('Foo attached');\n          })\n          .then(() => component.detached())\n          .then(() => component.unbind())\n          .then(() => {\n            expect(component.viewModel.name).toBe(null);\n          })\n          .then(() => component.bind({ name: 'Bar' }))\n          .then(() => {\n            expect(nameElement.innerHTML).toBe('Bar bind');\n          })\n          .then(() => component.attached())\n          .then(() => {\n            expect(nameElement.innerHTML).toBe('Bar attached');\n          })\n          .then(done);\n        });\n\n      afterEach(() => {\n        component.dispose();\n      });\n\n    });\n  </source-code>\n</code-listing>\n\nAs you see, the test helper lets you easily push components through their lifecycle, testing various aspects of it at each point along the way.\n\n## [Testing a Custom Attribute](aurelia-doc://section/5/version/1.0.0)\n\nTesting a Custom Attribute is not much different than testing a Custom Element. Let's look at how it's done by starting with a simple example custom attribute that lets you change the background color of the element it is placed on:\n\n<code-listing heading=\"A Custom Attribute\">\n  <source-code lang=\"JavaScript\">\n    export class MyAttributeCustomAttribute {\n      static inject = [Element];\n      constructor(element) {\n        this.element = element;\n      }\n\n      valueChanged(newValue){\n        this.element.style.backgroundColor = newValue;\n      }\n    }\n  </source-code>\n</code-listing>\n\nNow, let's assert that the element actually gets the background color it is bound to:\n\n<code-listing heading=\"A Custom Attribute Test\">\n  <source-code lang=\"JavaScript\">\n    import {StageComponent} from 'aurelia-testing';\n    import {bootstrap} from 'aurelia-bootstrapper';\n\n    describe('MyAttribute', () => {\n      let component;\n\n      beforeEach(() => {\n        component = StageComponent\n            .withResources('src/my-attribute')\n            .inView('<div my-attribute.bind=\"color\">Bob</div>')\n            .boundTo({ color: 'blue' });\n      });\n\n      it('should set the background color to provided color', done => {\n         component.create(bootstrap).then(() => {\n           expect(component.element.style.backgroundColor).toBe('blue');\n           done();\n         }).catch(e => console.log(e.toString()));\n      });\n\n      afterEach(() => {\n        component.dispose();\n      });\n    });\n  </source-code>\n</code-listing>\n\nAs you can see, everything follows the same pattern we had for our custom element test. One exception is that we take advantage of the `element` property which gets provided by the `ComponentTester` instance. The `element` property is the actual HTML element that gets rendered. This can also be used when testing custom elements.\n\n## [Testing custom component with a real view-model](aurelia-doc://section/6/version/1.0.0)\n\nIf you want to test a custom component with a real view-model, mocking\nout all dependencies, you can do this as well.  A common scenario is\nto test the view/view-model, mocking out service calls to the backend.\n\nIf the view model has a dependency on a class called Service for all backend communication:\n\n<code-listing heading=\"A Custom Component with a Real View-model\">\n  <source-code lang=\"JavaScript\">\n    export class MockService {\n      firstName;\n\n      getFirstName() { return Promise.resolve(this.firstName);\n    }\n\n    describe('MyComponent', () => {\n      let component;\n      let service = new MockService();\n\n      beforeEach(() => {\n        service.firstName = undefined;\n\n        component = StageComponent\n          .withResources('src/component')\n          .inView('<component></component>');\n\n        component.bootstrap(aurelia => {\n          aurelia.use.standardConfiguration();\n\n          aurelia.container.registerInstance(Service, service);\n        });\n      });\n\n      it('should render first name', done => {\n        service.firstName = 'Bob';\n\n        component.create(bootstrap).then(() => {\n          const nameElement = document.querySelector('.first-name');\n          expect(nameElement.innerHTML).toBe('Bob');\n\n          done();\n        });\n      });\n\n      afterEach(() => {\n        component.dispose();\n      });\n    });\n  </source-code>\n</code-listing>\n\n## [Using a Real Parent View-model](aurelia-doc://section/7/version/1.0.0)\n\nIf you want to test using a custom element inside of a real parent view-model this can be done just as easily.  This can be really helpful when needing to test the state of a parent that is affected by the child custom element or attribute -\n\n<code-listing heading=\"A Custom Attribute Test with Real Parent View-model\">\n  <source-code lang=\"JavaScript\">\n    import {StageComponent} from 'aurelia-testing';\n    import {bootstrap} from 'aurelia-bootstrapper';\n    import {MyComponent} from 'src/my-component';\n\n    describe('MyAttribute', () => {\n      let component;\n      let viewModel;\n\n      beforeEach(() => {\n        viewModel = new MyComponent();\n        component = StageComponent\n            .withResources('src/my-attribute')\n            .inView('<div my-attribute.bind=\"color\">Bob</div>')\n            .boundTo(viewModel);\n      });\n      //...\n    });\n  </source-code>\n</code-listing>\n\nUsing this you can also use the `ref` custom attribute to get access to things and check their state in the view-model.\n\nOr if your view-model has dependencies to load through DI -\n\n<code-listing heading=\"A Custom Attribute Test with Real Parent View-model with DI dependencies\">\n  <source-code lang=\"JavaScript\">\n    import {StageComponent} from 'aurelia-testing';\n    import {bootstrap} from 'aurelia-bootstrapper';\n    import {MyComponent} from 'src/my-component';\n    import {Container} from 'aurelia-dependency-injection';\n    import {MyService} from 'src/my-service';\n\n    describe('MyAttribute', () => {\n      let component;\n      let container;\n      let viewModel;\n      let myService;\n\n      beforeEach(() => {\n        container = new Container();\n        myService = container.get(MyService);\n        viewModel = container.get(MyComponent);\n        component = StageComponent\n            .withResources('src/my-attribute')\n            .inView('<div my-attribute.bind=\"color\">Bob</div>')\n            .boundTo(viewModel);\n      });\n      //...\n    });\n  </source-code>\n</code-listing>\n\nNow the service dependency for `MyComponent` will be resolved through DI automatically.\n\n## [Improving Readability with Multi-line Strings](aurelia-doc://section/8/version/1.0.0)\n\nYou can improve the readability of your complex views by using template literals in your tests -\n\n<code-listing heading=\"Multi-line Strings for Views\">\n  <source-code lang=\"JavaScript\">\n    import {StageComponent} from 'aurelia-testing';\n    import {bootstrap} from 'aurelia-bootstrapper';\n\n    describe('MyAttribute', () => {\n      let component;\n\n      beforeEach(() => {\n        let view = `\n          <div class=\"row\">\n            <div class=\"col-xs-12\">\n              <div my-attribute.bind=\"color\">Bob</div>\n            </div>\n          </div>\n        `;\n        component = StageComponent\n            .withResources('src/my-attribute')\n            .inView(view)\n            .boundTo(viewModel);\n      });\n      //...\n    });\n  </source-code>\n</code-listing>\n\n## [Helpful Properties and Functions](aurelia-doc://section/9/version/1.0.0)\n\nThe `ComponentTester` exposes a set of properties that can be handy when doing asserts or to stage a component in a specific way. Here's a list of what is available:\n\n* `element` - The HTML element that gets rendered.\n* `viewModel` - The view-model for the component.\n* `configure` - The `ComponentTester`'s configure method can be overwritten in order to set it up with custom configuration or get a reference to the `container` instance.\n* `dispose` - Cleans up the DOM after a test has run.\n* `bind` - Manually handles `bind`.\n* `unbind` - Manually handles `unbind`.\n* `attached` - Manually handles `attached`.\n* `detached` - Manually handles `detached`.\n* `waitForElement` and `waitForElements` - Waits until one or several elements are present / absent. See below.\n\n## [Testing complex components](aurelia-doc://section/10/version/1.0.0)\n\nIn some cases, the tested element is not rendered yet when the `component.create()` promise is resolved, and therefore when the actual test starts. For these situations, `aurelia-testing` and `ComponentTester` expose helper methods and functions to wait for tested elements to be present in the page.\n\n### Waiting for element(s)\n\nIf you want to wait for elements that can be looked up in the DOM using a query passed to `querySelector` or `querySelectorAll`, you can use one of the following:\n\n* `ComponentTester.waitForElement` or `ComponentTester.waitForElements`: to wait for one or several HTML element(s) within the tested component. The query is carried out using `querySelector` and `querySelectorAll`, respectively.\n* `waitForDocumentElement` or `waitForDocumentElements` (imported from `aurelia-testing`): to wait for one or several HTML element(s) within the document, not restricted to the descendants of the tested component. This is especially useful if you want to wait for elements created by third-party libraries such as context menus, date pickers, etc.\n\nAll these methods and functions take 2 arguments:\n\n* `selector` (mandatory): is a selector string to look up the wanted element(s). It must be compatible with `querySelector` and `querySelectorAll`\n* `options` is an object that can have the following properties:\n  - `present`: `true` to test for presence, `false` for absence (defaults to `true`)\n  - `interval`: the polling interval (defaults to 50ms)\n  - `timeout`: the timeout (defaults to 5s)\n\nThey all return a `Promise` that resolves to an `Element` (`waitForElement`) or a `NodeList` (`waitForElements`). The `Promise` is rejected in the event of a timeout. The returned `Promise` can be used to execute some testing code only once a given element has been detected to be present or absent, either because the component was slow to be fully rendered or because the test relies on asynchronous actions such as events or animations.\n\n### Waiting for matches to complex queries ... or anything else\n\nIf your query is complex (with non-trivial jQuery lookups for example), or you want to wait for the result of a callback to be something else than `null`, you can use the higher-level `waitFor` function imported from `aurelia-testing`.\n\n`waitFor(getter, options)` works exactly the same way as the previously described methods and functions, but takes a callback (`getter`) as the first argument instead of a selector string. `waitFor` internally calls `getter` with no arguments at regular intervals times until the returned value is anything else than `null`, an empty `NodeList` or jQuery set. The returned `Promise` will resolve to the result of `getter()`.\n\n### Examples\n\n<code-listing heading=\"Here is how to wait for the `firstName` input control from the example above:\">\n  <source-code lang=\"JavaScript\">\n    component.waitForElement('.firstName').then((nameElement) => {\n      expect(nameElement.innerHTML).toBe('Bob');\n      done();\n    });\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"... and here is the same using jQuery:\">\n  <source-code lang=\"JavaScript\">\n    import {waitFor} from 'aurelia-testing';\n\n    waitFor(() => $('.firstName')).then((nameElement) => {\n      expect(nameElement.html()).toBe('Bob');\n      done();\n    });\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Waiting for the same element to be absent but timeout after 2s is as easy as:\">\n  <source-code lang=\"JavaScript\">\n    component.waitForElement('.firstName', {present: false, timeout: 2000}).then(done);\n  </source-code>\n</code-listing>\n"}