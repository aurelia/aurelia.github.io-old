{"name":"Binding: Binding Behaviors","description":"An overview of the Aurelia binding engine's binding behavior functionality. Binding Behaviors are used to plug into a binding instance's lifecycle and change the way it operates.","author":{"name":"Jeremy Danyow","url":"http://danyow.net"},"featured":false,"links":{"static":"docs/binding/binding-behaviors","html":"docs/binding/binding-behaviors/index.html","fragment":"docs/binding/binding-behaviors/index-fragment.html","self":"docs/binding/binding-behaviors/index.json"},"content":"\n## Introduction\n\nBinding behaviors are a category of view resource, just like value converters, custom attributes and custom elements.  Binding behaviors are most like [value converters](http://www.danyow.net/aurelia-value-converters/) in that you use them declaratively in binding expressions to affect the binding.\n\nThe primary difference between a binding behavior and a value converter is *binding behaviors have full access to the binding instance, throughout it's lifecycle*. Contrast this with a value converter which only has the ability to intercept values passing from the model to the view and visa versa.\n\nThe additional \"access\" afforded to binding behaviors gives them the ability to change the behavior of the binding, enabling a lot of interesting scenarios which you'll see below.\n\n## throttle\n\nAurelia ships with a handful of behaviors out of the box to enable common scenarios.  The first is the throttle binding behavior which limits the rate at which the view-model is updated in two-way bindings or the rate at which the view is updated in to-view binding scenarios.\n\nBy default `throttle` will only allow updates every 200ms. You can customize the rate of course.  Here are a few examples.\n\n```HTML Updating a property, at most, every 200ms\n<input type=\"text\" value.bind=\"query & throttle\">\n```\n\nThe first thing you probably noticed in the example above is the `&` symbol, which is used to declare binding behavior expressions. Binding behavior expressions use the same syntax pattern as value converter expressions:\n\n* Binding behaviors can accept arguments: `firstName & myBehavior:arg1:arg2:arg3`\n* A binding expression can contain multiple binding behaviors: `firstName & behavior1 & behavior2:arg1`.\n* Binding expressions can also include a combination of value converters and binding behaviors: `\\${foo | upperCase | truncate:3 & throttle & anotherBehavior:arg1:arg2}`.\n\nHere's another example using `throttle`, demonstrating the ability to pass arguments to the binding behavior:\n\n```HTML Updating a property, at most, every 850ms\n<input type=\"text\" value.bind=\"query & throttle:850\">\n```\n\nThe throttle behavior is particularly useful when binding events to methods on your view-model.  Here's an example with the `mousemove` event:\n\n```HTML Handling an event, at most, every 200ms\n<div mousemove.delegate=\"mouseMove($event) & throttle\"></div>\n```\n\n[Throttle Demo](https://codesandbox.io/embed/015vo6z8p0?autoresize=1&fontsize=18&hidenavigation=1&module=%2Fsrc%2Fapp.html&view=preview)\n\n## debounce\n\nThe debounce binding behavior is another rate limiting binding behavior. Debounce prevents the binding from being updated until a specified interval has passed without any changes.\n\nA common use case is a search input that triggers searching automatically.  You wouldn't want to make a search API on every change (every keystroke).  It's more efficient to wait until the user has paused typing to invoke the search logic.\n\n```HTML Update after typing stopped for 200ms\n<input type=\"text\" value.bind=\"query & debounce\">\n```\n\n```HTML Update after typing stopped for 850ms\n<input type=\"text\" value.bind=\"query & debounce:850\">\n```\n\nLike throttle, the `debounce` binding behavior really shines in event binding. Here's another example with the `mousemove` event:\n\n```HTML Call mouseMove after mouse stopped moving for 500ms\n<div mousemove.delegate=\"mouseMove($event) & debounce:500\"></div>\n```\n\n[Debounce Demo](https://codesandbox.io/embed/zr7ylnjkm?autoresize=1&fontsize=18&hidenavigation=1&module=%2Fsrc%2Fapp.html&view=preview)\n\n## updateTrigger\n\nUpdate trigger allows you to override the input events that cause the element's value to be written to the view-model. The default events are `change` and `input`.\n\nHere's how you would tell the binding to only update the model on `blur`:\n\n```HTML Update on blur\n<input value.bind=\"firstName & updateTrigger:'blur'>\n```\n\nMultiple events are supported:\n\n```HTML Update with multiple events\n<input value.bind=\"firstName & updateTrigger:'blur':'paste'>\n```\n\n[Update Trigger Demo](https://codesandbox.io/embed/0y58p82w2v?autoresize=1&fontsize=18&hidenavigation=1&module=%2Fsrc%2Fapp.html&view=preview)\n\n## signal\n\nThe signal binding behavior enables you to \"signal\" the binding to refresh. This is especially useful when a binding result is impacted by global changes that are outside of the observation path.\n\nFor example, if you have a \"translate\" value converter that converts a key to a localized string- eg `\\${'greeting-key' | translate}` and your site allows users to change the current language, how would you refresh the bindings when that happens?\n\nAnother example is a value converter that uses the current time to convert a record's datetime to a \"time ago\" value:  `posted \\${postDateTime | timeAgo}`. The moment this binding expression is evaluated it will correctly result in `posted a minute ago`.  As time passes, it will eventually become inaccurate. How can we refresh this binding periodically so that it correctly displays `5 minutes ago`, then `15 minutes ago`, `an hour ago`, etc?\n\nHere's how you would accomplish this using the `signal` binding behavior:\n\n```HTML Using a Signal\nposted ${postDateTime | timeAgo & signal:'my-signal'}\n```\n\nIn the binding expression above we're using the `signal` binding behavior *to assign the binding a \"signal name\" of `my-signal`.* Signal names are arbitrary, you can give multiple bindings the same signal name if you want to signal multiple bindings at the same time.\n\nHere's how we can use the `BindingSignaler` to signal the bindings periodically:\n\n```JavaScript Signaling Bindings\nimport {BindingSignaler} from 'aurelia-templating-resources';\nimport {inject} from 'aurelia-framework';\n\n@inject(BindingSignaler)\nexport class App {\n  constructor(signaler) {\n    setInterval(() => signaler.signal('my-signal'), 5000);\n  }\n}\n```\n```TypeScript Signaling Bindings [variant]\nimport {BindingSignaler} from 'aurelia-templating-resources';\nimport {autoinject} from 'aurelia-framework';\n\n@autoinject\nexport class App {\n  constructor(signaler: BindingSignaler) {\n    setInterval(() => signaler.signal('my-signal'), 5000);\n  }\n}\n```\n\n[Signal Demo](https://codesandbox.io/embed/j3mjmnwrnw?autoresize=1&fontsize=18&hidenavigation=1&module=%2Fsrc%2Fapp.html&view=preview)\n\n## oneTime\n\nWith the `oneTime` binding behavior you can specify that string interpolated bindings should happen once. Simply write:\n\n```HTML One-time String Interpolation\n<span>${foo & oneTime}</span>\n```\n\nThis is an important feature to expose. One-time bindings are the most efficient type of binding because they don't incur any property observation overhead.\n\nThere are also binding behaviors for `toView` and `twoWay` which you could use like this:\n\n```HTML To-view and two-way binding behaviours\n<input value.bind=\"foo & toView\">\n<input value.to-view=\"foo\">\n\n<input value.bind=\"foo & twoWay\">\n<input value.two-way=\"foo\">\n```\n\n> Warning: Binding Mode Casing\n> The casing for binding modes is different depending on whether they appear as a **binding command** or as a **binding behavior**. Because HTML is case-insensitive, binding commands cannot use capitals. Thus, the binding modes, when specified in this place, use lowercase, dashed names. However, when used within a binding expression as a binding behavior, they must not use a dash because that is not a valid symbol for variable names in JavaScript. So, in this case, camel casing is used.\n\n## self\n\nWith the `self` binding behavior, you can specify that event handler will only response to the target where listener was attached to, not its descendants.\n\nFor example, in the following markup\n\n```HTML Self binding behavior\n<panel>\n  <header mousedown.delegate='onMouseDown($event)' ref='header'>\n    <button>Settings</button>\n    <button>Close</button>\n  </header>\n</panel>\n```\n\n`onMouseDown` is your event handler and it will be called not only when user `mousedown` on header element, but also all\nelements inside it, which in this case are the buttons `settings` and `close`. However, this is not always desired behavior.\nSometimes you want the component to only react when user click on the header itself, not the buttons. In order to achieve this, `onMouseDown` method needs\nsome modification:\n\n```JavaScript Handler without self binding behavior\n// inside component's view model class\nonMouseDown(event) {\n  // if mousedown on the header's descendants. Do nothing\n  if (event.target !== header) return;\n  // mousedown on header, start listening for mousemove to drag the panel\n  // ...\n}\n```\n\nThis works, but now business/ component logic are mixed up with DOM event handling, which are not necessary. Using `self` binding behavior can help\nyou achieve the same goal without filling up your methods with unnecessary code:\n\n```HTML Using self binding behavior\n<panel>\n  <header mousedown.delegate='onMouseDown($event) & self'>\n    <button class='settings'></button>\n    <button class='close'></button>\n  </header>\n</panel>\n```\n\n```JavaScript Using self binding behavior\n// inside component's view model class\nonMouseDown(event) {\n  // No need to perform check, as the binding behavior will ensure check\n  // if (event.target !== header) return;\n  // mousedown on header, start listening for mousemove to drag the panel\n  // ...\n}\n```\n\n## Custom binding behaviors\n\nYou can build custom binding behaviors just like you can build value converters. Instead of `toView` and `fromView` methods you'll create `bind(binding, scope, [...args])` and `unbind(binding, scope)` methods. In the bind method you'll add your behavior to the binding and in the unbind method you should cleanup whatever you did in the bind method to restore the binding instance to it's original state. The `binding` argument is the binding instance whose behavior you want to change. It's an implementation of the `Binding` interface. The `scope` argument is the binding's data-context. It provides access to the model the binding will be bound to via it's `bindingContext` and `overrideContext` properties.\n\nHere's a custom binding behavior that calls a method on your view model each time the binding's `updateSource` / `updateTarget` and `callSource` methods are invoked.\n\n```JavaScript Creating a Custom Binding Behavior\nconst interceptMethods = ['updateTarget', 'updateSource', 'callSource'];\n\nexport class InterceptBindingBehavior {\n  bind(binding, scope, interceptor) {\n    let i = interceptMethods.length;\n    while (i--) {\n      let method = interceptMethods[i];\n      if (!binding[method]) {\n        continue;\n      }\n      binding[`intercepted-${method}`] = binding[method];\n      let update = binding[method].bind(binding);\n      binding[method] = interceptor.bind(binding, method, update);\n    }\n  }\n\n  unbind(binding, scope) {\n    let i = interceptMethods.length;\n    while (i--) {\n      let method = interceptMethods[i];\n      if (!binding[method]) {\n        continue;\n      }\n      binding[method] = binding[`intercepted-${method}`];\n      binding[`intercepted-${method}`] = null;\n    }\n  }\n}\n```\n\n```HTML Using a Custom Binding Behavior\n<template>\n  <require from=\"./intercept-binding-behavior\"></require>\n\n  <div mousemove.delegate=\"mouseMove($event) & intercept:myFunc\"></div>\n\n  <input value.bind=\"foo & intercept:myFunc\">\n</template>\n```\n\n[Custom Binding Behavior Demo](https://codesandbox.io/embed/n5905k993m?autoresize=1&fontsize=18&hidenavigation=1&module=%2Fsrc%2Fapp.html&view=preview)\n"}