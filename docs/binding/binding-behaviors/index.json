{"name":"Binding Behaviors","description":"An overview of the Aurelia binding engine's binding behavior functionality. Binding Behaviors are used to plug into a binding instance's lifecycle and change the way it operates.","author":{"name":"Jeremy Danyow","url":"http://danyow.net"},"keywords":["JavaScript","Data Binding","Binding Behaviors"],"contributors":[],"translators":[],"links":{"static":"docs/binding/binding-behaviors","html":"docs/binding/binding-behaviors/index.html","fragment":"docs/binding/binding-behaviors/index-fragment.html","self":"docs/binding/binding-behaviors/index.json"},"content":"\n## [Introduction](aurelia-doc://section/1/version/1.0.0)\n\nBinding behaviors are a category of view resource, just like value converters, custom attributes and custom elements.  Binding behaviors are most like [value converters](http://www.danyow.net/aurelia-value-converters/) in that you use them declaratively in binding expressions to affect the binding.\n\nThe primary difference between a binding behavior and a value converter is *binding behaviors have full access to the binding instance, throughout it's lifecycle*. Contrast this with a value converter which only has the ability to intercept values passing from the model to the view and visa versa.\n\nThe additional \"access\" afforded to binding behaviors gives them the ability to change the behavior of the binding, enabling a lot of interesting scenarios which you'll see below.\n\n## [throttle](aurelia-doc://section/2/version/1.0.0)\n\nAurelia ships with a handful of behaviors out of the box to enable common scenarios.  The first is the throttle binding behavior which limits the rate at which the view-model is updated in two-way bindings or the rate at which the view is updated in to-view binding scenarios.\n\nBy default `throttle` will only allow updates every 200ms. You can customize the rate of course.  Here are a few examples.\n\n<code-listing heading=\"Updating a property, at most, every 200ms\">\n  <source-code lang=\"HTML\">\n    <input type=\"text\" value.bind=\"query & throttle\">\n  </source-code>\n</code-listing>\n\nThe first thing you probably noticed in the example above is the `&` symbol, which is used to declare binding behavior expressions. Binding behavior expressions use the same syntax pattern as value converter expressions:\n\n* Binding behaviors can accept arguments: `firstName & myBehavior:arg1:arg2:arg3`\n* A binding expression can contain multiple binding behaviors: `firstName & behavior1 & behavior2:arg1`.\n* Binding expressions can also include a combination of value converters and binding behaviors: `\\${foo | upperCase | truncate:3 & throttle & anotherBehavior:arg1:arg2}`.\n\nHere's another example using `throttle`, demonstrating the ability to pass arguments to the binding behavior:\n\n<code-listing heading=\"Updating a property, at most, every 850ms\">\n  <source-code lang=\"HTML\">\n    <input type=\"text\" value.bind=\"query & throttle:850\">\n  </source-code>\n</code-listing>\n\nThe throttle behavior is particularly useful when binding events to methods on your view-model.  Here's an example with the `mousemove` event:\n\n<code-listing heading=\"Handling an event, at most, every 200ms\">\n  <source-code lang=\"HTML\">\n    <div mousemove.delegate=\"mouseMove($event) & throttle\"></div>\n  </source-code>\n</code-listing>\n\n<au-demo heading=\"Throttle Demo\">\n  <source-code src=\"example/binding-binding-behaviors/throttle/app.js\"></source-code>\n</au-demo>\n\n## [debounce](aurelia-doc://section/3/version/1.0.0)\n\nThe debounce binding behavior is another rate limiting binding behavior. Debounce prevents the binding from being updated until a specified interval has passed without any changes.\n\nA common use case is a search input that triggers searching automatically.  You wouldn't want to make a search API on every change (every keystroke).  It's more efficient to wait until the user has paused typing to invoke the search logic.\n\n<code-listing heading=\"Update after typing stopped for 200ms\">\n  <source-code lang=\"HTML\">\n    <input type=\"text\" value.bind=\"query & debounce\">\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Update after typing stopped for 850ms\">\n  <source-code lang=\"HTML\">\n    <input type=\"text\" value.bind=\"query & debounce:850\">\n  </source-code>\n</code-listing>\n\nLike throttle, the `debounce` binding behavior really shines in event binding. Here's another example with the `mousemove` event:\n\n<code-listing heading=\"Call mouseMove after mouse stopped moving for 500ms\">\n  <source-code lang=\"HTML\">\n    <div mousemove.delegate=\"mouseMove($event) & debounce:500\"></div>\n  </source-code>\n</code-listing>\n\n<au-demo heading=\"Debounce Demo\">\n  <source-code src=\"example/binding-binding-behaviors/debounce/app.js\"></source-code>\n</au-demo>\n\n## [updateTrigger](aurelia-doc://section/4/version/1.0.0)\n\nUpdate trigger allows you to override the input events that cause the element's value to be written to the view-model. The default events are `change` and `input`.\n\nHere's how you would tell the binding to only update the model on `blur`:\n\n<code-listing heading=\"Update on blur\">\n  <source-code lang=\"HTML\">\n    <input value.bind=\"firstName & updateTrigger:'blur'>\n  </source-code>\n</code-listing>\n\nMultiple events are supported:\n\n<code-listing heading=\"Update with multiple events\">\n  <source-code lang=\"HTML\">\n    <input value.bind=\"firstName & updateTrigger:'blur':'paste'>\n  </source-code>\n</code-listing>\n\n<au-demo heading=\"Update Trigger Demo\">\n  <source-code src=\"example/binding-binding-behaviors/update-trigger/app.js\"></source-code>\n</au-demo>\n\n## [signal](aurelia-doc://section/5/version/1.0.0)\n\nThe signal binding behavior enables you to \"signal\" the binding to refresh. This is especially useful when a binding result is impacted by global changes that are outside of the observation path.\n\nFor example, if you have a \"translate\" value converter that converts a key to a localized string- eg `\\${'greeting-key' | translate}` and your site allows users to change the current language, how would you refresh the bindings when that happens?\n\nAnother example is a value converter that uses the current time to convert a record's datetime to a \"time ago\" value:  `posted \\${postDateTime | timeAgo}`. The moment this binding expression is evaluated it will correctly result in `posted a minute ago`.  As time passes, it will eventually become inaccurate. How can we refresh this binding periodically so that it correctly displays `5 minutes ago`, then `15 minutes ago`, `an hour ago`, etc?\n\nHere's how you would accomplish this using the `signal` binding behavior:\n\n<code-listing heading=\"Using a Signal\">\n  <source-code lang=\"HTML\">\n    posted ${postDateTime | timeAgo & signal:'my-signal'}\n  </source-code>\n</code-listing>\n\nIn the binding expression above we're using the `signal` binding behavior *to assign the binding a \"signal name\" of `my-signal`.* Signal names are arbitrary, you can give multiple bindings the same signal name if you want to signal multiple bindings at the same time.\n\nHere's how we can use the `BindingSignaler` to signal the bindings periodically:\n\n<code-listing heading=\"Signaling Bindings\">\n  <source-code lang=\"ES 2015\">\n    import {BindingSignaler} from 'aurelia-templating-resources';\n\n    export class App {\n      static inject() { return [BindingSignaler] };\n\n      constructor(signaler) {\n        setInterval(() => signaler.signal('my-signal'), 5000);\n      }\n    }\n  </source-code>\n  <source-code lang=\"ES 2016\">\n    import {BindingSignaler} from 'aurelia-templating-resources';\n    import {inject} from 'aurelia-framework';\n\n    @inject(BindingSignaler)\n    export class App {\n      constructor(signaler) {\n        setInterval(() => signaler.signal('my-signal'), 5000);\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {BindingSignaler} from 'aurelia-templating-resources';\n    import {autoinject} from 'aurelia-framework';\n\n    @autoinject\n    export class App {\n      constructor(signaler: BindingSignaler) {\n        setInterval(() => signaler.signal('my-signal'), 5000);\n      }\n    }\n  </source-code>\n</code-listing>\n\n<au-demo heading=\"Signal Demo\">\n  <source-code src=\"example/binding-binding-behaviors/signal/app.js\"></source-code>\n</au-demo>\n\n## [oneTime](aurelia-doc://section/6/version/1.0.0)\n\nWith the `oneTime` binding behavior you can specify that string interpolated bindings should happen once. Simply write:\n\n<code-listing heading=\"One-time String Interpolation\">\n  <source-code lang=\"HTML\">\n    <span>${foo & oneTime}</span>\n  </source-code>\n</code-listing>\n\nThis is an important feature to expose. One-time bindings are the most efficient type of binding because they don't incur any property observation overhead.\n\nThere are also binding behaviors for `toView` and `twoWay` which you could use like this:\n\n<code-listing heading=\"To-view and two-way binding behaviours\">\n  <source-code lang=\"HTML\">\n    <input value.bind=\"foo & toView\">\n    <input value.to-view=\"foo\">\n\n    <input value.bind=\"foo & twoWay\">\n    <input value.two-way=\"foo\">\n  </source-code>\n</code-listing>\n\n> Warning: Binding Mode Casing\n> The casing for binding modes is different depending on whether they appear as a **binding command** or as a **binding behavior**. Because HTML is case-insensitive, binding commands cannot use capitals. Thus, the binding modes, when specified in this place, use lowercase, dashed names. However, when used within a binding expression as a binding behavior, they must not use a dash because that is not a valid symbol for variable names in JavaScript. So, in this case, camel casing is used.\n\n## [self](aurelia-doc://section/7/version/1.0.0)\n\nWith the `self` binding behavior, you can specify that event handler will only response to the target where listener was attached to, not its descendants.\n\nFor example, in the following markup\n\n<code-listing heading=\"Self binding behavior\">\n  <source-code lang=\"HTML\">\n    <panel>\n      <header mousedown.delegate='onMouseDown($event)' ref='header'>\n        <button>Settings</button>\n        <button>Close</button>\n      </header>\n    </panel>\n  </source-code>\n</code-listing>\n\n`onMouseDown` is your event handler and it will be called not only when user `mousedown` on header element, but also all\nelements inside it, which in this case are the buttons `settings` and `close`. However, this is not always desired behavior.\nSometimes you want the component to only react when user click on the header itself, not the buttons. In order to achieve this, `onMouseDown` method needs\nsome modification:\n\n<code-listing heading=\"Handler without self binding behavior\">\n  <source-code lang=\"ES 2015/ES 2016/TypeScript\">\n    // inside component's view model class\n    onMouseDown(event) {\n      // if mousedown on the header's descendants. Do nothing\n      if (event.target !== header) return;\n      // mousedown on header, start listening for mousemove to drag the panel\n      // ...\n    }\n  </source-code>\n</code-listing>\n\nThis works, but now business/ component logic are mixed up with DOM event handling, which are not necessary. Using `self` binding behavior can help\nyou achieve the same goal without filling up your methods with unnecessary code:\n\n<code-listing heading=\"Using self binding behavior\">\n  <source-code lang=\"HTML\">\n    <panel>\n      <header mousedown.delegate='onMouseDown($event) & self'>\n        <button class='settings'></button>\n        <button class='close'></button>\n      </header>\n    </panel>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Using self binding behavior\">\n  <source-code lang=\"ES 2015/ES 2016/TypeScript\">\n    // inside component's view model class\n    onMouseDown(event) {\n      // No need to perform check, as the binding behavior will ensure check\n      // if (event.target !== header) return;\n      // mousedown on header, start listening for mousemove to drag the panel\n      // ...\n    }\n  </source-code>\n</code-listing>\n\n## [Custom binding behaviors](aurelia-doc://section/8/version/1.0.0)\n\nYou can build custom binding behaviors just like you can build value converters. Instead of `toView` and `fromView` methods you'll create `bind(binding, scope, [...args])` and `unbind(binding, scope)` methods. In the bind method you'll add your behavior to the binding and in the unbind method you should cleanup whatever you did in the bind method to restore the binding instance to it's original state. The `binding` argument is the binding instance whose behavior you want to change. It's an implementation of the `Binding` interface. The `scope` argument is the binding's data-context. It provides access to the model the binding will be bound to via it's `bindingContext` and `overrideContext` properties.\n\nHere's a custom binding behavior that calls a method on your view model each time the binding's `updateSource` / `updateTarget` and `callSource` methods are invoked.\n\n<code-listing heading=\"Creating a Custom Binding Behavior\">\n  <source-code lang=\"ES 2015/ES 2016/TypeScript\">\n    const interceptMethods = ['updateTarget', 'updateSource', 'callSource'];\n\n    export class InterceptBindingBehavior {\n      bind(binding, scope, interceptor) {\n        let i = interceptMethods.length;\n        while (i--) {\n          let method = interceptMethods[i];\n          if (!binding[method]) {\n            continue;\n          }\n          binding[`intercepted-${method}`] = binding[method];\n          let update = binding[method].bind(binding);\n          binding[method] = interceptor.bind(binding, method, update);\n        }\n      }\n\n      unbind(binding, scope) {\n        let i = interceptMethods.length;\n        while (i--) {\n          let method = interceptMethods[i];\n          if (!binding[method]) {\n            continue;\n          }\n          binding[method] = binding[`intercepted-${method}`];\n          binding[`intercepted-${method}`] = null;\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Using a Custom Binding Behavior\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"./intercept-binding-behavior\"></require>\n\n      <div mousemove.delegate=\"mouseMove($event) & intercept:myFunc\"></div>\n\n      <input value.bind=\"foo & intercept:myFunc\">\n    </template>\n  </source-code>\n</code-listing>\n\n<au-demo heading=\"Custom Binding Behavior Demo\">\n  <source-code src=\"example/binding-binding-behaviors/custom/app.js\"></source-code>\n</au-demo>\n"}