{"name":"Binding: Basics","description":"The basics of data-binding with Aurelia.","author":{"name":"Jeremy Danyow","url":"http://danyow.net"},"featured":false,"links":{"static":"docs/binding/basics","html":"docs/binding/basics/index.html","fragment":"docs/binding/basics/index-fragment.html","self":"docs/binding/basics/index.json"},"content":"\n\n## Introduction\n\nThis article covers the basics of data-binding with Aurelia. You'll learn how to bind to HTML attributes, DOM Events and element content. You'll also see how to give your view-models references to DOM elements, making it easy work with elements directly.\n\n## HTML and SVG Attributes\n\nAurelia supports binding HTML and SVG attributes to JavaScript expressions. Attribute binding declarations have three parts: `attribute.command=\"expression\"`.\n\n* `attribute`:  an HTML or SVG attribute name.\n* `command`: one of Aurelia's attribute binding commands:\n  * `one-time`: flows data one direction: from the view-model to the view, **once**.\n  * `to-view` / `one-way`: flows data one direction: from the view-model to the view.\n  * `from-view`: flows data one direction: from the view to the view-model.\n  * `two-way`: flows data both ways: from view-model to view and from view to view-model.\n  * `bind`: automically chooses the binding mode. Uses two-way binding for form controls and to-view binding for almost everything else.\n* `expression`: a JavaScript expression.\n\nTypically you'll use the `bind` command since it does what you intend most of the time.  Consider using `one-time` in performance critical situations where the data never changes because it skips the overhead of observing the view-model for changes. Below are a few examples.\n\n```HTML HTML Attribute Binding Examples\n<input type=\"text\" value.bind=\"firstName\">\n<input type=\"text\" value.two-way=\"lastName\">\n<input type=\"text\" value.from-view=\"middleName\">\n\n<a class=\"external-link\" href.bind=\"profile.blogUrl\">Blog</a>\n<a class=\"external-link\" href.to-view=\"profile.twitterUrl\">Twitter</a>\n<a class=\"external-link\" href.one-time=\"profile.linkedInUrl\">LinkedIn</a>\n```\n\nThe first input uses the `bind` command which will automatically create `two-way` bindings for input value attribute bindings. The second and third input uses the `two-way` / `from-view` commands which explicitly set the binding modes. For the first and second inputs, their value will be updated whenever the bound view-model `firstName` / `lastName` properties are updated, and the those properties will also be updated whenever the inputs change. For the third input, changes in the bound view-model `middleName` property will not update the input value, however, changes in the input will update the view-model. The first anchor element uses the `bind` command which will automatically create a `to-view` binding for anchor href attributes. The other two anchor elements use the `to-view` and `one-time` commands to explicitly set the binding's mode.\n\n## DOM Events\n\nThe binding system supports binding to DOM events.  A DOM event binding will execute a JavaScript expression whenever the specified DOM event occurs. Event binding declarations have three parts: `event.command=\"expression\"`.\n\n* `event`:  the name of a DOM event, without the \"on\" prefix.\n* `command`: one of Aurelia's event binding commands:\n  * `trigger`: attaches an event handler directly to the element. When the event fires, the expression will be invoked.\n  * `delegate`: attaches a single event handler to the document (or nearest shadow DOM boundary) which handles all events of the specified type in **bubbling** phase, properly dispatching them back to their original targets for invocation of the associated expression.\n  * `capture`: attaches a single event handler to the document (or nearest shadow DOM boundary) which handles all events of the specified type in **capturing** phase, properly dispatching them back to their original targets for invocation of the associated expression.\n* `expression`: a JavaScript expression. Use the special `$event` property to access the DOM event in your binding expression.\n\nBelow are a few examples.\n\n```HTML DOM Event Binding Examples\">\n<button type=\"button\" click.trigger=\"cancel()\">Cancel</button>\n\n<button type=\"button\" click.delegate=\"select('yes')\">Yes</button>\n<button type=\"button\" click.delegate=\"select('no')\">No</button>\n\n<input type=\"text\" blur.trigger=\"elementBlurred($event.target)\">\n<input type=\"text\" change.delegate=\"lastName = $event.target.value\">\n```\n\nThe cancel button uses the `trigger` command to attach an event listener to the button element that will call the view-model's cancel method.  The yes and no buttons use the `delegate` command which will use the event delegation pattern.  The input elements have binding expressions that use the special `$event` property to access the [DOM event](https://developer.mozilla.org/en-US/docs/Web/API/Event).\n\nAurelia will automatically call [`preventDefault()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault) on events handled with `delegate` or `trigger` binding. Most of the time this is the behavior you want. To turn this off, return `true` from your event handler function.\n\n## Function References\n\nWhile developing custom elements or custom attributes you may encounter a situation where you have a `@bindable` property that expects a reference to a function. Use the `call` binding command to declare and pass a function to the bindable property. The `call` command is superior to the `bind` command for this use-case because it will execute the function in the correct context, ensuring `this` is what you expect it to be.\n\n```HTML Simple call binding\n<my-element go.call=\"doSomething()\"></my-element>\n\n<input type=\"text\" value.bind=\"taskName\">\n<my-element go.call=\"doSomething(taskName)\"></my-element>\n```\n\nYour custom element or attribute can invoke the function that was passed to the `@bindable` property using standard call syntax: `this.go();`. If you need to invoke the function with arguments, create an object whose keys are the argument names and whose values are the argument values, then invoke the function with this \"arguments object\". The object's properties will be available for data-binding in the `call` binding expression.  For example, invoking the function with `this.go({ x: 5, y: -22, z: 11})`) will make `x`, `y` and `z` available for binding:\n\n```HTML Accessing the call argument properties\n<my-element execute.call=\"doSomething(x, y)\"></my-element>\n```\n\n## Referencing Elements\n\nUse the `ref` binding command to create a reference to a DOM element. The ref command's most basic syntax is `ref=\"expression\"`. When the view is data-bound the specified expression will be assigned the DOM element.\n\n```HTML Simple ref example\n<template>\n  <input type=\"text\" ref=\"nameInput\"> ${nameInput.value}\n</template>\n```\n\nThe `ref` command has several qualifiers you can use in conjunction with custom elements and attributes:\n\n* `element.ref=\"expression\"`: create a reference to the DOM element (same as `ref=\"expression\"`).\n* `attribute-name.ref=\"expression\"`: create a reference to a custom attribute's view-model.\n* `view-model.ref=\"expression\"`: create a reference to a custom element's view-model.\n* `view.ref=\"expression\"`: create a reference to a custom element's view instance (not an HTML Element).\n* `controller.ref=\"expression\"`: create a reference to a custom element's controller instance.\n\n## String Interpolation\n\nString interpolation expressions enable interpolating (surprise!) the result of an expression with text.  The best way to demonstrate this capability is with an example. Below are two span elements with data-bound textcontent:\n\n```HTML String interpolation example\n<span textcontent.bind=\"'Hello' + firstName\"></span>\n\n<span>Hello ${firstName}</span>\n```\n\nThe first span uses the `bind` command. The second uses string interpolation.  The interpolated version is much easier to read and easy to remember because the syntax matches the [template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) syntax standardized in ES2015/ES6.\n\nString interpolation can be used within html attributes as an alternative to to-view binding. By default, the mode of an interpolation binding is `to-view` and the result of the expression is always coerced to a string. Results that are `null` or `undefined` will result in empty string.\n\n## Element Content\n\nThe previous example compared string interpolation binding with `textcontent.bind`. Interpolation is easier to read but `textcontent.bind` can come in handy when you need to two-bind a `contenteditable` element:\n\n```HTML textContent example\n<div contenteditable textcontent.bind=\"firstName\"></div>\n<div contenteditable textcontent.bind=\"lastName\"></div>\n```\n\nYou may also need to bind html text to an element's `innerHTML` property:\n\n```HTML Binding innerHTML\n<template>\n  <div innerhtml.bind=\"htmlProperty | sanitizeHTML\"></div>\n  <div innerhtml=\"${htmlProperty | sanitizeHTML}\"></div>\n</template>\n```\n\n> Danger\n> Always use HTML sanitization. We provide a simple converter as a placeholder. However, it does NOT provide security against a wide variety of sophisticated XSS attacks, and should not be relied upon for sanitizing input from unknown sources. You can replace the built-in sanitizer by registering your own implementation of [HTMLSanitizer](https://github.com/aurelia/templating-resources/blob/master/src/html-sanitizer.js) with the app at startup. For example, `aurelia.use.singleton(HTMLSanitizer, BetterHTMLSanitizer);` We recommend using a library such as DOMPurify or sanitize-html for your implementation.\n\n> Warning\n> Binding using the `innerhtml` attribute simply sets the element's `innerHTML` property.  The markup does not pass through Aurelia's templating system.  Binding expressions and require elements will not be evaluated.\n\n## Contextual Properties\n\nThe binding system makes several properties available for binding in your templates, depending on the context.\n\n* `$this` - The binding context (the view-model).\n* `$parent` - Explicitly accesses the outer scope from within a compose or repeat template. You may need this when a property on the current scope masks a property on the outer scope. Chainable- eg `$parent.$parent.foo` is supported.\n* `$event` - The DOM Event in delegate or trigger bindings.\n* `$index` - In a repeat template, the index of the item in the collection.\n* `$first` - In a repeat template, is true if the item is the first item in the array.\n* `$last` - In a repeat template, is true if the item is the last item in the array.\n* `$even` - In a repeat template, is true if the item has an even numbered index.\n* `$odd` - In a repeat template, is true if the item has an odd numbered index.\n\n## Expression Syntax\n\nAurelia's expression parser implements a subset of [ECMAScript Expressions](https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions). For the features that are supported, you can typically expect the JavaScript in your view to work the same way as it would in your view model, or in the browser console. In addition there are two adjustments:\n\n* The Ampersand `&` represents a `BindingBehavior` (instead of Bitwise AND)\n* The Bar `|` represents a `ValueConverter` (instead of a Bitwise OR)\n\nNon-expression syntax (statements, declarations, function and class definitions) is not supported.\n\nAs an overview of various expressions that are possible, the following list is for illustrative purposes and not exhaustive (and not necessarily recommended, either), but should give you a fairly good idea of what you can do:\n\n### Primary Expressions\n\n#### Identifiers\n\n* `foo` - The `foo` variable in the current view-model\n* `ßɑṙ` - The `ßɑṙ` variable in the current view-model\n\n> Info\n> non-ASCII characters in the [Latin](https://en.wikipedia.org/wiki/Latin_script_in_Unicode#Table_of_characters) script are supported. This script contains 1,350 characters covering the vast majority of languages. Other [Non-BMP characters / Surrogate Pairs](https://en.wikipedia.org/wiki/Plane_(Unicode)) are not supported.\n\n#### Identifiers with special meaning in Aurelia\n\n* `$this` - The current view-model\n* `$parent` - The parent view-model\n\n#### Primitive literals\n\n* `true` - The literal value `true`\n* `false` - The literal value `false`\n* `null` - The literal value `null`\n* `undefined` - The literal value `undefined`\n\n#### String literals and escape sequences\n\n* `'foo'` or `\"foo\"` - The literal string `foo`\n* `'\\n'` - The literal string `[NEWLINE]`\n* `'\\t'` - The literal string `[TAB]`\n* `'\\''` - The literal string `'`\n* `'\\\\'` - The literal string `\\`\n* `'\\\\n'` - The literal string `\\n`\n* `'\\u0061'` - The literal string `a`\n\n> Warning\n> Unsupported string literals include `'\\x61'` (2-point hex escape), `'\\u{61}'` or `'\\u{000061}'` (n-point braced unicode escape), and Non-BMP characters and Surrogate Pairs.\n\n#### Template literals\n\n* `` `foo` `` - Equivalent to `'foo'`\n* `` `foo\\${bar}baz\\${qux}quux` `` - Equivalent to `'foo'+bar+'baz'+qux+'quux'`\n\n#### Numeric literals\n\n* `42` - The literal number `42`\n* `42.` or `42.0` - The literal number `42.0`\n* `.42` or `0.42` - The literal number `0.42`\n* `42.3` - The literal number `42.3`\n* `10e3` or `10E3` - The literal number `1000`\n\n> Warning\n> Unsupported numeric literals include `0b01` (binary integer literal), `0o07` (octal integer literal), and `0x0F` (hex integer literal).\n\n#### Array literals\n\n* `[]` - An empty array\n* `[1,2,3]` - An array containing the literal numbers `1`, `2` and `3`\n* `[foo, bar]` - An array containing the variables `foo` and `bar`\n* `[[]]` - An array containing an empty array\n\n> Warning\n> Unsupported array literals include `[,]` - [Elision](https://tc39.github.io/ecma262/#prod-Elision)\n\n#### Object literals\n\n* `{}` - An empty object\n* `{foo}` or `{foo,bar}` - ES6 shorthand notation, equivalent to `{'foo':foo}` or `{'foo':foo,'bar':bar}`\n* `{42:42}` - Equivalent to `{'42':42}`\n\n> Warning\n> Unsupported object literals include `{[foo]: bar}` or `{['foo']: bar}` (computed property names).\n\n### Unary expressions\n\n**`foo` here represents any valid primary expression or unary expression.**\n\n* `+foo` or `+1` - Equivalent to `foo` or `1` (the `+` unary operator is always ignored)\n* `-foo` or `-1` - Equivalent to `0-foo` or `0-1`\n* `!foo` - Negates `foo`\n* `typeof foo` - Returns the primitive type name of `foo`\n* `void foo` - Evaluates `foo` and returns `undefined`\n\n> Warning\n> Unary increment (`++foo` or `foo++`), decrement (`--foo` or `foo--`), bitwise (`~`), `delete`, `await` and `yield` operators are not supported.\n\n### Binary expressions (from highest to lowest precedence)\n\n**`a` and `b` here represent any valid primary, unary or binary expression.**\n\n* `a*b` or `a/b` or `a%b` - Multiplicative\n* `a+b` or `a-b` - Additive\n* <code>a&lt;b</code> or <code>a&gt;b</code> or <code>a&lt;=b</code> or <code>a&gt;=b</code> or `a in b` or `a instanceof b` - Relational\n* `a==b` or `a!=b` or `a===b` or `a!==b` - Equality\n* `a&&b` - Logical AND\n* `a||b` - Logical OR\n\n> Warning\n> Exponentiation (`a**b`) and bitwise operators are not supported.\n\n### Conditional expressions\n\n**`foo` etc here represent any valid primary, unary, binary or conditional expression.**\n\n* `foo ? bar : baz`\n* `foo ? bar : baz ? qux : quux`\n\n### Assignment expressions\n\n**`foo` here must be an assignable expression (a simple accessor, a member accessor or an indexed member accessor). `bar` can any valid primary, unary, binary, conditional or assignment expression.**\n\n* `foo = bar`\n* `foo = bar = baz`\n\n### Member and Call expressions\n\nMember expressions with special meaning in Aurelia:\n* `$parent.foo` - Access the `foo` variable in the parent view-model\n* `$parent.$parent.foo` - Access the `foo` variable in the parent's parent view-model\n* `$this` - Access the current view-model (equivalent to simply `this` inside the view-model if it's an ES class)\n\nNormal member and call expressions:\n\n**`foo` here represents any valid member, call, assignment, conditional, binary, unary or primary expression (provided the expression as a whole is also valid JavaScript).**\n\n* `foo.bar` - Member accessor\n* `foo['bar']` - Keyed member accessor\n* `foo()` - Function call\n* `foo.bar()` - Member function call\n* `foo['bar']()` - Keyed member function call\n\nTagged template literals:\n\n**`foo` here should be a function that can be called. The string parts of the template are passed as an array to the first argument and the expression parts are passed as consecutive arguments.**\n\n* ``foo`bar` `` - Equivalent to `foo(['bar'])`\n* ``foo`bar\\${baz}qux` `` - Equivalent to `foo(['bar','qux'], baz)`\n* ``foo`bar\\${baz}qux\\${quux}corge` `` - Equivalent to `foo(['bar','qux','corge'],baz,quux)`\n* ``foo`\\${bar}\\${baz}\\${qux}` `` - Equivalent to `foo(['','','',''],bar,baz,qux)`\n\n### Binding Behaviors and Value Converters\n\nThese are not considered to be a part of normal expressions and must always come at the end of an expression (though multiple can be chained). Furthermore, BindingBehaviors must come after ValueConverters.\n(note: BindingBehavior and ValueConverter are abbreviated to BB and VC for readability)\n\nValid BB expressions:\n\n* `foo & bar & baz` - Applies the BB `bar` to the variable `foo`, and then applies the BB `baz` to the result of that.\n* `foo & bar:'baz'` - Applies the BB `bar` to the variable `foo`, and passes the literal string `'baz'` as an argument to the BB\n* `foo & bar:baz:qux` - Applies the BB `bar` to the variable `foo`, and passes the variables `baz` and `qux` as arguments to the BB\n* `'foo' & bar` - Applies the BB `bar` to the literal string `'foo'`\n\nValid VC expressions (likewise):\n\n* `foo | bar | baz`\n* `foo | bar:'baz'`\n* `foo | bar:baz:qux`\n* `'foo' | bar`\n\nCombined BB and VC expressions:\n\n* `foo | bar & baz`\n* `foo | bar:42:43 & baz:'qux':'quux'`\n* `foo | bar | baz & qux & quux`\n\nInvalid combined BB and VC expressions (BB must come at the end):\n\n* `foo & bar | baz`\n* `foo | bar & baz | qux`\n"}