{"name":"Binding: Observables","description":"Using observables with Aurelia.","featured":false,"links":{"static":"docs/binding/observable-properties","html":"docs/binding/observable-properties/index.html","fragment":"docs/binding/observable-properties/index-fragment.html","self":"docs/binding/observable-properties/index.json"},"content":"\n\n## Observable Properties\n\nHave you ever needed to perform an action when a property is changed? If you have, that's a great use of property observation.\n\nTo observe a property, you need to decorate it with the `@observable` decorator and define a method as the change handler. This method can receive 2 parameters: the new value and the old value. You can put any business logic inside this method.\n\nBy convention, the change handler is a method whose name is composed of the _property_name_ and the literal value 'Changed'. For example, if you decorate the property `color` with `@observable`, you have to define a method named `colorChanged()` to be the change handler. Here's an example of that:\n\n```JavaScript Observable Properties\nimport { observable } from 'aurelia-framework';\n\nexport class Car {\n  @observable color = 'blue';\n\n  colorChanged(newValue, oldValue) {\n    // this will fire whenever the 'color' property changes\n  }\n}\n```\n```TypeScript Observable Properties [variant]\nimport { observable } from 'aurelia-framework';\n\nexport class Car {\n  @observable color = 'blue';\n\n  colorChanged(newValue, oldValue) {\n    // this will fire whenever the 'color' property changes\n  }\n}\n```\n\n> Info\n> You do not have to check if `newValue` and `oldValue` are different. The change handler will not be called if you assign a value that the property already has.\n\nIf you do not want to use the convention, you can define the callback name for the change handler by setting the `changeHandler` property of the `@observable` decorator:\n\n```JavaScript Observable Properties\nimport { observable } from 'aurelia-framework';\n\nexport class Car {\n  @observable({ changeHandler: 'myChangeHandler' })\n  color = 'blue';\n\n  myChangeHandler(newValue, oldValue) {\n    // this will fire whenever the 'color' property changes\n  }\n}\n```\n```TypeScript Observable Properties [variant]\nimport { observable } from 'aurelia-framework';\n\nexport class Car {\n  @observable({ changeHandler: 'myChangeHandler' })\n  color = 'blue';\n\n  myChangeHandler(newValue, oldValue) {\n    // this will fire whenever the 'color' property changes\n  }\n}\n```\n\nIf you prefer, can also put the `@observable` on classes:\n\n```JavaScript Observable Properties\nimport { observable } from 'aurelia-framework';\n\n@observable('color')\n@observable({ name: 'speed', changeHandler: 'speedChangeHandler' })\nexport class Car {\n  color = 'blue';\n  speed = 300;\n\n  colorChanged(newValue, oldValue) {\n    // this will fire whenever the 'color' property changes\n  }\n\n  speedChangeHandler(newValue, oldValue) {\n    // this will fire whenever the 'speed' property changes\n  }\n}\n```\n```TypeScript Observable Properties [variant]\nimport { observable } from 'aurelia-framework';\n\n@observable('color')\n@observable({ name: 'speed', changeHandler: 'speedChangeHandler' })\nexport class Car {\n\n  color = 'blue';\n  speed = 300;\n\n  colorChanged(newValue, oldValue) {\n    // this will fire whenever the 'color' property changes\n  }\n\n  speedChangeHandler(newValue, oldValue) {\n    // this will fire whenever the 'speed' property changes\n  }\n}\n```\n\n> Info\n> The `@observable` _only_ tracks changes to the value of a property, _not_ changes _in_ the value itself. This means that if the property is an array, the change handler will not fire when adding, removing or editing items.\n\n\n## Observing Collections\n\nUse the Collection Observer to observe changes to a collection. Collection types that can be observed are [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), and [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set). Create a subscription by providing the collection to observe and a callback function.\n\n```JavaScript Configuring a Collection Observer\nimport {BindingEngine} from 'aurelia-framework';\n\n@inject(BindingEngine)\nexport class App {\n\n  myCollection = [\"foo\"];\n\n  constructor(bindingEngine) {\n    let subscription = bindingEngine.collectionObserver(this.myCollection)\n      .subscribe(this.collectionChanged.bind(this));\n  }\n\n  collectionChanged(splices) {\n      // This will fire any time the collection is modified. \n  }\n}\n```\n```TypeScript Configuring a Collection Observer [variant]\nimport {BindingEngine, autoinject, ICollectionObserverSplice} from 'aurelia-framework';\n\n@autoinject\nexport class App {\n\n  myCollection: Array<string> = [\"foo\"];\n\n  constructor(private bindingEngine: BindingEngine) {\n    let subscription = this.bindingEngine.collectionObserver(this.myCollection)\n      .subscribe(this.collectionChanged.bind(this));\n  }\n\n  collectionChanged(splices: Array<ICollectionObserverSplice<string>>) {\n      // This will fire any time the collection is modified. \n  }\n}\n```\n\nThe callback will receive an array of splices which provides information about the change that was detcted. The properties of the splice may vary depending on the type of collection being observed. Here you can see example callback functions used to observe each of the different collection types.\n\n```JavaScript Array Splice\ncollectionChanged(splices) {\n  for (var i = 0; i < splices.length; i++) {\n    var splice = splices[i];\n\n    var valuesAdded = this.myCollection.slice(splice.index, splice.index + splice.addedCount);\n    if (valuesAdded.length > 0) {\n      console.log(`The following values were inserted at ${splice.index}: ${JSON.stringify(valuesAdded)}`);\n    }\n\n    if (splice.removed.length > 0) {\n      console.log(`The following values were removed from ${splice.index}: ${JSON.stringify(splice.removed)}`);\n    }\n  }\n}\n```\n```TypeScript Array Splice [variant]\ncollectionChanged(splices: Array<ICollectionObserverSplice<string>>) {\n  for (var i = 0; i < splices.length; i++) {\n    var splice: ICollectionObserverSplice<string> = splices[i];\n\n    var valuesAdded = this.myCollection.slice(splice.index, splice.index + splice.addedCount);\n    if (valuesAdded.length > 0) {\n      console.log(`The following values were inserted at ${splice.index}: ${JSON.stringify(valuesAdded)}`);\n    }\n\n    if (splice.removed.length > 0) {\n      console.log(`The following values were removed from ${splice.index}: ${JSON.stringify(splice.removed)}`);\n    }\n  }\n}\n```\n\n```JavaScript Map Splice\ncollectionChanged(splices) {\n  for (var i = 0; i < splices.length; i++) {\n    var splice = splices[i];\n\n    if(splice.type == \"add\"){\n      var valuesAdded = this.myCollection.get(splice.key);\n      console.log(`'${valuesAdded}' was added to position ${splice.key}`);\n    }\n    \n    if(splice.type == \"update\"){\n      var newValue = splice.object.get(splice.key);\n      console.log(`Position ${splice.key} changed from '${splice.oldValue}' to '${newValue}'`);\n    }\n\n    if(splice.type == \"delete\"){\n      console.log(`'${splice.oldValue}' was deleted from position ${splice.key}`);\n    }\n  \n  }\n}\n```\n```TypeScript Map Splice [variant]\ncollectionChanged(splices: Array<ICollectionObserverSplice<Map<number, string>>>) {\n  for (var i = 0; i < splices.length; i++) {\n    var splice: ICollectionObserverSplice<Map<number, string>> = splices[i];\n\n    if(splice.type == \"add\"){\n      var valuesAdded = this.myCollection.get(splice.key);\n      console.log(`'${valuesAdded}' was added to position ${splice.key}`);\n    }\n    \n    if(splice.type == \"update\"){\n      var newValue = splice.object.get(splice.key);\n      console.log(`Position ${splice.key} changed from '${splice.oldValue}' to '${newValue}'`);\n    }\n\n    if(splice.type == \"delete\"){\n      console.log(`'${splice.oldValue}' was deleted from position ${splice.key}`);\n    }\n  \n  }\n}\n```\n\n```JavaScript Set Splice\ncollectionChanged(splices) {\n  for (var i = 0; i < splices.length; i++) {\n    var splice = splices[i];\n\n    if(splice.type == \"add\"){\n      console.log(`'${splice.value}' was added to the set`);\n    }\n\n    if(splice.type == \"delete\"){\n      console.log(`'${splice.value}' was removed from the set`);\n    }\n  }\n}\n```\n```TypeScript Set Splice [variant]\ncollectionChanged(splices: Array<ICollectionObserverSplice<Set<number>>>) {\n  for (var i = 0; i < splices.length; i++) {\n    var splice: ICollectionObserverSplice<Set<number>> = splices[i];\n\n    if(splice.type == \"add\"){\n      console.log(`'${splice.value}' was added to the set`);\n    }\n\n    if(splice.type == \"delete\"){\n      console.log(`'${splice.value}' was removed from the set`);\n    }\n  }\n}\n```\n\n> Warning\n> If you were to overwrite the value of the collection after the subscription has been created, changes wil no longer be detected. For example, running `this.myCollection = []` after `this.bindingEngine.collectionObserver(this.myCollection)` will fail to observe changes to `myCollection`.\n"}