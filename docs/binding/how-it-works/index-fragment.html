<section class="article">
  <header>
    <h1>Binding: How it Works</h1>
    <h2>How data-binding works in Aurelia.</h2>
  </header>

  <article class="markdown">
    <section><h2 id="end-to-end">End to End</h2><p>This article explains how the binding system works. There is a lot to cover here, and to start we're actually going to look at a component outside of the binding system so you can gain a full understanding of the process. A good place to start is in the templating module, with a component called the 
<a href="https://github.com/aurelia/templating/blob/master/src/view-compiler.js" target="_blank">ViewCompiler</a>
. The ViewCompiler's job is to compile views into a <code>ViewFactory</code> which will be used to instantiate instances of your templates, called Views. Some view factories will be used to instantiate only one instance of a particular template. The ViewFactory that resulted from compiling your <code>app.html</code> template typically falls into this category. Other view factories for templates used with <code>repeat.for</code> may be used to instantiate tens, hundreds or even thousands of View instances.</p>
<p>A ViewFactory is comprised, among other things, of a template (a document fragment), a set of HTML behavior instructions (instructions for creating custom elements or custom attributes that appear in the template), binding expressions (factories for creating bindings that appear in the template), and dependencies (things you've <code>&lt;require from=&quot;...&quot;&gt;</code>).</p>
<p>When Aurelia loads one of your HTML templates the markup is parsed by the browser into a document fragment. The document fragment is the browser's object representation of your HTML. It is a tree structure and all the node names and attribute names have been lower-cased by the browser's HTML parser (except for SVG elements). The ViewCompiler traverses each DOM node in the tree and checks whether the node's name matches the name of a custom element. For now we won't go into the details of what happens when a custom element is discovered because it doesn't really matter to the binding system whether an element is custom or built-in. In addition to checking for custom elements, the ViewCompiler asks the BindingLanguage implementation to examine each node's attributes and content. The 
<a href="https://github.com/aurelia/templating-binding/blob/master/src/binding-language.js" target="_blank">standard BindingLanguage implementation</a>
 that ships with Aurelia looks for attributes whose name ends with <code>.bind</code>, <code>.to-view</code>, <code>.delegate</code>, <code>.trigger</code> or starts with <code>ref</code>, etc. These attribute postfixes and prefixes are known as &quot;binding commands&quot;. The standard BindingLanguage also checks the element's content for string interpolation expressions. When a binding command or string interpolation is discovered, the attribute's value (text) or interpolation's content (also text) is sent to the binding system's 
<a href="https://github.com/aurelia/binding/blob/master/src/parser.js" target="_blank">Parser</a>
. If you've written your binding expression correctly the parser will be able to tokenize the text (split it into a series of interesting parts) and convert the tokens to an abstract syntax tree (AST). The AST is the object representation of your JavaScript binding expression. We'll dive into the AST in a minute. What is important to understand now is that by this point the ViewCompiler has gathered a whole bunch of information about each binding expression in your template. It knows the name of the DOM element, the name of the element's attribute you intend to bind to (if applicable), the binding command (<code>bind</code>/<code>trigger</code>/etc) and it has the AST representation of your JavaScript binding expression. All of these parts are used to construct a <code>BindingExpression</code> which is a factory for creating binding instances.</p>
<p>Once the ViewCompiler has completely traversed the document fragment it returns the <code>ViewFactory</code> instance, which will be cached until it is needed. Aurelia compiles templates on an as-needed basis so it is likely to be used soon after it is compiled. Orchestrating all the work described above and the steps to follow is the <code>CompositionEngine</code> in conjunction with a <code>Controller</code>, which are parts of the templating module. The CompositionEngine is a high level component that creates controllers and executes composition instructions. Composition instructions are the result of application bootstrapping, routing and the <code>&lt;compose&gt;</code> element. They tell Aurelia to compose a view with a view-model. The Controller is a little bit lower level. It &quot;owns&quot; a <code>View</code> and its corresponding view-model, and takes us through the <code>created</code>, <code>bind</code>, <code>attached</code>, <code>detached</code> and <code>unbind</code> composition lifecycle events that occur when composing a view and view-model, injecting the view into the DOM and later removing it when it is no longer needed. Let's go through these steps, one-by-one, focusing on what happens with respect to data-binding.</p>
<p>The ViewFactory's <code>create</code> method will be called to create a <code>View</code> instance. A View in this sense is a JavaScript class with methods for all of the composition lifecycle events. Creating a View involves several steps. First the ViewCompiler's document fragment is cloned to create the element that will ultimately be injected into the DOM and data-bound. This is the element that is given to your view-model's constructor when you use <code>@inject(Element)</code>. Next, the ViewCompiler will execute all its instructions: creating custom element instances, custom attribute instances, and binding instances.</p>
<p>Creating a binding instance is accomplished by invoking the <code>createBinding</code> method on each BindingExpression, passing in the specific DOM element, custom element or custom attribute that is relevant to the BindingExpression. The <code>createBinding</code> method uses the ObserverLocator to locate the appropriate property observer for the combination of DOM element and property. Property observers expose a <code>subscribe</code>, <code>unsubscribe</code>, <code>getValue</code> and <code>setValue</code> interface. Each property observer has a specific observation strategy tailored for certain types of objects or elements and their various properties. For example, if you were binding an input element's value attribute there is an observer implementation that will subscribe to the input's <code>change</code> and <code>input</code> DOM events. With the property observer in hand <code>createBinding</code> will instantiate a Binding instance, passing the property observer to the Binding's constructor. This observer is known as the Binding's <code>targetObserver</code>. A few other items are passed to the Binding's constructor: the DOM element, known as the binding's <code>target</code>, the attribute name, the binding mode (<code>to-view</code>/<code>two-way</code>/<code>one-time</code>) and last but not least, the BindingExpression's AST, which is known as the binding's <code>sourceExpression</code>.</p>
<p>Once the ViewFactory's <code>create</code> method has finished executing all the instructions and creating all the bindings it will instantiate the <code>View</code>, whose constructor will receive the DOM element, bindings, controllers, and a few other items. With the View created the Controller can execute the view's <code>bind</code> method, passing in the binding context and override context. The binding context and override context tuple is known as the <code>scope</code>- more on that in a minute...</p>
<p>The view's <code>bind</code> method loops through all of its binding instances and calls their <code>bind</code> method, passing in the binding context and override context. This is where the AST in the binding's <code>sourceExpression</code> becomes important. The abstract syntax tree is the heart of the binding system. It is the object representation of your binding's JavaScript expression. Each node in the tree is an implementation of a very binding-specific interface. There are about 20 different AST node types, each tailored to a particular type of JavaScript expression. The AST can be evaluated by calling the root AST node's <code>evaluate</code> method and passing in the <code>scope</code>. Each node in the AST knows how to evaluate its piece of the expression using the scope and the end result will be the value of the JavaScript expression. After the binding gets the model value by evaluating the <code>sourceExpression</code> it assigns this value to the view by calling the <code>targetObserver</code>'s <code>setValue</code> method. Next the binding will check its binding mode. If it is <code>one-time</code>, there is nothing left to do. If it is <code>to-view</code> or <code>two-way</code> the binding will use the AST's <code>connect</code> method to subscribe to changes in the view-model. Each node in the AST knows which view-model properties to observe and will use the ObserverLocator to create property observers to subscribe to property change events. Finally, if the binding mode is <code>two-way</code> the binding will call the <code>targetObserver</code>'s subscribe method.</p>
<p>At this point the view and view-model are data-bound. When changes occur in the model, the property observers created when the AST was <code>connect</code>ed will fire change events, triggering the binding to update the target by calling <code>targetObserver.setValue</code>. When changes occur in the view the property observer known as the <code>targetObserver</code> will trigger the binding to update the source by calling <code>sourceExpression.assign(scope, value)</code>. All that remains is for the Controller to <code>attach</code> the view to the DOM. Later, when the view is no longer needed it will be <code>detached</code> from the DOM and <code>unbind</code> will be invoked, unbinding all the views, which will unsubscribe all the property observers.</p>
</section>
<section><h2 id="abstract-syntax-tree">Abstract Syntax Tree</h2><p>The abstract syntax tree is a key part of the binding system, we've discussed how it is used but it is easier to understand if you can visualize it. Below is a demo where you can enter any binding expression and see the AST resulting from parsing the expression. Click on the buttons to view some example expressions we put together or enter your own.</p>
<au-demo heading="AST Demo">
  <source-code src="example/binding-how-it-works/ast/app.js"><pre class="language-javascript"><code></code></pre></source-code>
</au-demo>
</section>
<section><h2 id="binding-context-scope">Binding Context / Scope</h2><p>The &quot;scope&quot; in aurelia is made up of two objects: the <code>bindingContext</code> (almost always a view-model instance) and the <code>overrideContext</code> which can be thought of as an &quot;overlay&quot; of the bindingContext. Properties on the overrideContext &quot;override&quot; corresponding properties on the bindingContext. It is actually rare for there to be a property on the overrideContext that is &quot;hiding&quot; a property on the bindingContext beneath. Most of the time the overrideContext is storing extra contextual properties such as <code>$index</code>, <code>$first</code>, <code>$last</code>, <code>$odd</code>, <code>$even</code> in the case of the repeat, <code>$event</code> when event bindings are firing, etc. The other purpose of the overrideContext is to enable scope traversal. The overrideContext also has a reference to the parent overrideContext and to its corresponding bindingContext which enables the binding system to traverse the scope as-needed when it evaluates a binding expression. If you've been using Aurelia for a while you might remember needing to use <code>$parent</code> to access the outer scope. It is not needed anymore because the binding system knows how to traverse the scope (read: traverse the bindingContext/overrideContext hierarchy) automatically.</p>
<p>When are bindingContexts created? Not often. The repeat is the only thing that creates them on the fly. The rest of the time the bindingContext is the view-model instance you'd expect it to be. On the other hand, overrideContexts are created on an as-needed basis, typically when it is time to compose a view and view-model.
</compose></require></p>
</section>

  </article>
</section>
