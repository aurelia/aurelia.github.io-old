{"name":"Observable Properties","description":"Data-binding observable properties with Aurelia.","author":{"name":"Fabio Luz"},"links":{"static":"docs/binding/binding-observable-properties","html":"docs/binding/binding-observable-properties/index.html","fragment":"docs/binding/binding-observable-properties/index-fragment.html","self":"docs/binding/binding-observable-properties/index.json"},"content":"\n\n## Introduction\n\nHave you ever needed to perform an action when a property is changed? If you have, that's a great use of property observation.\n\nTo observe a property, you need to decorate it with the `@observable` decorator and define a method as the change handler. This method can receive 2 parameters: the new value and the old value. You can put any business logic inside this method.\n\nBy convention, the change handler is a method whose name is composed of the _property_name_ and the literal value 'Changed'. For example, if you decorate the property `color` with `@observable`, you have to define a method named `colorChanged()` to be the change handler. Here's an example of that:\n\n<code-listing heading=\"Observable Properties\">\n  <source-code lang=\"ES 2015\">\n    import { observable, decorators } from 'aurelia-framework';\n\n    export const App = decorators(\n      observable('color')\n    ).on(class {\n      color = 'blue';\n\n      colorChanged(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n    })\n  </source-code>\n  <source-code lang=\"ES 2016\">\n    import { observable } from 'aurelia-framework';\n\n    export class Car {\n      @observable color = 'blue';\n\n      colorChanged(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import { observable } from 'aurelia-framework';\n\n    export class Car {\n      @observable color = 'blue';\n\n      colorChanged(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n    }\n  </source-code>\n</code-listing>\n\n> Info\n> You do not have to check if `newValue` and `oldValue` are different. The change handler will not be called if you assign a value that the property already has.\n\nIf you do not want to use the convention, you can define the callback name for the change handler by setting the `changeHandler` property of the `@observable` decorator:\n\n<code-listing heading=\"Observable Properties\">\n  <source-code lang=\"ES 2015\">\n    import { observable, decorators } from 'aurelia-framework';\n\n    export const Car = decorators(\n      observable({ name: 'color', changeHandler: 'myChangeHandler' })\n    ).on(class {\n      color = 'blue';\n\n      myChangeHandler(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n    })\n  </source-code>\n  <source-code lang=\"ES 2016\">\n    import { observable } from 'aurelia-framework';\n\n    export class Car {\n      @observable({ changeHandler: 'myChangeHandler' })\n      color = 'blue';\n\n      myChangeHandler(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import { observable } from 'aurelia-framework';\n\n    export class Car {\n      @observable({ changeHandler: 'myChangeHandler' })\n      color = 'blue';\n\n      myChangeHandler(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n    }\n  </source-code>\n</code-listing>\n\nIf you prefer, can also put the `@observable` on classes:\n\n<code-listing heading=\"Observable Properties\">\n  <source-code lang=\"ES 2015\">\n    import { observable, decorators } from 'aurelia-framework';\n\n    export const App = decorators(\n      observable('color'),\n      observable({ name: 'speed', changeHandler: 'speedChangeHandler' })\n    ).on(class {\n      color = 'blue';\n      speed = 300;\n\n      colorChanged(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n\n      speedChangeHandler(newValue, oldValue) {\n        // this will fire whenever the 'speed' property changes\n      }\n    })\n  </source-code>\n  <source-code lang=\"ES 2016\">\n    import { observable } from 'aurelia-framework';\n\n    @observable('color')\n    @observable({ name: 'speed', changeHandler: 'speedChangeHandler' })\n    export class Car {\n      color = 'blue';\n      speed = 300;\n\n      colorChanged(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n\n      speedChangeHandler(newValue, oldValue) {\n        // this will fire whenever the 'speed' property changes\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import { observable } from 'aurelia-framework';\n\n    @observable('color')\n    @observable({ name: 'speed', changeHandler: 'speedChangeHandler' })\n    export class Car {\n\n      color = 'blue';\n      speed = 300;\n\n      colorChanged(newValue, oldValue) {\n        // this will fire whenever the 'color' property changes\n      }\n\n      speedChangeHandler(newValue, oldValue) {\n        // this will fire whenever the 'speed' property changes\n      }\n    }\n  </source-code>\n</code-listing>  \n\n> Info\n> The `@observable` _only_ tracks changes to the value of a property, _not_ changes _in_ the value itself. This means that if the property is an array, the change handler will not fire when adding, removing or editing items.\n"}