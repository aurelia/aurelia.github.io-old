{"name":"CLI + built-in Bundler Advanced","description":"Advanced Usage of the CLI built-in Bundler.","author":{"name":"Chunpeng Huo","url":"https://github.com/huochunpeng"},"featured":false,"links":{"static":"docs/cli/cli-bundler/advanced","html":"docs/cli/cli-bundler/advanced/index.html","fragment":"docs/cli/cli-bundler/advanced/index-fragment.html","self":"docs/cli/cli-bundler/advanced/index.json"},"content":"\n\n## Introduction\n\nThis page covers advanced usage of CLI built-in bundler. Thanks for the runtime capability of RequireJS and SystemJS, apps built with CLI bundler are very flexible at runtime.\n\n## onRequiringModule\n\nonRequiringModule is an API to customize CLI bundler's behavior on module tracing. Use this API in in `aurelia_project/tasks/build.js` (or `build.ts`).\n\n```JavaScript\nfunction writeBundles() {\n  return buildCLI.dest({\n    onRequiringModule: function(moduleId) {\n      //...\n    }\n  });\n}\n```\n\nThis optional callback is called before auto-tracing any moduleId (including auto-stubbing core Node.js modules).\nIt would not be called for any modules provided by app's src files or explicit\ndependencies config in aurelia.json.\n\nYou can return three types of result (all can be returned in promise):\n1. Boolean `false`: ignore this moduleId;\n2. Array of strings like `['a', 'b']`: ignore this moduleId, but require module id \"a\" and \"b\" instead;\n3. A string: the full JavaScript content of this module, must be in AMD format;\n4. All other returns are ignored and go onto performing auto-tracing.\n\nHere are examples of use cases:\n\n### 1. ignore certain moduleId at bundling time, supply it at runtime\n\nTo build a multi-tenancy app, you can ignore moduleId \"client-info\" at bundling time, then fills it up at runtime.\n\nFirst, calm CLI bundler down on missing module.\n\n```JavaScript\nfunction writeBundles() {\n  return buildCLI.dest({\n    onRequiringModule: function(moduleId) {\n      // 1. Boolean `false`: ignore this moduleId;\n      if (moduleId === 'client-info') return false;\n    }\n  });\n}\n```\n\nIf you use TypeScript, add a `ts-ignore` to calm TypeScript compiler down.\n\n```TypeScript\n// @ts-ignore TS2307\nimport * as clientInfo from 'client-info';\n```\n\nSecond, add a path in `aurelia_project/aurelia.json` to point it to runtime location you will supply it.\n\n```JSON\n\"paths\": {\n  \"root\": \"src\",\n  \"resources\": \"resources\",\n  \"elements\": \"resources/elements\",\n  \"attributes\": \"resources/attributes\",\n  \"valueConverters\": \"resources/value-converters\",\n  \"bindingBehaviors\": \"resources/binding-behaviors\",\n  \"client-info\": \"../customize/client-info\"\n}\n```\n\nNote `\"../customize/client-info\"` is relative to `\"root\": \"src\"`, it will resolve to `https://hostname/customize/client-info.js` at runtime when RequireJS loads the missing module. You need to make sure you supply an AMD or UMD format JavaScript file at that location. Technically it should be an anonymous AMD module, not named AMD module.\n\n> Warning: No CommonJS and Native ES Module at runtime for RequireJS\n> CommonJS and Native ES Module are not supported at runtime, they are only acceptable at bundling time.\n\n> Warning: Native ES Module at runtime for SystemJS\n> Native ES Module is not supported at runtime. But SystemJS supports it with extra transpiler config, we would not go into details here.\n\nFor local dev, you can have a local `customize/client-info.js` something like this:\n\n```JavaScript\ndefine(function() {return \"client-info\";});\n```\n\nNote SystemJS is different, the above path `\"client-info\": \"../customize/client-info\"` doesn't work for SystemJS at runtime. For SystemJS, you need to:\n1. change the import line to `import * as clientInfo from 'client-info.js';` with `.js` extension.\n2. supply the runtime module at `https://hostname/client-info.js`\n\n### 2. bundling depedencies for missing module\n\nThis is a companion feature to support the previous use case. For instance, your runtime `client-info` module uses lodash, but your main app doesn't use lodash. We want to bundle lodash in our app.\n\nExample of `client-info` module code.\n\n```JavaScript\ndefine(['lodash'], function(_) {return _.camelCase(\"client-info\");});\n```\n\nBring lodash in.\n\n```JavaScript\nfunction writeBundles() {\n  return buildCLI.dest({\n    onRequiringModule: function(moduleId) {\n       // 2. Array of strings like `['a', 'b']`: require module id \"a\" and \"b\" instead;\n       if (moduleId === 'client-info') return ['lodash'];\n    }\n  });\n}\n```\n\nNote the above is not the only way to achieve the outcome. You can also do:\n\n```JavaScript\nonRequiringModule: function(moduleId) {\n  // 1. Boolean `false`: ignore this moduleId;\n  if (moduleId === 'client-info') return false;\n}\n```\n\nPlus\n\n```JSON aurelia_project/aurelia.json\n\"bundles\": [\n  // ...\n  {\n    \"name\": \"vendor-bundle.js\",\n    \"prepend\": [ /* ... */ ],\n    \"dependencies\": [\n      // ...\n      // force bundling lodash\n      \"lodash\"\n    ]\n  }\n]\n```\n\n### 3. supply module implementation directly\n\nIn previous chapter \"Dependency Management\", we said\n\n> With jquery in prepend, please don't `import $ from 'jquery'` in any code. Otherwise, auto tracing will bring jquery npm package into bundler again, causes duplicated jquery loading (one prepend before `require.js`, one npm package after `require.js`).\n\nHere is how you can still allow `import $ from 'jquery'`.\n\n```JavaScript\nonRequiringModule: function(moduleId) {\n  // 3. A string: the full JavaScript content of this module, must be in AMD format;\n  // just return global jQuery object\n  if (moduleId === 'jquery') return `define(function() {return window.jQuery});`;\n}\n```\n\nThis trick is particularly useful if you want to test your source code in Node.js env (where you want to load npm package jquery), and run your app in browser with jquery prepended.\n\n## Global wrapShim\n\nIn previous chapter \"Dependency Management\", we showed `wrapShim` per shim. You can also set it globally.\n\n```JSON aurelia_project/aurelia.json\n\"build\": {\n  \"loader\": {\n    \"type\": \"require\",\n    \"configTarget\": \"vendor-bundle.js\",\n    \"includeBundleMetadataInConfig\": \"auto\",\n    \"config\": {\n      \"wrapShim\": true\n    }\n  }\n}\n```\n\n`wrapShim` wraps shimmed legacy code in a function. This will delay the execution of the legacy code to module loading time.\n\n## Npm package alias\n\nIn dependency config, there are two more fields you can play with:\n\n* `path` - This is a path to the folder where the package's source is located. This path is relative to your application's `src` folder.\n* `main` - This is the main module (entry point) of the package, relative to the `path`. It works with or without `.js` file extension.\n\nFor instance, monaco-languageclient wants to use a patched version of vscode. You can alias vscode like this:\n\n```JSON\n{\n  \"name\": \"vscode\",\n  \"path\": \"../node_modules/monaco-languageclient/lib\",\n  \"main\": \"vscode-compatibility\"\n}\n```\n\n## Local copy of npm package\n\nSimilar to the above example, you can do:\n\n```JSON\n{\n  \"name\": \"my-awesome-package\",\n  \"path\": \"../my-awesome-package\",\n  // main field is optional, as long as you have a package.json in\n  // my-awesome-package folder, CLI bundler can read it and find main file\n  \"main\": \"index\"\n}\n```\n\nIf it is a single-file package, you can merge path and main:\n\n```JSON\n{\n  \"name\": \"my-awesome-package\",\n  \"path\": \"../my-awesome-package/the-entry-file.js\"\n}\n```\n\nThis short-cut can also be used in npm package alias.\n\n## Lazy bundling of main file\n\nThe default behavior on npm package main file:\n\n* lazy loading for any package without explicit config.\n* eager loading for package with explicit config. This design suggests you only use explicit config on lib that is not explicitly required by your code (directly or indirectly).\n* you can use `\"lazyMain\": true` in explicit config to force lazy loading.\n\nFor example, you have a local copy of lodash, but don't want to pack main file (the main file imports all lodash features).\n\n```JSON\n{\n  \"name\": \"lodash\",\n  \"path\": \"../lodash\",\n  // you can let CLI bundler to find main file in package.json\n  // or explicitly name main file\n  // \"main\": \"lodash\"\n  \"lazyMain\": true\n}\n```\n\nWith lazyMain setup, if you only use `import map from 'lodash/map';`, only `loash/map.js` will be bundled.\n\nlazyMain would not prevent bundling the main file when you use `import _ from 'lodash';`, it only ensures not bundling it blindly.\n"}