{"name":"App Config and Startup","description":"In this article you'll learn the various ways to bootstrap and configure Aurelia, along with different mechanisms for controlling the initial render strategy.","author":{"name":"Rob Eisenberg","url":"http://robeisenberg.com"},"links":{"static":"docs/fundamentals/app-configuration-and-startup","html":"docs/fundamentals/app-configuration-and-startup/index.html","fragment":"docs/fundamentals/app-configuration-and-startup/index-fragment.html","self":"docs/fundamentals/app-configuration-and-startup/index.json"},"content":"\n## Bootstrapping Aurelia\n\nMost platforms have a \"main\" or entry point for code execution. Aurelia is no different. If you've read the Quick Start, then you've seen the `aurelia-app` attribute. Simply place this on an HTML element and Aurelia's bootstrapper will load an _app${context.language.fileExtension}_ and _app.html_, databind them together and inject them into the DOM element on which you placed that attribute.\n\nOften times you want to configure the framework or run some code prior to displaying anything to the user though. So chances are, as your project progresses, you will migrate towards needing some startup configuration. In order to do this, you can provide a value for the `aurelia-app` attribute that points to a configuration module. This module should export a single function named `configure`. Aurelia invokes your `configure` function, passing it the Aurelia object which you can then use to configure the framework yourself and decide what, when, and where to display your UI. Here's an example configuration file showing the standard configuration, the same configuration that is equivalent to what you would get when using `aurelia-app` without a value:\n\n<code-listing heading=\"Standard Configuration\">\n  <source-code lang=\"ES 2015/2016\">\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nSo, if you want to keep all the default settings, it's really easy. Just call `standardConfiguration()` to configure the standard set of plugins. Then call `developmentLogging()` to turn on logging in debug mode, output to the `console`.\n\nThe `use` property on the `aurelia` instance is an instance of `FrameworkConfiguration`. It has many helper methods for configuring Aurelia. For example, if you wanted to manually configure all the standard plugins without using the `standardConfiguration()` helper method to do so and you wanted to configure logging without using the helper method for that, this is how you would utilize the `FrameworkConfiguration` instance:\n\n<code-listing heading=\"Manual Configuration\">\n  <source-code lang=\"ES 2015/2016\">\n    import {LogManager} from 'aurelia-framework';\n    import {ConsoleAppender} from 'aurelia-logging-console';\n\n    LogManager.addAppender(new ConsoleAppender());\n    LogManager.setLevel(LogManager.logLevel.debug);\n\n    export function configure(aurelia) {\n      aurelia.use\n        .defaultBindingLanguage()\n        .defaultResources()\n        .history()\n        .router()\n        .eventAggregator();\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia, LogManager} from 'aurelia-framework';\n    import {ConsoleAppender} from 'aurelia-logging-console';\n\n    LogManager.addAppender(new ConsoleAppender());\n    LogManager.setLevel(LogManager.logLevel.debug);\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .defaultBindingLanguage()\n        .defaultResources()\n        .history()\n        .router()\n        .eventAggregator();\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nYou can see that this code configures the default data-binding language (.bind, .trigger, etc.), the default set of view resources (repeat, if, compose, etc.) the history module (integration with the browser's history API), the router (mapping routes to components) and the event aggregator (app-wide pub/sub messaging). If, for example, you were building an app that didn't need to use the router or event aggregator, but did want debug logging, you could do that very easily with this configuration:\n\n<code-listing heading=\"Minimal Configuration\">\n  <source-code lang=\"ES 2015/2016\">\n    export function configure(aurelia) {\n      aurelia.use\n        .defaultBindingLanguage()\n        .defaultResources()\n        .developmentLogging();\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .defaultBindingLanguage()\n        .defaultResources()\n        .developmentLogging();\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nOnce you've configured the framework, you need to start things up by calling `aurelia.start()`. This API returns a promise. Once it's resolved, the framework is ready, including all plugins, and it is now safe to interact with the services and begin rendering.\n\n## Rendering the Root Component\n\nThe root component is set by calling `aurelia.setRoot()`. If no values are provided, this defaults to treating the element with the `aurelia-app` attribute as the DOM host for your app and `app${context.language.fileExtension}`/`app.html` as the source for the root component. However, you can specify whatever you want, just like this:\n\n<code-listing heading=\"Manual Root Component\">\n  <source-code lang=\"ES 2015/2016\">\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      aurelia.start().then(() => aurelia.setRoot('my-root', document.getElementById('some-element'));\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      aurelia.start().then(() => aurelia.setRoot('my-root', document.getElementById('some-element'));\n    }\n  </source-code>\n</code-listing>\n\nThis causes the `my-root${context.language.fileExtension}`/`my-root.html` to be loaded as the root component and injected into the `some-element` HTML element.\n\n> Info\n> The content of the app host element, the one marked with `aurelia-app` or passed to `Aurelia.prototype.setRoot`, will be replaced when `Aurelia.prototype.setRoot` completes.\n\n> Warning: When using the `<body>` element as the app host, bear in mind that any content added prior to the completion of `Aurelia.prototype.setRoot` will be removed.\n\n## Bootstrapping Older Browsers\n\nAurelia was originally designed for Evergreen Browsers. This includes Chrome, Firefox, IE11 and Safari 8. However, we also support IE9 and above through the use of additional polyfills. To support these earlier browsers, you need the [requestAnimationFrame Polyfill](https://www.npmjs.com/package/raf) and the [MutationObserver polyfill](https://github.com/megawac/MutationObserver.js). Once you have installed these (via `npm install --save-dev raf mutationobserver-shim`), you'll need to adjust your code to load them before Aurelia is initialized.\n\nIn case you are using Webpack, create a file, e.g. `ie-polyfill.js`:\n\n<code-listing heading=\"Polyfill Configuration\">\n  <source-code lang=\"JavaScript\">\n    import 'mutationobserver-shim/MutationObserver'; // IE10 MutationObserver polyfill\n    import 'raf/polyfill'; // IE9 requestAnimationFrame polyfill\n  </source-code>\n</code-listing>\n\nAfter you have created the file, add it as the first file in your `aurelia-bootstrapper` bundle. You can find bundle configuration in the `webpack.config.js` file, something like:\n\n<code-listing heading=\"Polyfill Configuration\">\n  <source-code lang=\"JavaScript\">\n    entry: {\n      'app': ['./ie-polyfill', 'aurelia-bootstrapper'],\n  </source-code>\n</code-listing>\n\nIf you are using JSPM change your `index.html` startup code as follows:\n\n<code-listing heading=\"Polyfill Configuration\">\n  <source-code lang=\"HTML\">\n    <!doctype html>\n    <html>\n      <head>\n        <title>My App</title>\n      </head>\n      <body>\n        <script src=\"jspm_packages/system.js\"></script>\n        <script src=\"config.js\"></script>\n        <script>\n          SystemJS.import('raf/polyfill').then(function() {\n            return SystemJS.import('aurelia-polyfills');\n          }).then(function() {\n            return SystemJS.import('mutationobserver-shim/MutationObserver');\n          }).then(function() {\n            SystemJS.import('aurelia-bootstrapper');\n          });\n        </script>\n      </body>\n    </html>\n  </source-code>\n</code-listing>\n\n> Info: Module Loaders and Bundlers\n> The code in this article demonstrates loading via SystemJS. However, these techniques can be accomplished with other module loaders just as readily. Be sure to lookup the appropriate APIs for your chosen loader or bundler in order to translate these samples into the required code for your own app.\n\n> Warning: Promises in Edge\n> Currently, the Edge browser has a serious performance problem with its Promise implementation. This deficiency can greatly increase startup time of your app. If you are targeting the Edge browser, it is highly recommended that you use the [bluebird promise](http://bluebirdjs.com/docs/getting-started.html) library to replace Edge's native implementation. You can do this by simply referencing the library prior to loading other libraries.\n\n## Manual Bootstrapping\n\nSo far, we've been bootstrapping our app declaratively by using the `aurelia-app` attribute. That's not the only way though. You can manually bootstrap the framework as well. In case of JSPM, here's how you would change your HTML file to use manual bootstrapping:\n\n<code-listing heading=\"Manual Bootstrapping with JSPM\">\n  <source-code lang=\"HTML\">\n    <!doctype html>\n    <html>\n      <head>\n        <title>My App</title>\n      </head>\n      <body>\n        <script src=\"jspm_packages/system.js\"></script>\n        <script src=\"config.js\"></script>\n        <script>\n          SystemJS.import('aurelia-bootstrapper').then(bootstrapper => {\n            bootstrapper.bootstrap(function(aurelia) {\n              aurelia.use\n                .standardConfiguration()\n                .developmentLogging();\n\n              aurelia.start().then(() => aurelia.setRoot('app', document.body));\n            });\n          });\n        </script>\n      </body>\n    </html>\n  </source-code>\n</code-listing>\n\nIn case you use Webpack, you can replace the `aurelia-bootstrapper-webpack` package with the `./src/main` entry file in the `aurelia-bootstrapper` bundle defined inside of `webpack.config.js`, and call the bootstrapper manually:\n\n\n<code-listing heading=\"Manual Bootstrapping with Webpack\">\n  <source-code lang=\"ES 2015/2016\">\n    import {bootstrap} from 'aurelia-bootstrapper-webpack';\n\n    bootstrap(async aurelia => {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      await aurelia.start();\n      aurelia.setRoot('app', document.body);\n    });\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia} from 'aurelia-framework';\n    import {bootstrap} from 'aurelia-bootstrapper-webpack';\n\n    bootstrap(async (aurelia: Aurelia) => {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      await aurelia.start();\n      aurelia.setRoot('app', document.body);\n    });\n  </source-code>\n</code-listing>\n\nThe function you pass to the `bootstrap` method is the same as the `configure` function from the examples above.\n\n## Making Resources Global\n\nWhen you create a view in Aurelia, it is completely encapsulated. In the same way that you must `import` modules into an ES2015/TypeScript module, you must also import or `require` components into an Aurelia view. However, certain components are used so frequently across views that it can become very tedious to import them over and over again. To solve this problem, Aurelia lets you explicitly declare certain \"view resources\" as global. In fact, the configuration helper method `defaultResources()` mentioned above does just that. It takes the default set of view resources, such as `repeat`, `if`, `compose`, etc, and makes them globally usable in every view. You can do the same with your own components. Here's how we could make the `my-component` custom element, located in a _resources_ subfolder of your project, globally available in all views.\n\n<code-listing heading=\"Make a Component Global\">\n  <source-code lang=\"ES 2015/2016\">\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .globalResources('resources/my-component');\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .globalResources('resources/my-component');\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n</code-listing>\n\n## Organizing Your App with Features\n\nSometimes you have whole group of components or related functionality that collectively form a \"feature\". This \"feature\" may even be owned by a particular set of developers on your team. You want these developers to be able to manage the configuration and resources of their own feature, without interfering with the other parts of the app. For this scenario, Aurelia provides the \"feature\" feature.\n\nImagine, as above, that we have a `my-component` component. Imagine that that was then one of a dozen components that formed a logical feature in your app called `my-feature`. Rather than place the feature's configuration logic inside the app's configuration module, we can place the feature's configuration inside its own feature configuration module.\n\nTo create a \"feature\", simply create a folder in your app; in the case of our example: `my-feature`. Inside that folder, place all the components and other code that pertain to that feature. Finally, create an `index${context.language.fileExtension}` file at the root of the `my-feature` folder. The `index${context.language.fileExtension}` file should export a single `configure` function. Here's what our code might look like for our hypothetical `my-feature` feature:\n\n<code-listing heading=\"A Feature Module (index${context.language.fileExtension})\">\n  <source-code lang=\"ES 2015/2016\">\n    export function configure(config) {\n      config.globalResources(['./my-component', './my-component-2', 'my-component-3', 'etc.']);\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {FrameworkConfiguration} from 'aurelia-framework';\n\n    export function configure(config: FrameworkConfiguration): void {\n      config.globalResources(['./my-component', './my-component-2', 'my-component-3', 'etc.']);\n    }\n  </source-code>\n</code-listing>\n\nThe `configure` method receives an instance of the same `FrameworkConfiguration` object as the `aurelia.use` property. So, the feature can configure your app in any way it needs. An important note is that resources should be configured using paths relative to the `index${context.language.fileExtension}` itself.\n\nHow then do we turn this feature on in our app? Here's an app configuration file that shows:\n\n<code-listing heading=\"Using a Feature\">\n  <source-code lang=\"ES 2015/2016\">\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .feature('my-feature');\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .feature('my-feature');\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n</code-listing>\n\n## Installing Plugins\n\nSimilar to features, you can install 3rd party plugins. The main difference is that a \"feature\" is provided internally by your application, while a plugin is installed from a 3rd party source through your package manager.\n\nTo use a plugin, you first install the package. For example `jspm install my-plugin` would use jspm to install the `my-plugin` package. Once the package is installed, you must configure it in your application. Here's some code that shows how that works.\n\n<code-listing heading=\"Using a Plugin\">\n  <source-code lang=\"ES 2015/2016\">\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .plugin('my-plugin', pluginConfiguration);\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {Aurelia} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .plugin('my-plugin', pluginConfiguration);\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nSimply provide the same name used during installation, to the plugin API. Some plugins may require configuration (see the plugin's documentation for details). If so, pass the configuration object or configuration callback function as the second parameter of the `plugin` API.\n\n## Leveraging Progressive Enhancement\n\nSo far you've seen Aurelia replacing a portion of the DOM with a root component. However, that's not the only way to render with Aurelia. Aurelia can also progressively enhance existing HTML.\n\nImagine that you want to generate your home page on the server, including using your server-side templating engine to render out HTML. Perhaps you've got custom components you created with Aurelia, but you want to render the custom elements on the server with some content, in order to make things a bit more SEO friendly. Or perhaps you have an existing, traditional web app, that you want to incrementally start adding Aurelia to. When the HTML is rendered in the browser, you want to progressively enhance that HTML and \"bring it to life\" by activating all the Aurelia component's rich behavior.\n\nAll this is possible with Aurelia, using a single method call: `enhance`. Instead of using `aurelia-app` let's use manual bootstrapping for this example. To progressively enhance the entire `body` of your HTML page, you can do something like this (JSPM-based example):\n\n<code-listing heading=\"Progressive Enhancement\">\n  <source-code lang=\"HTML\">\n    <!doctype html>\n    <html>\n      <head>\n        <title>My App</title>\n      </head>\n      <body>\n        <my-component message=\"Enhance Me\"></my-component>\n\n        <script src=\"jspm_packages/system.js\"></script>\n        <script src=\"config.js\"></script>\n        <script>\n          SystemJS.import('aurelia-bootstrapper').then(bootstrapper => {\n            bootstrapper.bootstrap(function(aurelia){\n              aurelia.use\n                .defaultBindingLanguage()\n                .defaultResources()\n                .developmentLogging()\n                .globalResources('resources/my-component');\n\n              aurelia.start().then(() => aurelia.enhance());\n            });\n          });\n        </script>\n      </body>\n    </html>\n  </source-code>\n</code-listing>\n\nIt's important to note that, in order for `enhance` to identify components to enhance in your HTML page, you need to declare those components as global resources, as we have above with the `my-component` component.\n\nOptionally, you can provide an object instance to use as the data-binding context for the enhancement, or provide a specific part of the DOM to enhance. Here's an example that shows both (JSPM-based):\n\n<code-listing heading=\"Customized Progressive Enhancement\">\n  <source-code lang=\"HTML\">\n    <!doctype html>\n    <html>\n      <head>\n        <title>My App</title>\n      </head>\n      <body>\n        <my-component message.bind=\"message\"></my-component>\n\n        <script src=\"jspm_packages/system.js\"></script>\n        <script src=\"config.js\"></script>\n        <script>\n          SystemJS.import('aurelia-bootstrapper').then(bootstrapper => {\n            bootstrapper.bootstrap(function(aurelia){\n              aurelia.use\n                .defaultBindingLanguage()\n                .defaultResources()\n                .developmentLogging()\n                .globalResources('resources/my-component');\n\n              var viewModel = {\n                message: 'Enhanced'\n              };\n\n              aurelia.start().then(() => aurelia.enhance(viewModel, document.body));\n            });\n          });\n        </script>\n      </body>\n    </html>\n  </source-code>\n</code-listing>\n\nBut what if you need to enhance multiple elements on a page that do not have a direct parent/child relationship? For example, suppose you have an existing application written on a non-Aurelia framework that you need to refactor component by component.\n\nYou can't use the `aurelia.enhance` method multiple times because it was not designed for that. Instead you can use the templating engine's `enhance` method directly.\n\n<code-listing heading=\"Multiple Enhance HTML\">\n  <source-code lang=\"HTML\">\n    <!doctype html>\n    <html>\n      <head>\n        <title>My App</title>\n      </head>\n      <body>\n        <my-component message=\"Enhance Me\"></my-component>\n        <div class=\"42\">Some legacy code that you don't want to enhance</div>\n        <your-component message.bind=\"message\"></your-component>\n      </body>\n    </html>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Multiple Enhance Code\">\n  <source-code lang=\"ES 2015/2016\">\n    import {TemplatingEngine} from 'aurelia-framework';\n\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .globalResources('resources/my-component', 'resources/your-component');\n\n      aurelia.start().then(a => {\n        let templatingEngine = a.container.get(TemplatingEngine);\n\n        templatingEngine.enhance({\n          container: a.container,\n          element: document.querySelector('my-component'),\n          resources: a.resources\n        });\n\n        templatingEngine.enhance({\n          container: a.container,\n          element: document.querySelector('your-component'),\n          resources: a.resources,\n          bindingContext: {\n            message: 'Enhance Me as well'\n          }\n        });\n\n      });\n    }\n  </source-code>\n</code-listing>\n\n## Customizing Conventions\n\nThere are many things you may want to customize or configure as part of your application's bootstrap process. Once you have your main `configure` method in place and `aurelia-app` is pointing to that module, you can do just about anything you want. One of the most common aspects of Aurelia that developers may want to customize, is its conventions.\n\n\n### Configuring the View Location Convention\n\nAurelia uses a _View Strategy_ to locate the view that is associated with a particular component's view-model. If the component doesn't specify its own view strategy, then Aurelia's `ViewLocator` service will use a fallback view strategy. The fallback strategy that is used is named `ConventionalViewStrategy`. This strategy uses the view-model's module id to conventionally map to its view id. For example, if the module id is \"welcome${context.language.fileExtension}\" then this strategy will look for the view at \"welcome.html\". The conventional strategy's mapping logic can be changed if a different convention is desired. To do this, during bootstrap, import the `ViewLocator` and replace its `convertOriginToViewUrl` method with your own implementation. Here's some example code:\n\n<code-listing heading=\"Custom View Location Convention\">\n  <source-code lang=\"ES 2015/2016\">\n    import {ViewLocator} from 'aurelia-framework';\n\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      ViewLocator.prototype.convertOriginToViewUrl = (origin) => {\n        let moduleId = origin.moduleId;\n        ...\n        return \"view.html\";\n      };\n\n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {ViewLocator, Aurelia, Origin} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      ViewLocator.prototype.convertOriginToViewUrl = (origin: Origin): string => {\n        let moduleId = origin.moduleId;\n        ...\n        return \"view.html\";\n      };\n\n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nIn this example, you would simply replace \"...\" with your own mapping logic and return the resulting view path that was desired.\n\nIf you're using Webpack with a HTML templating engine such as Jade, you'd have to configure Aurelia to look for the `.jade` extension instead of `.html`. This is due to Webpack keeping the original sourcemaps and lets loader plugins take care of transpiling the source. Here's the code to configure Aurelias' `ViewLocator` for Jade:\n\n<code-listing heading=\"Custom Jade View Location\">\n  <source-code lang=\"ES 2015/2016\">\n    import {ViewLocator} from 'aurelia-framework';\n\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      ViewLocator.prototype.convertOriginToViewUrl = (origin) => {\n        let moduleId = origin.moduleId;\n        let id = (moduleId.endsWith('.js') || moduleId.endsWith('.ts')) ? moduleId.substring(0, moduleId.length - 3) : moduleId;\n        return id + '.jade';\n      };\n\n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {ViewLocator, Aurelia, Origin} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      ViewLocator.prototype.convertOriginToViewUrl = (origin: Origin): string => {\n        let moduleId = origin.moduleId;\n        let id = (moduleId.endsWith('.js') || moduleId.endsWith('.ts')) ? moduleId.substring(0, moduleId.length - 3) : moduleId;\n        return id + '.jade';\n      };\n\n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n</code-listing>\n\n### Configuring the Fallback View Location Strategy\n\nIn addition to customizing the mapping logic of the `ConventionalViewStrategy` you can also replace the entire fallback view strategy. To do this, replace the `createFallbackViewStrategy` of the `ViewLocator` with your own implementation. Here's some sample code for that:\n\n<code-listing heading=\"Custom View Fallback\">\n  <source-code lang=\"ES 2015/2016\">\n    import {ViewLocator} from 'aurelia-framework';\n\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      ViewLocator.prototype.createFallbackViewStrategy = (origin) => {\n        return new CustomViewStrategy(origin);\n      };\n\n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {ViewLocator, Aurelia, Origin} from 'aurelia-framework';\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging();\n\n      ViewLocator.prototype.createFallbackViewStrategy = (origin: Origin) => {\n        return new CustomViewStrategy(origin);\n      };\n\n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n</code-listing>\n\n## Logging\n\nAurelia has a simple logging abstraction that the framework itself uses. By default it is a no-op. The configuration in the above examples shows how to install an appender which will take the log data and output it to the console. Here's the code again, for convenience:\n\n<code-listing heading=\"Configuring Logging\">\n  <source-code lang=\"ES 2015/2016\">\n    import {LogManager} from 'aurelia-framework';\n    import {ConsoleAppender} from 'aurelia-logging-console';\n\n    LogManager.addAppender(new ConsoleAppender());\n    LogManager.setLevel(LogManager.logLevel.debug);\n\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration;\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {LogManager, Aurelia} from 'aurelia-framework';\n    import {ConsoleAppender} from 'aurelia-logging-console';\n\n    LogManager.addAppender(new ConsoleAppender());\n    LogManager.setLevel(LogManager.logLevel.debug);\n\n    export function configure(aurelia: Aurelia): void {\n      aurelia.use\n        .standardConfiguration;\n\n      aurelia.start().then(() => aurelia.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nYou can also see how to set the log level. Values for the `logLevel` include: `none`, `error`, `warn`, `info` and `debug`.\n\nThe above example uses our provided `ConsoleAppender`, but you can easily create your own appenders. Simply implement a class that matches the `Appender` interface from the logging library.\n"}