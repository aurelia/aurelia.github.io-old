{"name":"Custom Attributes","description":"An overview of the Aurelia templating engine's custom attribute functionality. Custom Attributes are used to add custom behaviors to DOM elements.","author":{"name":"Ashley Grant","url":"http://www.ashleygrant.com"},"keywords":["JavaScript","Templating","Custom Attributes"],"contributors":[],"translators":[],"links":{"static":"docs/templating/custom-attributes","html":"docs/templating/custom-attributes/index.html","fragment":"docs/templating/custom-attributes/index-fragment.html","self":"docs/templating/custom-attributes/index.json"},"content":"\n## [Introduction](aurelia-doc://section/1/version/1.0.0)\n\nCustom attributes are a category of view resource, just like value converters, binding behaviors and custom elements.  Custom attributes provide the ability to alter the behavior or add functionality to any DOM element.\n\nCustom attributes may work by simply being added to a DOM element, or they may require that a value be set for the attribute. The value may be a simple value, or a complex set of options. These options may or may not be known when a custom attribute is developed. Aurelia provides simple APIs to create custom attributes of all of these types, while the Aurelia templating engine provides strong databinding capabilities for custom attributes.\n\nMany custom attributes will work directly on the DOM element they are attached to. It is not necessary to search the DOM for the element a custom attribute is attached to. This is accomplished simply by requesting the element be injected into the attribute by Aurelia's Dependency Injection system. Simply request for an object of type `Element` to be injected in to your attribute. Aurelia will ensure you are provided with the DOM element the attribute has been attached to.\n\n## [Simple Custom Attribute](aurelia-doc://section/2/version/1.0.0)\n\nThe simplest custom attribute to create is one that changes the behavior of an element merely by being added to the element. The following attribute will make an HTML element be displayed as a 100 pixel square with a red background.\n\n<code-listing heading=\"red-square${context.language.fileExtension}\">\n  <source-code lang=\"ES 2015/2016\">\n    export class RedSquareCustomAttribute {\n      static inject = [Element];\n\n      constructor(element){\n        this.element = element;\n        this.element.style.width = this.element.style.height = '100px';\n        this.element.style.backgroundColor = 'red';\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {autoinject} from 'aurelia-framework';\n\n    @autoinject\n    export class RedSquareCustomAttribute {\n      constructor(private element: Element){\n          this.element.style.width = this.element.style.height = '100px';\n          this.element.style.backgroundColor = 'red';\n      }\n    }\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"simple-attribute-usage.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"./red-square\"></require>\n      <div red-square></div>\n    </template>\n  </source-code>\n</code-listing>\n\nThe attribute name is inferred via an Aurelia convention. This convention is `\\${Name}CustomAttribute` for the ECMAScript class name. The class name is in \"init caps\" format. Aurelia converts this to \"dash-case\" format for use in HTML. Thus, `RedSquareCustomAttribute` becomes `red-square`.\n\n## [Explicit Attribute Naming](aurelia-doc://section/3/version/1.0.0)\n\nOverriding the default naming convention is possible by utilizing the `@customAttribute` decorator. Provide this decorator with the exact name for your attribute as below. Note that Aurelia does not convert from \"init caps\" to \"dash-case\" when using this decorator. It uses the exact value passed to the decorator.\n\n<code-listing heading=\"red-square${context.language.fileExtension}\">\n  <source-code lang=\"ES 2015/ES 2016/TypeScript\">\n    import {customAttribute} from 'aurelia-framework';\n\n    @customAttribute('red-square')\n    export class MyClass {\n      // implement custom element here\n    }\n  </source-code>\n</code-listing>\n\n\n## [Single Value Binding](aurelia-doc://section/4/version/1.0.0)\n\nAurelia custom attributes support three different types of binding: single value binding, options binding, and dynamic options binding. The simplest of the three binding types is single value binding. Aurelia will automatically set the `value` property on the attribute's view-model. Note that this property is not set until databinding is complete. This means the `value` property will not be set in the custom attribute's constructor or in its `created` lifecycle event. It is available in the `bind` and later lifecycle events.\n\n<code-listing heading=\"square${context.language.fileExtension}\">\n  <source-code lang=\"ES 2015/2016\">\n    export class SquareCustomAttribute {\n      static inject = [Element];\n\n      constructor(element){\n        this.element = element;\n        this.element.style.width = this.element.style.height = '100px';\n      }\n\n      bind() {\n        this.element.style.backgroundColor = this.value;\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {autoinject} from 'aurelia-framework';\n\n    @autoinject\n    export class SquareCustomAttribute {\n      constructor(private element: Element){\n        this.element.style.width = this.element.style.height = '100px';\n      }\n\n      bind() {\n        this.element.style.backgroundColor = this.value;\n      }\n    }\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Simple Attribute with Value Usage\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"./square\"></require>\n\n      <div square=\"red\"></div>\n      <div square=\"${color}\"></div>\n      <div square.bind=\"color\"></div>\n    </template>\n  </source-code>\n</code-listing>\n\n\nNote that in the above code sample, the color of the square will not be updated, even if the bound value is changed. This is because the attribute is not notified when the `value` property changes. Aurelia can notify a custom attribute when its value has changed, via the `valueChanged(newValue, oldValue)` callback function. The `valueChanged` callback function, if implemented on the view-model, will be called whenever the attribute's value changes. This function has two optional parameters, `newValue` and `oldValue`. These parameters will be set to the new value of the attribute and old value of the attribute, respectively. The `value` property is still set by Aurelia even if the `valueChanged` function is implemented. Note that if you implement both the `bind` and `valueChanged` callbacks, only `bind` will be called when the value is initially bound. If you implement only the `valueChanged` function, then it will be called when the value is initially bound.\n\n<code-listing heading=\"square${context.language.fileExtension}\">\n  <source-code lang=\"ES 2015/2016\">\n    export class SquareCustomAttribute {\n      static inject = [Element];\n\n      constructor(element){\n        this.element = element;\n        this.element.style.width = this.element.style.height = '100px';\n      }\n\n      valueChanged(newValue, oldValue){\n        this.element.style.backgroundColor = newValue;\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {autoinject} from 'aurelia-framework';\n\n    @autoinject\n    export class SquareCustomAttribute {\n      constructor(private element: Element){\n        this.element.style.width = this.element.style.height = '100px';\n      }\n\n      valueChanged(newValue: string, oldValue: string){\n        this.element.style.backgroundColor = newValue;\n      }\n    }\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Simple Attribute with Value Usage\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"./square\"></require>\n\n      <div square=\"red\"></div>\n      <div square=\"${color}\"></div>\n      <div square.bind=\"color\"></div>\n\n      <input type=\"text\" value.bind=\"color\" />\n    </template>\n  </source-code>\n</code-listing>\n\nWhen the user updates the value of the `color` property via the textbox, Aurelia will call the `valueChanged` method on the custom attribute to alert the custom attribute to the change.\n\n## [Options Binding](aurelia-doc://section/5/version/1.0.0)\n\nOptions binding provides a custom attribute the ability to have multiple bindable properties. Each bindable property must be specified using the `bindable` decorator. The attribute view-model may implement an optional `\\${propertyName}Changed(newValue, oldValue)` callback function for each bindable property. When binding to these options, separate each option with a semicolon and supply a binding command or literal value as in the example below. It is important to note that bindable properties are converted to dash-case when used in the DOM, while the VM property they are bound to are kept with their original casing.\n\n<code-listing heading=\"square${context.language.fileExtension}\">\n  <source-code lang=\"ES 2015/2016\">\n    import {bindable, inject} from 'aurelia-framework';\n\n    @inject(Element)\n    export class SquareCustomAttribute {\n      @bindable sideLength;\n      @bindable color;\n\n      constructor(element){\n        this.element = element;\n      }\n\n      sideLengthChanged(newValue, oldValue){\n        this.element.style.width = this.element.style.height = `${newValue}px`;\n      }\n\n      colorChanged(newValue, oldValue){\n        this.element.style.backgroundColor = newValue;\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {bindable, autoinject} from 'aurelia-framework';\n\n    @autoinject\n    export class SquareCustomAttribute {\n      @bindable sideLength: string;\n      @bindable color: string;\n\n      constructor(private element: Element){\n      }\n\n      sideLengthChanged(newValue:string, oldValue:string){\n        this.element.style.width = this.element.style.height = `${newValue}px`;\n      }\n\n      colorChanged(newValue:string, oldValue:string){\n        this.element.style.backgroundColor = newValue;\n      }\n    }\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Options Binding Usage\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"./square\"></require>\n\n      <div square=\"color.bind: squareColor; side-length.bind: squareSize\"></div>\n    </template>\n  </source-code>\n</code-listing>\n\n## [Default Option](aurelia-doc://section/6/version/1.0.0)\n\nA single bindable property can be made the default among all the options in an options binding.  Thus, when you use a custom attribute that would otherwise require using the options HTML syntax, and you want to provide a value or binding only for the default property, then you can use the simpler HTML syntax of a single value binding. \n\nWith options bindings each bindable property must be decorated with the `bindable` decorator.  To specify that you want a bindable property to be the default among all the other bindable properties, use the `primaryProperty` configuration parameter of the `bindable` decorator, as shown below:\n\n<code-listing heading=\"square${context.language.fileExtension}\">\n  <source-code lang=\"ES 2015/2016\">\n    import {bindable, inject} from 'aurelia-framework';\n\n    @inject(Element)\n    export class SquareCustomAttribute {\n      @bindable sideLength;\n      @bindable({ primaryProperty: true }) color;\n\n      constructor(element){\n        this.element = element;\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {bindable, autoinject} from 'aurelia-framework';\n\n    @autoinject\n    export class SquareCustomAttribute {\n      @bindable sideLength: string;\n      @bindable({ primaryProperty: true }) color: string;\n\n      constructor(private element: Element){\n      }\n    }\n  </source-code>\n</code-listing>\n\nThen when you use the custom attribute, instead of this:\n\n<code-listing heading=\"Usage when Binding a Single Property using the Options Syntax\">\n  <source-code lang=\"HTML\">\n    <div square=\"color.bind: squareColor\"></div> \n </source-code>\n</code-listing>\n\nYou can do this:\n\n<code-listing heading=\"Usage with Simpler Binding Syntax on a Default Bindable Property\">\n  <source-code lang=\"HTML\">\n      <div square.bind=\"squareColor\"></div> \n</source-code>\n</code-listing>\n\nOr if you don't care about binding, then this:\n\n<code-listing heading=\"Usage with Simpler Syntax on a Default Bindable Property\">\n  <source-code lang=\"HTML\">\n      <div square=\"#123456\"></div> \n</source-code>\n</code-listing>\n\n## [Dynamic Options Binding](aurelia-doc://section/7/version/1.0.0)\n\nUtilizing dynamic options, a custom attribute may deal with bindable properties where the name of the property is not known when creating the attribute. Simply decorate the attribute's view-model with the `dynamicOptions` decorator and implement the `propertyChanged(name, newValue, oldValue)` callback function. Aurelia will provide the name of the option that has changed along with new and old values for the option. Binding to a dynamic options attribute works exactly the same as binding to an options attribute in the DOM.\n\n<code-listing heading=\"square${context.language.fileExtension}\">\n  <source-code lang=\"ES 2015/2016\">\n    import {dynamicOptions, inject} from 'aurelia-framework';\n\n    @dynamicOptions\n    @inject(Element)\n    export class SquareCustomAttribute {\n      constructor(element){\n        this.element = element;\n      }\n\n      propertyChanged(name, newValue, oldValue){\n        switch(name){\n          case 'fill':\n            this.element.style.backgroundColor = newValue;\n            break;\n          case 'size':\n            this.element.style.width = this.element.style.height = `${newValue}px`;\n            break;\n          default:\n            this.element.style[name] = newValue;\n            break;\n        }\n      }\n    }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n    import {dynamicOptions, autoinject} from 'aurelia-framework';\n\n    @dynamicOptions\n    @autoinject\n    export class RedSquareCustomAttribute {\n      constructor(private element: Element){\n      }\n\n      propertyChanged(name: string, newValue: string, oldValue: string){\n        switch(name){\n          case 'fill':\n            this.element.style.backgroundColor = newValue;\n            break;\n          case 'size':\n            this.element.style.width = this.element.style.height = `${newValue}px`;\n            break;\n          default:\n            this.element.style[name] = value;\n            break;\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"Single Value Binding Usage\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"./square\"></require>\n\n      <div square=\"fill.bind: squareColor; size: 100\"></div>\n    </template>\n  </source-code>\n</code-listing>\n\n## [Globally Accessible Custom Attributes](aurelia-doc://section/8/version/1.0.0)\n\nIn all of our examples, we've been using the `require` element to import custom attributes we need into our view.  There's an easier way.  If you have some commonly used custom attributes that you'd like to make globally available, use Aurelia's `globalResources` function to register them.  This will eliminate the need to `require` elements at the top of every view.\n\n"}