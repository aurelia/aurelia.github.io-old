{"articles":{"data":[{"articleName":"What is Aurelia?","articleHref":"docs/overview/what-is-aurelia","sectionName":"What is Aurelia?","sectionId":"what-is-aurelia","id":1567,"text":"Aurelia is a collection of Modern JavaScript modules, which when used together, function as a powerful platform for building browser, desktop and mobile applications, all open source and built on open web standards. Let's unpack this statement a little... A Collection of Modern JavaScript Modules Rather than being a monolithic framework, Aurelia is broken down into a collection of feature-oriented modules. Examples of feature modules include metadata, dependency injection, binding, templating, router and more. Each module is written using ECMAScript (aka JavaScript) or TypeScript (a strict superset of JavaScript that adds compile-time type checking). Many of these modules can be used individually in any type of JavaScript project, including Node.js. A Powerful Platform for Building Apps While Aurelia's modules can be used for many purposes, their true power lies in using them together as a front-end application platform. If your end goal is to create rich, engaging experiences for your customers, meeting or exceeding what is found in modern native applications, Aurelia provides the means. Through its rich component model, dynamic UI composition, routing and extensive set of plugins, Aurelia provides a comprehensive set of capabilities and tools to build any front-end experience you can dream up, whether you're targeting the browser, mobile or desktop. Open Source With all the power and capability that Aurelia offers, you might expect it to have an expensive licensing model or be closed source, but neither is true. Aurelia is free and its code is open sourced under the MIT License, a very permissive license used by many popular web projects today. Its starter kits and documentation are available under the Creative Commons 0 license. It also has a Contributor License Agreement (CLA) for those who wish to join the core team in working on Aurelia. Ultimately, this means that you can use Aurelia without fear of legal repercussions and we can build it in the same confidence. Built on Open Web Standards Not only is Aurelia written with ECMAScript, but it's also designed to make careful use of the DOM standard. Rather than Aurelia utilizing a costly abstraction over the DOM, implementing its own custom HTML parser or adopting framework-specific JavaScript extensions, it leverages the latest DOM APIs to get \"bare metal\" performance, exceptional memory efficiency and all while staying synced with the continuous improvements of the browser platform itself. Additionally, Aurelia's component model is based on W3C Web Components HTML Templates and ShadowDOM, so you know it will stand the test of time and will enable you to evolve your application along with advances in the standards, without major application re-writes or framework churn."},{"articleName":"What is Aurelia?","articleHref":"docs/overview/what-is-aurelia","sectionName":"Why choose Aurelia?","sectionId":"why-choose-aurelia","id":1568,"text":"There are many frameworks to choose from today. We believe that Aurelia provides a fresh and exciting approach to front-end development with power and flexibility that is unmatched by other options. That said, we recognize that each team and each project has different needs. You might find Aurelia to be the right choice for you if... You want an all-in-one solution - Aurelia provides core capabilities like dependency injection, templating, routing and pub/sub, so you don't have to piece together a bunch of libraries in order to build an application. On top of this rich core, Aurelia also provides a number of additional plugins for internationalization, validation, modal dialogs, UI virtualization and much more. You also don't have to cobble together a bunch of different tools. Aurelia provides a CLI for generating and building projects, a browser plugin for debugging and a VS Code plugin as well. Yet, you're not forced to use any of these as Aurelia is structured to enable you to swap out any detail, even down to the templating/binding engine, in order to guarantee maximum flexibility. You need blazing rendering speed and great memory efficiency - In 3rd-party benchmarks like DB Monster, Aurelia renders faster than any other framework today. Because of its batched rendering and observable object pooling, Aurelia also utilizes less memory and causes less GC churn than other frameworks. You require the safety of uni-directional data-flow, but need the productivity of data-binding - Aurelia features an observable-based binding system that uses uni-directional data-flow by default, pushing data from your model into your view via a highly efficient, DOM-batching mechanism. Two-way binding can also be leveraged for HTML form controls, allowing for increased developer productivity, without sacrificing the safety of uni-directional flow or that of component encapsulation. You desire API stability amidst a turbulent JavaScript landscape - Aurelia follows Semver and works hard not to make breaking changes to its APIs. We're proud to say that we've continued to innovate and advance the platform while having no breaking changes to core framework APIs since our 1.0 release on July 27, 2016. You value high standards compliance - Focused on ES2015+ and W3C Web Components while avoiding unnecessary abstractions, Aurelia provides the cleanest and most standards-compliant component model you'll find anywhere. You think a framework should \"get out of your way\" - Aurelia is the only framework that lets you build components with plain, vanilla JavaScript/TypeScript. The framework stays out of your way so your code remains clean and easy to evolve over time. You like programming models that are easy to learn and remember - Because of its simple, consistent design, developers are able to learn a very small set of Aurelia patterns and APIs while unlocking limitless possibilities. Simple conventions help developers follow solid patterns and reduce the amount of code they have to write and maintain. This all results in less fiddling with the framework and more focus on the application. You prefer a platform that integrates well with other frameworks and libraries - Because of the extensible design of Aurelia and its strict adherence to web standards, it's easy to integrate Aurelia with any 3rd party library or framework, including jQuery, React, Polymer, Bootstrap, MaterializeCSS and many more. You love or want to be a part of open source - Aurelia is open sourced under the MIT license and doesn't add or remove special clauses or conditions to the license. We're proud of the work our community has done together and we'd love you to join in and help us make Aurelia better for everyone. You thrive on being part of a welcoming community - With one of the largest and most active developer gitter channels, a huge number of contributors and a large, active core team, Aurelia has an amazing community. Our core team and community love to welcome new developers and we all work hard to help each other succeed."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Modern JavaScript","sectionId":"modern-javascript","id":1569,"text":"Fully written in standards-based ES2015+ and TypeScript. Forward compatible with JavaScript technology coming in future ECMAScript specs. Full support for both Babel and TypeScript."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Modern DOM","sectionId":"modern-dom","id":1570,"text":"Consistently leverages the most modern DOM APIs. Bare \"to the metal\" usage of the DOM; no DOM wrappers in order to ensure maximum performance and memory efficiency. Automatically polyfills the DOM where appropriate, in order to support older browsers."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Modern Tooling","sectionId":"modern-tooling","id":1571,"text":"Supports modern build tooling via the Aurelia CLI and Webpack, out-of-the-box. Works well with powerful testing tools like Karma and Protractor. Provides a custom Chrome debug panel as well as a VS Code plugin."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Code Quality","sectionId":"code-quality","id":1572,"text":"Source code is covered by an extensive suite of unit tests. All source is fully linted for style and feature-usage consistency throughout. TypeScript d.ts files and full API documentation are provided for all libraries."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Web Component Standards","sectionId":"web-component-standards","id":1573,"text":"Leverages W3C Web Components specs such as HTMLTemplateElement and ShadowDOM. Fully compatible with 3rd-party Web Components, even those originating from other frameworks, such as Polymer. Provides a Web Component-based programming model even on browsers that will never support Web Components."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Modularity","sectionId":"modularity","id":1574,"text":"Highly modular development, suitable for small and large-scale apps alike. Native support for feature-based development facilitating parallel development of multiple teams on the same app. Strong component model for high re-use of UI components across apps."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Platform Support","sectionId":"platform-support","id":1575,"text":"Designed for modern web browsers but supports older browsers, such as IE9, via additional polyfills. Designed for mobile application development in combination with PhoneGap/Cordova/Crosswalk. Designed for desktop application development in combination with Electron or NWJS."},{"articleName":"Technical Benefits","articleHref":"docs/overview/technical-benefits","sectionName":"Capabilities","sectionId":"capabilities","id":1576,"text":"Write apps in ES2015+ and TypeScript. One simple way of creating components that work in a variety of contexts: Custom Elements Dynamically Composed UI (data-driven component composition) Routing/Navigation Modal Dialogs Web Components Progressive Enhancement Custom scenarios enabled through low-level access to our View Composition Engine Fully-extensible View Compiler, View Engine and View Resource Pipeline. Fully-extensible and adaptive data-binding engine. Powerful and flexible hierarchical dependency injection. Eager/Lazy/Hybrid loading of any/all application resources. Powerful application router with support for encapsulated child routers for multi-team, large-scale development. Optionally create standards-compliant Web Components or use Aurelia to \"shield\" you from unstable specs. Interoperate with any standards-compliant Web Component. Loosely coupled cross-component communication via publish/subscribe. Fully customizable application startup and plugin model. Enables authoring of testable, maintainable and extensible code. Leverage conventions to write less code and get more done. Little to no framework intrusion, so developers can focus on their app, not the framework. Application and package bundling compatible with all major build systems."},{"articleName":"Business Advantages","articleHref":"docs/overview/business-advantages","sectionName":"Commercially Backed","sectionId":"commercially-backed","id":1577,"text":"Commercial support options available. Custom contracts available for enterprises. Internally \"dogfooded\" by Blue Spire Inc. in its own products."},{"articleName":"Business Advantages","articleHref":"docs/overview/business-advantages","sectionName":"Commercial Products and Services","sectionId":"commercial-products-and-services","id":1578,"text":"Official on-site or virtual training. Consulting, advisory, and code-review services. Aurelia UX (In Development) - Cross-platform, mobile UI components."},{"articleName":"Business Advantages","articleHref":"docs/overview/business-advantages","sectionName":"Strategic Partnerships","sectionId":"strategic-partnerships","id":1579,"text":"Partnerships with both large and boutique consulting organizations in order to provide scale-out of developer resources as needed by businesses adopting Aurelia. Official training partners around the world to deliver training anywhere and anytime."},{"articleName":"Business Advantages","articleHref":"docs/overview/business-advantages","sectionName":"Broad Customer Reach","sectionId":"broad-customer-reach","id":1580,"text":"Applications developed in virtually every space: healthcare, insurance, finance, entertainment, technology, developer tools, LOB, gaming, etc. Used internally at many well-known enterprises. Adoption among large, international organizations and governments as well as small and medium businesses."},{"articleName":"Creating a Todo App","articleHref":"docs/tutorials/creating-a-todo-app","sectionName":"Setup","sectionId":"setup","id":1581,"text":"Aurelia is an amazing framework that embraces simple and clean code without sacrificing power. In this tutorial we'll introduce you to the simplicity of Aurelia through the construction of a \"Todo\" application. You'll see just how clean and simple your application code can be and you'll learn several of the basic concepts and capabilities of Aurelia. Before we start writing some code, you'll need to get setup with a basic project structure. There are several ways to setup Aurelia, including using our command line tools, Webpack, Yeoman or our skeletons. However, to start you out, we're going to show you a basic script-tag setup that requires no additional tools or build systems. Please begin by downloading the basic script setup by clicking the button below. With this setup, you can choose between two popular programming language options: ESNext and TypeScript. If you would like to stay strictly with spec-compliant next-generation ECMAScript, you will want to go with the ESNext option. However, if you like strong typing and rich compile-time verification and tooling for your language, you'll want to go with TypeScript. Once you've made your language choice, you'll need to do two things: Configure this documentation to show all code samples in your preferred programming language. Configure your Aurelia project to use your preferred programming language. Let's configure this documentation first. If you scroll down a bit and look to the right of any source-code example, you will see a dropdown for selecting your preferred programming language. Click that and be sure to select the language that matches your choice. Now let's setup your project. First, unzip the downloaded files on your hard drive. Doing so will provide you with the default folder structure and scripts needed to complete this tutorial and continue your learning and experimentation afterward. You'll also want to open the folder in your favorite text editor so you can navigate between files, make edits and add new files. The first file we need to look at is the index.html. This is what kicks off our app and it's also where we configure your programming language selection. You should see something like this in your index.html: Before we explain what this does, let's adjust the programming language it's using. If you look at the second script tag, you will see its src pointing to scripts/config-typescript.js. This is the configuration for TypeScript. So, if you want to use TypeScript, you are all set and don't need to make any changes. If you want to use ESNext, you need to swap its src so that it points at scripts/config-esnext.js. That's it. Your language selection is now configured with these docs and with your new project."},{"articleName":"Creating a Todo App","articleHref":"docs/tutorials/creating-a-todo-app","sectionName":"The Index.html Page","sectionId":"the-indexhtml-page","id":1582,"text":"If you've followed along this far, you now have everything set up to help you learn Aurelia. Let's start by taking a look at the index.html file in a bit more depth. Yes, that's it. This is the only HTML page in our application. With this in place you can use Aurelia to create almost any type of application you can imagine. Let's look at each element of this file to see what's going on. First, you can see that this document is setup as a standard HTML5 document with a doctype, html, head and body. The items of interest to us lie within (and on) the body tag. Let's look at each script tag in turn: This tag is used to load SystemJS, a modern JavaScript module loader. Because Aurelia is a modern framework, it's written as modules and encourages you to create your code in a modular fashion. To use modules in ${context.language.name} you need a loader that understands modular code. That's what SystemJS does. It locates modules, understands their dependencies and ensures that everything is properly loaded at runtime. Aurelia supports a variety of module loaders. Besides SystemJS, Aurelia supports all AMD-based loaders such as RequireJS, Cajon and Dojo. Aurelia also supports module-based build systems like Webpack. As discussed previously, this line of code configures the programming language you want to use. It's actually a configuration file for the SystemJS module loader that installs a transpiler into the loader. As a result, each time a module is loaded, it's able to take your ESNext or TypeScript code and automatically convert it to ES5 code that today's browsers fully understand. Pretty cool right? Info In a production app, you wouldn't use a transpiler to transform code on-the-fly in the browser like we're doing here. That would perform quite poorly and require you to distribute an entire transpiler with your app. We're using this technique here to enable you to get started without any tooling or build setup needed. In a later guide, we'll show you how to use the CLI to setup a production-ready project, complete with automatic application builds and bundling. This is the core of Aurelia itself, in a single script file. You need to add that to use the framework. That's what's going to enable all the cool capabilities we'll use in this guide. The last script tag is a bit different. Instead of setting a src, it provides some code. The SystemJS object is being provided by the SystemJS module loader we mentioned above. Here, we're calling one of its APIs, import. This API tells the loader to load or \"import\" a module with the specified name. In this case, we're loading aurelia-bootstrapper which resides in the aurelia-core.min.js file linked above. This module contains Aurelia's \"bootstrap\" or \"startup\" code. This tells Aurelia to load the framework, configure it and run your application. There's one more thing to note. I wonder if you noticed it. On the body tag, there's an aurelia-app attribute. It's pointing to src/main. This is what tells Aurelia's bootstrapper what module contains the framework configuration as well as what HTML element is the \"host\" element where the application will be rendered. We'll look at creating that file a little bit later. Before we do that, we want to do something a bit non-traditional. We want to show you how you can build your entire Todo application in plain, vanilla ${context.language.name} without using any Aurelia APIs. Then, we'll use Aurelia to render our application to the screen, without changing any of our ${context.language.name} code. I know you're going to find this interesting, so let's get to it!"},{"articleName":"Creating a Todo App","articleHref":"docs/tutorials/creating-a-todo-app","sectionName":"The Todo Class","sectionId":"the-todo-class","id":1583,"text":"One of the amazing things you can do with Aurelia, that you can't with any other framework or library, is model your entire application using plain ${context.language.name}. We think you'll understand it when you see it. We're going to begin by creating a Todo class. Since we're making a Todo App, we'll need a class to model out an individual Todo item. In the src folder of your project, create the following file: That's it. It's a plain class that models the todo's description text along with a boolean done to indicate if you've completed your todo."},{"articleName":"Creating a Todo App","articleHref":"docs/tutorials/creating-a-todo-app","sectionName":"The App Class","sectionId":"the-app-class","id":1584,"text":"Our todo application contains a list of Todo instances. It can add and remove todos. The todos are added by allowing the user to provide a todo description. Once they type a description and add the todo, the description is cleared so they can create another todo. Let's model these ideas. Here's the App class: Again, it's that simple. Let's review the ideas we modeled: Our application has a heading of \"Todos\". The todo list is modeled as an array of Todo instances represented by the todos property. Todo instances can be added (addTodo) or removed (removeTodo). When instances are added, they are given a description, provided by the user. After the Todo is added, the description is cleared to enable the next addition. Here's what's amazing. This is all the ${context.language.name} code for the app. But where is Aurelia? Well, the answer is that Aurelia tries as hard as possible to stay out of your ${context.language.name} code. That's why you don't see it above. It's not needed. Aurelia has the ability to render plain ${context.language.name} objects."},{"articleName":"Creating a Todo App","articleHref":"docs/tutorials/creating-a-todo-app","sectionName":"Getting Ready to Render","sectionId":"getting-ready-to-render","id":1585,"text":"Ok, now that we've modeled out our application in ${context.language.name}, we need to make Aurelia render it. We weren't completely honest when we said above that we had showed you all the ${context.language.name} code. There's one final piece that gets it all going. If you recall, when we looked at index.html there was an aurelia-app attribute on the body element. This attribute tells the aurelia-bootstrapper where to render the application and what main file to use to configure the app. The value of that attribute points to src/main. So, let's create that file in our src folder and see what it does. Info When working with TypeScript, in this simple setup, you may see some \"squigglies\" in your code editor. This results from the fact that this simple setup isn't configured in a way that the code editor can find the type definition files. It's nothing to worry about and everything will work correctly. In the next tutorial, when we set up a production-ready project, this issue will go away. If you have prior experience with this, you can use Typings to install the d.ts definitions yourself at any point. When we provide a main file, like above, we are able to tell Aurelia how to configure itself by simply exporting a configure method. The framework will provide an instance of the Aurelia object which you can use in a variety of ways. There are many options, plugins and 3rd party extensions you can add, for example. In this case, we're configuring Aurelia with the \"basic configuration\". After that, we tell the framework to \"start\". Once it is started up we tell it to \"set root\". So, what does \"set root\" mean? If you think of your UI as a hierarchy of components, what we're doing is configuring the \"root\" component of that hierarchy. This is the root of the UI component tree that Aurelia needs to render. The next thought you might have is \"but you didn't say what component to render!\" That's a great point. One of the ways that Aurelia is able to stay out of the way is by having some basic conventions. In this case, we have a very simple convention. The root, by default, is app.js, relative to the main.js file. If you don't like that, as with all Aurelia conventions, you can override it with explicit configuration. For now, let's stick to the conventions. Ok, we're almost ready to run our app. The next piece is to tell Aurelia how it should render app.js;"},{"articleName":"Creating a Todo App","articleHref":"docs/tutorials/creating-a-todo-app","sectionName":"Rendering the App","sectionId":"rendering-the-app","id":1586,"text":"As a brief recap, remember that almost nothing we've done so far is Aurelia-specific. Almost all the code we've written is just vanilla ${context.language.name}. Now that we've added a main file to our project and have specified which module exports the root component of our UI hierarchy, Aurelia is ready to render. In order to render, we need to create a view for the app component. This introduces the next convention of Aurelia. To create a view for any class, simply create an HTML file with the same name as the ${context.language.name} module but change the file extension to .html. Inside that view, you can place an HTML 5 template with data binding expressions declaring how the view should render an instance of the class. Let's start with a very basic view of our app. There are a couple of things to notice here. First, all views are wrapped in a Web Components template element. Second, did you notice the \\${heading} syntax? Well, inside of a view, you have access to all the properties and methods of the class instance associated with that View and you can access them inside the content of any element or attribute by using the ${context.language.name} template string syntax as shown above. The above syntax creates a one-way data-binding to the heading property. By \"one-way\" we mean that the dataflow is unidirectional and only changes to the heading property will affect the view. There is no \"reverse\" flow from the view back to the view-model. Info: Presentation Patterns We call a View's associated class its View-Model because it's a model for, or a model of the View. Most Aurelia development leverages the Model - View - View-Model pattern. However, Aurelia is flexible enough to enable also using patterns like Supervising Controller, Passive View and Model - View - Controller if desired. Ok, now that we have a view, we're ready to run our app. To do that, we'll need to start a web server to serve up your index.html page, so we can view it in a browser. How you go about doing that depends on which server-side technology you want to use. Below are instructions for a couple of common scenarios: Visual Studio - Open Visual Studio 2015. Using the main menu, select File > Open > Web site... In the resulting dialog, choose the project folder then click the Open button. The folder contents will be displayed in the Visual Studio Solution Explorer window. Right click on index.html in Solution Explorer and select \"View in Browser\". This will fire up the development web server and serve index.html. NodeJS with npm - To start up a simple web server in the project folder, first globally install the http-server command with npm install http-server -g. (In some environments you may need to use sudo). Once that is installed, change directory to the project folder. You can now spin up the server from within the folder with the following command http-server -o -c-1. NodeJS with yarn - First install the http-server with yarn add http-server. Then use yarn run http-server -o -c-1 to run the server. Firefox - If you don't want to worry about setting up a web server, Firefox is flexible enough to serve the app directly from your hard drive. Simply open the index.html file with Firefox. When you run the app, you should see the app render out the heading property, something like this: Todo App With Heading Rendering properties in HTML seems simple enough, but what about working with user input? Let's add some markup that enables us to take input from the user to create our todos: Now, we've added a form to our view. We're using this to collect the todo name from the user. Take a look at the input. By appending .bind to the value attribute, we've told Aurelia that we want it to be bound to the todoDescription on our view-model. In Aurelia, you can bind any HTML attribute to its view model with a simple property expression like this, just by appending .bind. Here, we have another convention that it's important to point out. When we use .bind Aurelia works on your behalf to pick the most sensible \"binding mode\" based on the element and attribute you are binding. For example, since this is an input and you are binding its value then .bind will cause Aurelia to set up a two-way binding. This means that any time the view-model's todoDescription changes, it will be updated in the input's value property but also any time the input's value property changes, the view-model will have its todoDescription updated as well. There's something else of note in this markup though. We can not only bind properties, but you can attach to events. Take a look at the form element itself. In Aurelia, you can take any DOM event and append .trigger to it. This means that when that event fires, it will trigger the associated expression to be evaluated. In this case, the submit event causes the addTodo() method to be invoked. Because we've used the submit event, it means that the todo will be added either by pressing the submit button or by pressing enter while inside the input. Info: Binding Commands Aurelia will use two-way binding for all form control value bindings and one-way binding for everything else. However, you can always override this by using an explicit binding command. For example, instead of using .bind you can use .one-way, .two-way or .one-time. Similarly, you can use .delegate for event delegation in place of .trigger. If you run the app now, you should see something like this: Todo App With Form Try typing into the input box and adding the todo. You should notice that the input box gets cleared out each time you do that. The reason for this is that the value of the input has two way binding and our original code cleared out the todoDescription after adding a new Todo instance. Here's our addTodo() implementation for reference: Well, we can now add todos, but we can't see them! Let's remedy that by looking at how Aurelia handles lists of data. Change your markup to match this new version: To generate HTML based on an Array, Map or Set, we use the repeat.for=\"local of collection\" syntax. This syntax is derived from the for...of loop of ${context.language.name} itself. As you can see above, we want to generate one li for each item in our todos array. So, we place a repeat.for attribute on the li we want to be generated and we specify the todos collection and that we want the local loop variable to be named todo. With this we can bind to any property of the todo instance. So, you can see how we're just re-applying all the same techniques from above now. We're binding the checked attribute to the todo's done property and its description property is being injected into the content of the span. Finally, we're adding a trigger on the button's click event so that we can remove the todo. Notice that the removeTodo is still in scope. Just like in ${context.language.name}, inside a loop, you still have access to the variable in the outer block. This allows us to call the removeTodo method on the App class, passing in the particular Todo instance that we want to remove. If you run the application again, you should now see something like this: Todo App With List We're almost there! There's one thing that's missing. Notice that if you check and uncheck the boxes, nothing happens. We would like to have some user feedback in this case. Perhaps crossing out the todo item? Let's make one final version of our view to add that in: This final example shows how we can bind css directly on any HTML element. It also shows how we can use our \\${} syntax directly inside any attribute. In this case, we want to add the text-decoration of line-through whenever the todo's done property is true, otherwise we want the none value. Warning: style vs css attribute Use the style attribute's alias, css when doing string interpolation to ensure your application is compatible with Internet Explorer and Edge, if you care about supporting these browsers. Run the application one more time and you should see the expected result: Todo App With CSS"},{"articleName":"Creating a Todo App","articleHref":"docs/tutorials/creating-a-todo-app","sectionName":"Conclusion","sectionId":"conclusion","id":1587,"text":"With its strong focus on developer experience, Aurelia can enable you to not only create amazing applications, but also enjoy the process. We've designed it with simple conventions in mind so you don't need to waste time with tons of configuration or write boilerplate code just to satisfy a stubborn or restrictive framework. You'll never hit a roadblock with Aurelia either. It's been carefully designed to be pluggable and customizable...and most of the time you just write plain ${context.language.name} and forget the framework is even there. Thanks for taking the time to read through our guide. There's so much more to learn and do! We hope you'll continue on to our Contact Manager Tutorial to learn how to use the Aurelia CLI to get setup with a production-grade project and use some more advanced features like routing, publish/subscribe and custom elements. We're looking forward to seeing what you create!"},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Setting Up Your Machine","sectionId":"setting-up-your-machine","id":1588,"text":"For this tutorial, we're going to use the Aurelia CLI. If you've already setup your machine with the CLI, you can skip to the next section. If not, then please install the following CLI prerequisites: Install NodeJS version 4.x or above. You can download it here. Install a Git Client Here's a nice GUI client. Here's a standard client. Warning When installing Git for Windows, there is an option to use git bash only, run git from windows command prompt, or run git and included unix tools from windows command prompt. You must choose run git from windows command prompt or run git and included unix tools from windows command prompt in order for the Aurelia CLI to work. Once you have the prerequisites installed, you can install the Aurelia CLI itself. From the command line, use npm to install the CLI globally: Info Always run commands from a Bash prompt. Depending on your environment, you may need to use sudo when executing npm global installs. Warning While creating a new project doesn't require NPM 3, front-end development, in general, requires a flat-package structure, which is not available with NPM versions prior to 3. It is recommended that you update to NPM 3, which will be able to manage this structural requirement. You can check your NPM version with npm -v. If you need to update, run npm install npm -g."},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Creating A New Aurelia Project","sectionId":"creating-a-new-aurelia-project","id":1589,"text":"Now, that you've got your machine setup, we can create our contact manager app. To create the project, run au new from the command line. You will be presented with a number of options. Name the project \"contact-manager\" and then select either the \"Default ESNext\" or \"Default TypeScript\" option depending on what is most comfortable for you. (Do not select \"Custom\" for this tutorial.) Once you've made your choice, the CLI will show you your selections and ask if you'd like to create the file structure. Hit enter to accept the default \"yes\". After that, you'll be asked if you would like to install your new project's dependencies. Press enter to select the default \"yes\" for this as well. Once the dependencies are installed (it will take a few minutes), your project is ready to go. Just change directory into the project folder and run it by typing au run --watch. This will run the app and watch the project's source for changes. Open a web browser and navigate to the url indicated in the CLI's output. If you've got everything setup correctly, you should see the message \"Hello World!\" in the browser."},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Adding Required Assets","sectionId":"adding-required-assets","id":1590,"text":"For this tutorial, we're going to be working against a fake, in-memory backend. We've also pre-created the CSS and some utility functions, so we don't have to waste time on that here. Before we begin writing the app, you'll need to download these required assets and add them to your project. Once you've downloaded the zip file, extract it and you'll find three files: web-api.js - The fake, in-memory backend. utility.js - Some helper functions used by the app. styles.css - The styles for this app. Copy all of these files to the src folder of your project. TypeScript users should also rename the file extensions from .js to .ts."},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Building the Application Shell","sectionId":"building-the-application-shell","id":1591,"text":"Warning Before proceeding any further, please make sure you are familiar with the concepts introduced in Creating a Todo App or otherwise have some basic experience with Aurelia. Topics covered in Creating a Todo App will not be covered in this article. Let's start by looking at a picture of the final product of this tutorial. It will help us to see the application's structure and the pieces we need to build. The Final Contact Manager App In the picture, you can see that we have a header across the top, a contact list on the left and a detail pane filling the rest of the space. We'll refer to the over-arching application structure, as the shell or layout of our app. Let's begin by putting that in place now. To begin, we're going to setup our App class by configuring it with a router. We want our browser history to reflect which contact in our list is selected, so we'll introduce a client-side router to handle the navigation from screen to screen. Replace the code in your app${context.language.fileExtension} with the following: Warning After changing the code above, if you immediately try to compile, you may receive a compile error on your unit tests because the sample test references the App class, which we just changed. To address this, remove the dummy unit test. To add routing to your app, all you have to do is add a configureRouter method to your App class. The framework will call this method, passing it a RouterConfiguration and a Router. You can use the configuration object to get the router setup with the routes you want. Use the map method to map route patterns to the modules that should handle the patterns. Minimally, each route needs at least a route pattern and a moduleId. In the case above, we are registering two routes. The first route is empty, indicated by route: ''. This will be the default route that is matched when there is no fragment. This route will cause the no-selection module to load. We'll use this to display a nice message to the user, if they haven't selected a contact to view. The second route has the pattern contacts/:id. This will match the literal contacts/ followed by a parameter, which we've named id. When this route is matched, the router will load the contact-detail module so that we can display the selected contact. Info Did you notice the calls to PLATFORM.moduleName(....)? This is a special API that is used in Aurelia Webpack projects to allow Webpack to identify strings that represent modules. This enables Webpack to include the referenced module in the built package. There are a couple more points of interest with this configuration. First, notice that we've set the config.title property. This sets a base \"title\" to be used in the document's title for the browser. We can also set a title on each route. When we do that, the router's title and the matched route's title will be joined together to form the final document title. The second thing to notice is that the second route has a name property. We'll be able to use this later to generate routes without needing to copy/paste the route pattern everywhere. Instead, we can just refer to the route by name. Now that we've configured our application's navigation structure, we need to put the visual structure in place. To do that, replace your app.html file with the following markup: There are several interesting things to note about this view. First, take a look at the require elements at the top of the view. This is how we can \"import\" or \"require\" various resources into our view. It's the view equivalent of the ES 2015 \"import\" syntax. Just as JavaScript is modularized and requires importing of other resources, so do Aurelia views. In this specific case, we're indicating that we want to bring in our custom styles. Below the require elements, you can see a pretty standard structure. We have some HTML to setup a navbar at the top. Below that we have the application's main container div. This has two columns. The first will contain our contact list, indicated by the placeholder div. The second contains a router-view custom element. The router-view is provided by Aurelia and is a placeholder that indicated where the router should render the current route. This allows you to structure your application layout however you want, simply placing the router-view wherever you want to see the current page rendered. Whenever you have a configureRouter method, the view must also contain a router-view. We're almost done setting up the application shell. Before we're done, we need to install Bootstrap and import it in our main file. We'll be using that in this tutorial in order to give our application a decent appearance. In your own apps, you can use any CSS framework you like. To get Bootstrap setup, we begin by installing the library itself with NPM. Execute the following on the command line to do this: Next, we need to import it in our main${context.language.fileExtension} by adding the following line to the top of the file: Info Whenever you install new dependencies used in your app, make sure to restart the au run or respectively the au run --watch command, in order to have the CLI re-bundle your freshly added dependencies."},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Building Out the Default Route","sectionId":"building-out-the-default-route","id":1592,"text":"If you run the application now, using au run --watch, you'll see a compile error similar to: This is actually expected. Why? Well, we use PLATFORM.moduleName(....) as part of our route configuration, but we haven't actually created these modules. Let's create them now. Create a new file under src named no-selection${context.language.fileExtension} and give it the following code: This will provide the basic functionality for our \"no selection\" screen. All we want to do is display a message to our end user to select a contact. Now, let's add a view to render this view-model. Create another file named no-selection.html and add that to your src folder with the following contents: All it does is provide a container with some styling in order to display our message to the user. Next, let's just add a placeholder module for our contact detail screen, so we can satisfy the build. Create a new file under src named contact-detail${context.language.fileExtension} and give it the following code: With this in place, you should now be able to run your application. If you haven't stopped/restarted it after editing the bundles, then you will need to do that now. When you run the application, you should see something similar to this: No Selection Screen"},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Building Out the Contact List","sectionId":"building-out-the-contact-list","id":1593,"text":"We've got the basic visual structure of our application in place and routing is now working. We've even created our first screen. However, it's not very interesting. We've got a div placeholder for the actual contact list at present. Let's go ahead and build that out, as a contact-list custom element. Aurelia strives to be a self-consistent framework. As such, building a custom element is the same as creating your App component and your routed components. To create the contact-list custom element, start by creating a new file named contact-list${context.language.fileExtension} and add the following code: Info We use a dashed naming convention to separate the words contact-list as our custom element name. The name of the class instead should be defined by using the UpperCamelCase version ContactList. The view-model for our custom element has a few notable characteristics. First, we're using dependency injection. Aurelia has its own dependency injection container, which it uses to instantiate classes in your app. Classes can declare constructor dependencies through inject metadata. This looks a bit different depending on what language you are using. In ES 2015, you can declare an inject static method that returns an array of constructor dependencies while in ES Next and TypeScript, you can use an inject decorator to declare those dependencies. As you can see here, our ContactList class has a dependency on our WebAPI class. When Aurelia instantiates the contact list, it will first instantiate (or locate) an instance of the web API and \"inject\" that into the contact list's constructor. The second thing to notice is the created method. All Aurelia components follow a component life-cycle. A developer can opt into any stage of the life-cycle by implementing the appropriate methods. In this case, we're implementing the created hook which gets called after both the view-model and the view are created. We're using this as an opportunity to call our API and get back the list of contacts, which we then store in our contacts property so we can bind it in the view. Finally, we have a select method for selecting a contact. We'll revisit this shortly, after we take a look at how it's used in the view. On that note, create a contact-list.html file and use the following code for the view: The markup above begins by repeating an li for each contact of our contacts array. Take a look at the class attribute on the li. We've used an interesting technique here to add an active class if the contact's id is the same as the selectedId of the contact on our ContactList view-model. We've used the $parent special value to reach outside of the list's scope and into the parent view-model so we can test against that property. Throughout the list template, we've used basic string interpolation binding to show the firstName, lastName and email of each contact. Take special note of the a tag. First, we are using a custom attribute provided by Aurelia's routing system: route-href. This attribute can generate an href for a route, based on the route's name and a set of parameters. Remember how we named the contacts route in our configuration? Here we're using that by referencing the \"contacts\" route name and binding the contacts's id parameter as the route's id parameter. With this information, the router is able to generate the correct href on the a tag for each contact. Additionally, we've also wired up a click event. Why would we do this if the href is already going to handle navigating to the correct contact? Well, we're looking for instant user feedback. We want the list selection to happen ASAP, so we don't have to wait on the navigation system or on the loading of the contact data. To accomplish this, we use the select method to track the selected contact's id, which allows us to instantly apply the selection style. Finally, normal use of .trigger or .delegate causes the default action of the event to be cancelled. But, if you return true from your method, as we have done above, it will be allowed to continue. Thus, when the user clicks on the contact, we immediately select the contact in the list and then the href is allowed to trigger the router, causing a navigation to the selected contact. Ok, now that we've got the contact list built, we need to use it. To do that, update your app.html with the following markup: There are two important additions. First, we've added another require element at the top, to import our new contact-list into this view. Remember that views are encapsulated, just like modules. So, this makes the contact-list visible from within this view. Second, we now use the custom element, right above our router-view. If you go ahead and run the application, you should now see something like this: The Contact List"},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Building Out the Contact Detail Screen","sectionId":"building-out-the-contact-detail-screen","id":1594,"text":"Ok, things are starting to come together, but we still can't view an individual contact. If you try selecting something from the list, you'll see an error like the following in the console: Again, this is because the router is trying to route to the detail screen, but we only have a stub component with no view. So, let's build out the real detail component. Replace the contents of contact-detail${context.language.fileExtension} with the following code: Once again, we are using dependency injection to get an instance of our WebAPI. We need this to load the contact detail data. Next, we implement a method named activate. Remember when we mentioned that all components have a life-cycle? Well, there are additional life-cycle methods for routed components. activate is one such method and it gets invoked right before the router is about to activate the component. This is also how the router passes the component its route parameters. Let's dig in a bit more. The first argument passed to activate is the params object. This object will have one property for every route param that was parsed as well as a property for each query string parameter. If you recall, our route pattern for the contact details screen was contacts/:id. So, our params object will have an id property with the requested contact's id. Using this id we call our WebAPI to retrieve the contact data. This API returns a Promise which we wait on and then store the loaded contact in a contact property so it's easy to bind to. We also make a copy of this object and store it in the originalContact property, so we can do some rudimentary checking to see if the data has been edited by the user at a later point. The second argument passed to activate is the routeConfig. This is the same configuration object that you created to configure the router itself. You can get access to that here so that you can access any of its properties. The router generates a navModel for each routeConfig. Using the navModel you can dynamically set the title of the document for this route. So, we call navModel.setTitle() in order to set up the document's title with the name of the contact that we just loaded. This screen demonstrates another part of the navigation lifecycle available to routed components: the canDeactivate hook. If present, this method is called before navigating away from the current component. It gives your component an opportunity to cancel navigation, if it desires.  In the case of the contact detail screen, we are comparing our originalContact to the current contact, using our areEqual helper method, in order to determine whether or not the user has made any changes to the data. If they have, we show a confirmation dialog to make sure they want to navigate away, since they would lose their changes. If the canDeactivate hook returns true, navigation is allowed; if false is returned, it is prevented and the route state is reverted. If we take a brief look at the save method, we can see that this is just a brief call to the WebAPI's saveContact method. After that succeeds, we update our originalContact to the latest version and then we update the document's title with the potentially new contact name. Finally, we have a canSave computed property which we'll use in the view. This will help us show some simple feedback to the user to indicate whether the UI and data are in a state that allows for saving. With that all in place, let's look at the view that will render this component. Create a new file named contact-detail.html. Don't be intimidated by the amount of HTML above. It's mostly all basic form controls and bootstrap structures. If you look at the input elements, you will see that they all have a two-way binding to the appropriate contact's properties. The only real interesting part is the button element at the bottom. This button invokes save when clicked, but notice that it also has its disabled attribute bound to our canSave property. The result is that the user won't be able to save if the API is in the middle of a request or if there is missing contact information. You should now be able to select contacts in the list, see their details, edit them, save and even see the confirm dialog on unsaved data navigations. It should look something like this: The Contact Details"},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Adding Pub/Sub Messaging","sectionId":"adding-pubsub-messaging","id":1595,"text":"If you play around with the application for a bit, you'll notice a few \"buggy\" behaviors: Refreshing the browser with a contact selected results in the correct contact being shown, but not in the correct contact list item being highlighted. If you edit some data, try to navigate away and then cancel, the contact list item selection will go out of sync, highlighting the contact you were going to before you cancelled, but not the current contact. If you edit some data and save, you will notice that changes in the name are not reflected in the list. The reason for these issues is that we have two separate components, our contact-list and our contact-detail which both have their own internal data structures and behaviors, but which do have an affect on each other. The router is controlling the contact detail screen, so it's the ultimate source of truth and the contact list should sync with it. To handle this, we're going to increase the amount of information in our system by introducing pub/sub. Let's create a couple of messages that our contact-detail component can publish and then let the contact-list subscribe to those and respond appropriately. Whenever the contact detail screen successfully saves a contact, we'll publish the ContactUpdated message and whenever the end user begins viewing a new contact, we'll publish the ContactViewed message. Each of these messages will carry the contact data along with it so that subscribers have contextual data related to the event. Next, let's update our contact-detail code to incorporate Aurelia's EventAggregator and publish the messages at the appropriate time: First, notice that we've both imported Aurelia's EventAggregator and configured it to be injected into the constructor of our ContactDetail class. We've also imported the two messages we created. Whenever a contact is loaded, we publish the ContactViewed message. Whenever a contact is saved, we publish the ContactUpdated message. Finally, if the user attempts to navigate away, but cancels, we reflect this by publishing another ContactViewed message, representing that they are returning to view the current contact. With these messages in place, we can now enable any other component in our system to loosely subscribe to the new information in our system and use that data as appropriate to its internal needs. We'll go ahead and update the contact-list component to take advantage of this information to ensure that it is always in sync: As you can see, we've just imported and injected our EventAggregator and then it's as simple as calling the subscribe method and passing it the message type and a callback. When the message is published, your callback is fired and passed the instance of the message type. In this case, we use these messages to update our selection as well as the details of the contact that are relevant to our list. If you run the application now, you should see that everything is working as expected."},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Adding A Loading Indicator","sectionId":"adding-a-loading-indicator","id":1596,"text":"Let's add one more final touch to this application. Whenever we're navigating from screen to screen or making a WebAPI request, let's show a loading indicator at the top of our app. To do this, we'll use a 3rd party library and create a custom Aurelia element to wrap it up. Begin by installing the nprogress library with the following command: Info: TypeScript Definition Files TypeScript users should note that when using 3rd party libraries, in order to make them work in a TypeScript project, you may need to acquire (or create) d.ts files. See TypeScript's official documentation, if you encounter issues. With that in place, let's create our loading-indicator custom element. In the src/resources/elements folder create a file named loading-indicator${context.language.fileExtension} and use the code below for its implementation: This code creates a custom element, but we're doing a few unique things here. First, since the entire rendering job is handled by the NProgress library, we don't need Aurelia's templating engine to render this component at all. So, we use the noView() decorator to tell Aurelia not to load a loading-indicator.html, compile it or do any of that rendering work. Additionally, the NProgress library requires some CSS to work, so we make sure to import that above. Next, we want our custom HTML element to have a loading property that we can bind to via an HTML attribute in the DOM. So, we declare that by using the bindable decorator. Whenever you have a bindable, by convention, you can optionally declare a propertyNameChanged method that will be called whenever the binding system updates the property. So, we've added one of those so that we can toggle the NProgress indicator off and on, based on the value of that property. Previously, when we created the contact-list component, we required that into the app.html view and used it, since all views are encapsulated. However, we're going to do something different in this case, as an example. Aurelia actually gives you the ability to globalize view resources, such as custom elements. This is a convenience so that you don't have to require common resources repeatedly into every view. To do this, we need to register our element as a global resource. Open up the resources/index${context.language.fileExtension} file that's already in your solution, and change the code so that it has the registration as follows: With this registration in place, we can now use our new indicator in our app.html, but before we do that, we want to make one more change to our app${context.language.fileExtension}. We would like to be able to bind the indicator to the request state of our API, so we need to make that available in our App class. Update your app${context.language.fileExtension} as follows: Ok, now that we've got an api property we can bind to, update your app.html to the final version that adds the loading-indicator and binds its loading property: And with that, we've finished our app. Congratulations!"},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Next Steps","sectionId":"next-steps","id":1597,"text":"Now that you've completed the tutorial, you may want to consider doing some additional research or development exercises to continue your learning and hone your skills. Here are a few ideas: Create a real backend for the app and use the http-client or fetch-client to retrieve the data. Extend that application so that new contacts can be added. Extend the contact detail form with data validation. Learn more about the component life-cycle. Learn more about the navigation life-cycle and routing. Expand your knowledge of binding and templating."},{"articleName":"Creating a Contact Manager","articleHref":"docs/tutorials/creating-a-contact-manager","sectionName":"Conclusion","sectionId":"conclusion","id":1598,"text":"This tutorial presents a fairly simple application, but it provides an opportunity to demonstrate a number of interesting techniques. We hope it's helped you along in the process of learning Aurelia and we look forward to seeing what things you will build next."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Bootstrapping Aurelia","sectionId":"bootstrapping-aurelia","id":1599,"text":"Most platforms have a \"main\" or entry point for code execution. Aurelia is no different. If you've read the Quick Start, then you've seen the aurelia-app attribute. Simply place this on an HTML element and Aurelia's bootstrapper will load an app${context.language.fileExtension} and app.html, databind them together and inject them into the DOM element on which you placed that attribute. Often times you want to configure the framework or run some code prior to displaying anything to the user though. So chances are, as your project progresses, you will migrate towards needing some startup configuration. In order to do this, you can provide a value for the aurelia-app attribute that points to a configuration module. This module should export a single function named configure. Aurelia invokes your configure function, passing it the Aurelia object which you can then use to configure the framework yourself and decide what, when, and where to display your UI. Here's an example configuration file showing the standard configuration, the same configuration that is equivalent to what you would get when using aurelia-app without a value: So, if you want to keep all the default settings, it's really easy. Just call standardConfiguration() to configure the standard set of plugins. Then call developmentLogging() to turn on logging in debug mode, output to the console. Warning Some Aurelia modules will not behave correctly if they are imported before the Aurelia Platform Abstraction Layer (PAL) is initialized, which happens during aurelia.start(). If you need these modules in your configuration module, you need to initialize the PAL yourself before the file is loaded. This Github issue describes how you can manually initialize the PAL before starting the bootstrapping process. The use property on the aurelia instance is an instance of FrameworkConfiguration. It has many helper methods for configuring Aurelia. For example, if you wanted to manually configure all the standard plugins without using the standardConfiguration() helper method to do so and you wanted to configure logging without using the helper method for that, this is how you would utilize the FrameworkConfiguration instance: You can see that this code configures the default data-binding language (.bind, .trigger, etc.), the default set of view resources (repeat, if, compose, etc.) the history module (integration with the browser's history API), the router (mapping routes to components) and the event aggregator (app-wide pub/sub messaging). If, for example, you were building an app that didn't need to use the router or event aggregator, but did want debug logging, you could do that very easily with this configuration: Once you've configured the framework, you need to start things up by calling aurelia.start(). This API returns a promise. Once it's resolved, the framework is ready, including all plugins, and it is now safe to interact with the services and begin rendering."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Rendering the Root Component","sectionId":"rendering-the-root-component","id":1600,"text":"The root component is set by calling aurelia.setRoot(). If no values are provided, this defaults to treating the element with the aurelia-app attribute as the DOM host for your app and app${context.language.fileExtension}/app.html as the source for the root component. However, you can specify whatever you want, just like this: This causes the my-root${context.language.fileExtension}/my-root.html to be loaded as the root component and injected into the some-element HTML element. Info The content of the app host element, the one marked with aurelia-app or passed to Aurelia.prototype.setRoot, will be replaced when Aurelia.prototype.setRoot completes. Warning: When using the <body> element as the app host, bear in mind that any content added prior to the completion of Aurelia.prototype.setRoot will be removed."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Bootstrapping Older Browsers","sectionId":"bootstrapping-older-browsers","id":1601,"text":"Aurelia was originally designed for Evergreen Browsers. This includes Chrome, Firefox, IE11 and Safari 8. However, we also support IE9 and above through the use of additional polyfills. To support these earlier browsers, you need the requestAnimationFrame Polyfill and the MutationObserver polyfill. Once you have installed these (via npm install --save-dev raf mutationobserver-shim), you'll need to adjust your code to load them before Aurelia is initialized. In case you are using Webpack, create a file, e.g. ie-polyfill.js: After you have created the file, add it as the first file in your aurelia-bootstrapper bundle. You can find bundle configuration in the webpack.config.js file, something like: If you are using JSPM change your index.html startup code as follows: Info: Module Loaders and Bundlers The code in this article demonstrates loading via SystemJS. However, these techniques can be accomplished with other module loaders just as readily. Be sure to lookup the appropriate APIs for your chosen loader or bundler in order to translate these samples into the required code for your own app. Warning: Promises in Edge Currently, the Edge browser has a serious performance problem with its Promise implementation. This deficiency can greatly increase startup time of your app. If you are targeting the Edge browser, it is highly recommended that you use the bluebird promise library to replace Edge's native implementation. You can do this by simply referencing the library prior to loading other libraries."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Manual Bootstrapping","sectionId":"manual-bootstrapping","id":1602,"text":"So far, we've been bootstrapping our app declaratively by using the aurelia-app attribute. That's not the only way though. You can manually bootstrap the framework as well. In case of JSPM, here's how you would change your HTML file to use manual bootstrapping: In case you use Webpack, you can replace the aurelia-bootstrapper-webpack package with the ./src/main entry file in the aurelia-bootstrapper bundle defined inside of webpack.config.js, and call the bootstrapper manually: The function you pass to the bootstrap method is the same as the configure function from the examples above."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Making Resources Global","sectionId":"making-resources-global","id":1603,"text":"When you create a view in Aurelia, it is completely encapsulated. In the same way that you must import modules into an ES2015/TypeScript module, you must also import or require components into an Aurelia view. However, certain components are used so frequently across views that it can become very tedious to import them over and over again. To solve this problem, Aurelia lets you explicitly declare certain \"view resources\" as global. In fact, the configuration helper method defaultResources() mentioned above does just that. It takes the default set of view resources, such as repeat, if, compose, etc, and makes them globally usable in every view. You can do the same with your own components. Here's how we could make the my-component custom element, located in a resources subfolder of your project, globally available in all views."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Organizing Your App with Features","sectionId":"organizing-your-app-with-features","id":1604,"text":"Sometimes you have whole group of components or related functionality that collectively form a \"feature\". This \"feature\" may even be owned by a particular set of developers on your team. You want these developers to be able to manage the configuration and resources of their own feature, without interfering with the other parts of the app. For this scenario, Aurelia provides the \"feature\" feature. Imagine, as above, that we have a my-component component. Imagine that that was then one of a dozen components that formed a logical feature in your app called my-feature. Rather than place the feature's configuration logic inside the app's configuration module, we can place the feature's configuration inside its own feature configuration module. To create a \"feature\", simply create a folder in your app; in the case of our example: my-feature. Inside that folder, place all the components and other code that pertain to that feature. Finally, create an index${context.language.fileExtension} file at the root of the my-feature folder. The index${context.language.fileExtension} file should export a single configure function. Here's what our code might look like for our hypothetical my-feature feature: The configure method receives an instance of the same FrameworkConfiguration object as the aurelia.use property. So, the feature can configure your app in any way it needs. An important note is that resources should be configured using paths relative to the index${context.language.fileExtension} itself. How then do we turn this feature on in our app? Here's an app configuration file that shows: Info: Features with Webpack When using Webpack, the syntax for enabling a feature is a little different. Instead of calling .feature('my-feature');, you will want to use the PLATFORM.moduleName(...) helper that allows the Aurelia Webpack plugin to understand dynamic module references. In this case, your syntax will look like .feature(PLATFORM.moduleName('my-feature/index')); Notice that in addition to the use of the PLATFORM.moduleName(...) helper, the index file must be directly referenced."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Installing Plugins","sectionId":"installing-plugins","id":1605,"text":"Similar to features, you can install 3rd party plugins. The main difference is that a \"feature\" is provided internally by your application, while a plugin is installed from a 3rd party source through your package manager. To use a plugin, you first install the package. For example jspm install my-plugin would use jspm to install the my-plugin package. Once the package is installed, you must configure it in your application. Here's some code that shows how that works. Simply provide the same name used during installation to the plugin API. Some plugins may require configuration (see the plugin's documentation for details). If so, pass the configuration object or configuration callback function as the second parameter of the plugin API. While all plugins work in a similar manner, consider the real-world example of adding and configuring the dialog plugin by using a configuration callback. The configuration parameter in this case is a type of DialogConfiguration and the above code would become:"},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Leveraging Progressive Enhancement","sectionId":"leveraging-progressive-enhancement","id":1606,"text":"So far you've seen Aurelia replacing a portion of the DOM with a root component. However, that's not the only way to render with Aurelia. Aurelia can also progressively enhance existing HTML. Imagine that you want to generate your home page on the server, including using your server-side templating engine to render out HTML. Perhaps you've got custom components you created with Aurelia, but you want to render the custom elements on the server with some content, in order to make things a bit more SEO friendly. Or perhaps you have an existing, traditional web app, that you want to incrementally start adding Aurelia to. When the HTML is rendered in the browser, you want to progressively enhance that HTML and \"bring it to life\" by activating all the Aurelia component's rich behavior. All this is possible with Aurelia, using a single method call: enhance. Instead of using aurelia-app let's use manual bootstrapping for this example. To progressively enhance the entire body of your HTML page, you can do something like this (JSPM-based example): It's important to note that, in order for enhance to identify components to enhance in your HTML page, you need to declare those components as global resources, as we have above with the my-component component. Optionally, you can provide an object instance to use as the data-binding context for the enhancement, or provide a specific part of the DOM to enhance. Here's an example that shows both (JSPM-based): But what if you need to enhance multiple elements on a page that do not have a direct parent/child relationship? For example, suppose you have an existing application written on a non-Aurelia framework that you need to refactor component by component. You can't use the aurelia.enhance method multiple times because it was not designed for that. Instead you can use the templating engine's enhance method directly."},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Customizing Conventions","sectionId":"customizing-conventions","id":1607,"text":"There are many things you may want to customize or configure as part of your application's bootstrap process. Once you have your main configure method in place and aurelia-app is pointing to that module, you can do just about anything you want. One of the most common aspects of Aurelia that developers may want to customize, is its conventions. Configuring the View Location Convention Aurelia uses a View Strategy to locate the view that is associated with a particular component's view-model. If the component doesn't specify its own view strategy, then Aurelia's ViewLocator service will use a fallback view strategy. The fallback strategy that is used is named ConventionalViewStrategy. This strategy uses the view-model's module id to conventionally map to its view id. For example, if the module id is \"welcome${context.language.fileExtension}\" then this strategy will look for the view at \"welcome.html\". The conventional strategy's mapping logic can be changed if a different convention is desired. To do this, during bootstrap, import the ViewLocator and replace its convertOriginToViewUrl method with your own implementation. Here's some example code: In this example, you would simply replace \"...\" with your own mapping logic and return the resulting view path that was desired. If you're using Webpack with a HTML templating engine such as Jade, you'd have to configure Aurelia to look for the .jade extension instead of .html. This is due to Webpack keeping the original sourcemaps and lets loader plugins take care of transpiling the source. Here's the code to configure Aurelias' ViewLocator for Jade: Configuring the Fallback View Location Strategy In addition to customizing the mapping logic of the ConventionalViewStrategy you can also replace the entire fallback view strategy. To do this, replace the createFallbackViewStrategy of the ViewLocator with your own implementation. Here's some sample code for that:"},{"articleName":"App Config and Startup","articleHref":"docs/fundamentals/app-configuration-and-startup","sectionName":"Logging","sectionId":"logging","id":1608,"text":"Aurelia has a simple logging abstraction that the framework itself uses. By default it is a no-op. The configuration in the above examples shows how to install an appender which will take the log data and output it to the console. Here's the code again, for convenience: You can also see how to set the log level. Values for the logLevel include: none, error, warn, info and debug. The above example uses our provided ConsoleAppender, but you can easily create your own appenders. Simply implement a class that matches the Appender interface from the logging library."},{"articleName":"Creating Components","articleHref":"docs/fundamentals/components","sectionName":"Creating A Component","sectionId":"creating-a-component","id":1609,"text":"In Aurelia, user interface components are composed of view and view-model pairs. The view is written with HTML and is rendered into the DOM. The view-model is written with ${context.language.name} and provides data and behavior to the view. The Templating Engine along with Dependency Injection are responsible for creating these pairs and enforcing a predictable lifecycle for the component. Once instantiated, Aurelia's powerful databinding links the two pieces together allowing changes in your view-model to be reflected in the view and changes in your view to reflected in your view-model. This Separation of Concerns is great for developer/designer collaboration, maintainability, architectural flexibility, and even source control. To create a UI component, you need only create two files, one for each of the component parts. Let's create a simple \"Hello\" component. To do that we'll need a hello${context.language.fileExtension} for our view-model and hello.html for our view. Here's the source for each: Notice that the view-model is a plain class. There's nothing remarkable about it. One of the strengths of Aurelia is that you can write so much of your application in vanilla JS. Also, notice how the view is wrapped in a Web Components HTMLTemplateElement. All views use standards-based HTML templates. You can also see the very simple, easy-to remember binding language. Simply append .bind to any HTML attribute in the DOM, and Aurelia will bind it to the corresponding property in your view-model. The .bind binding command configures the \"default binding behavior\" for the attribute. For most attributes, this is a one-way binding, where data updates only flow in one direction: from the view-model to the view. However, usually, the behavior you want for form controls is two-way binding so that data not only flows from your view-model into your view, but user input in the view flows back into your view-model. Those are the defaults, but you can always be explicit about the binding direction by using .one-way, two-way or .one-time in place of .bind (.one-time renders the initial value of the property but does not perform synchronization thereafter, making it a nice memory and performance gain for data you know will not change). In addition to binding HTML attributes, you can also bind events. Any event, either native or custom, can be bound using .trigger this causes the expression to be invoked when the indicated event is fired. Info You can read more about data binding in the various Binding articles. Now you know how to build basic components. What's great about this knowledge? It's consistent throughout Aurelia. The same pattern as above is used to create your app's root component, screens that the router navigates to, custom elements, dynamically composed UI components, modal dialogs, etc."},{"articleName":"Creating Components","articleHref":"docs/fundamentals/components","sectionName":"Component Instantiation Through Dependency Injection (DI)","sectionId":"component-instantiation-through-dependency-injection-di","id":1610,"text":"View-models and other interface elements, such as Custom Elements and Custom Attributes, are created as classes which are instantiated by the framework using a dependency injection container. Code written in this style is easy to modularize and test. Rather than creating large classes, you can break things down into small objects that collaborate to achieve a goal. The DI can then put the pieces together for you at runtime. In order to leverage DI, you simply decorate your class to tell the framework what it should pass to its constructor. Here's an example of a CustomerDetail component that depends on Aurelia's fetch client. If you are using ES2016, use the inject decorator. It should pass a list of types to provide instances of. There should be one argument for each constructor parameter. In the above example, we needed an HttpClient instance, so we added the HttpClient type in the inject decorator and then added a corresponding parameter in the constructor. If you are sticking with ES2015, or don't want to use decorators, you can also add a static inject method to the class that returns an array of types to inject. If you are using TypeScript >= 1.5, you can add the @autoinject decorator to your class and leave out the Types in the decorator call, but just use them on the constructor's signature."},{"articleName":"Creating Components","articleHref":"docs/fundamentals/components","sectionName":"The Component Lifecycle","sectionId":"the-component-lifecycle","id":1611,"text":"All components have a well-defined lifecycle. Below is a list of methods you can implement on your view-model in order to hook into the component lifecycle: constructor() - The view-model's constructor is called first. created(owningView: View, myView: View) - If the view-model implements the created callback it is invoked next. At this point in time, the view has also been created and both the view-model and the view are connected to their controller. The created callback will receive the instance of the \"owningView\". This is the view that the component is declared inside of. If the component itself has a view, this will be passed second. bind(bindingContext: Object, overrideContext: Object) - Databinding is then activated on the view and view-model. If the view-model has a bind callback, it will be invoked at this time. The \"binding context\" to which the component is being bound will be passed first. An \"override context\" will be passed second. The override context contains information used to traverse the parent hierarchy and can also be used to add any contextual properties that the component wants to add. attached() - Next, the component is attached to the DOM (in document). If the view-model has an attached callback, it will be invoked at this time. detached() - If defined on your view-model - is invoked after the component has been removed from the DOM. Due to navigating away or other reasons. unbind() - After a component is detached, it's usually unbound. If your view-model has the unbind callback, it will be invoked during this process. Each of these callbacks is optional. Implement whatever makes sense for your component, but don't feel obligated to implement any of them if they aren't needed for your scenario. Usually, if you implement bind you will need to implement unbind. The same goes for attached and detached, but again, it isn't mandatory. The order in which the lifecycle hooks are listed above matches the order in which they are invoked. For example, bind happens before attached to ensure elements take their initial state from the view-model before the view is attached to the DOM and transitioned in. Likewise, detached happens before unbind to ensure the view is transitioned out and detached from the DOM before unbind potentially causes the view to change. Info It is important to note that if you implement the bind callback function, then the property changed callbacks for any bindable properties will not be called when the property value is initially set. The changed callback will be called for any subsequent time the bound value changes."},{"articleName":"Dependency Injection","articleHref":"docs/fundamentals/dependency-injection","sectionName":"Introduction","sectionId":"introduction","id":1612,"text":"When building applications, it's often necessary to take a \"divide and conquer\" approach by breaking down complex problems into a series of simpler problems. In an object-oriented world, this translates to breaking down complex objects into a series of smaller objects, each focusing on a single concern, and collaborating with the others to form a complex system and model its behavior. A dependency injection container is a tool that can simplify the process of decomposing such a system. Often times, when developers go through the work of destructuring a system, they introduce a new complexity of \"re-assembling\" the smaller parts again at runtime. This is what a dependency injection container can do for you, using simple declarative hints."},{"articleName":"Dependency Injection","articleHref":"docs/fundamentals/dependency-injection","sectionName":"Injection","sectionId":"injection","id":1613,"text":"Let's say we have a CustomerEditScreen that needs to load a Customer entity by ID from a web service. We wouldn't want to place all the details of our AJAX implementation inside our CustomerEditScreen class. Instead, we would want to factor that into a CustomerService class that our CustomerEditScreen, or any other class, can use when it needs to load a Customer. Aurelia's dependency injection container lets you accomplish this by declaring that the CustomerEditScreen needs to have a CustomerService injected at creation time. The mechanism for declaring a class's dependencies depends on the language you have chosen to author your application with. Typically, you would use Decorators, an ES Next feature supported by both Babel and TypeScript. Here's what it looks like to declare that the CustomerEditScreen needs a CustomerService: Notice that we use the inject decorator and that the constructor signature matches the list of dependencies in the inject decorator. This tells the DI that any time it wants to create an instance of CustomerEditScreen it must first obtain an instance of CustomerService which it can inject into the constructor of CustomerEditScreen during instantiation. You can have as many injected dependencies as you need. Simply ensure that the inject decorator and the constructor match one another. Here's a quick example of multiple dependencies: Info To use Decorators in Babel, you need the babel-plugin-transform-decorators-legacy plugin. To use them in TypeScript, you need to add the \"experimentalDecorators\": true setting to the compilerOptions section of your tsconfig.json file. Aurelia projects typically come with these options pre-configured. If you are using TypeScript, you can take advantage of an experimental feature of the language to have the TypeScript transpiler automatically provide Type information to Aurelia's DI. You can do this by configuring the TypeScript compiler with the \"emitDecoratorMetadata\": true option in the compilerOptions section of your tsconfig.json file. If you do this, you don't need to duplicate the type information with inject, instead, as long as your constructor definition contains its parameters' types, you can use Aurelia's autoinject decorator like this: Info Interestingly, you don't need to use our autoinject decorator at all to get the above to work. The TypeScript compiler will emit the type metadata if any decorator is added to the class. Aurelia can read this metadata regardless of what decorator triggers TypeScript to add it. We simply provide the autoinject decorator for consistency and clarity. If you aren't using Babel's or TypeScript's decorator support (or don't want to), you can easily provide inject metadata using a simple static method or property on your class: In addition to a static inject method, a static inject property is also supported. In fact, the inject decorator simply sets the static property automatically. It's just syntax sugar. If you wanted to use decorators, but didn't want to use Aurelia's decorator, you could even create your own to set this same property. The nice thing about dependency injection is that it works in a recursive fashion. For example, if class A depends on class B, and class B depends on classes C and D, and class D depends on E, F and G, then creating class A will result in the resolution of all the classes in the hierarchy that are needed."},{"articleName":"Dependency Injection","articleHref":"docs/fundamentals/dependency-injection","sectionName":"Object Lifetime, Child Containers and Default Behavior","sectionId":"object-lifetime-child-containers-and-default-behavior","id":1614,"text":"Each object created by the dependency injection container has a \"lifetime\". There are three lifetime behaviors that are typical: Container Singleton - A singleton class, A, is instantiated when it is first needed by the DI container. The container then holds a reference to class A's instance so that even if no other objects reference it, the container will keep it in memory. When any other class needs to inject A, the container will return the exact same instance. Thus, the instance of A has its lifetime connected to the container instance. It will not be garbage collected until the container itself is disposed and no other classes hold a reference to it. Application Singleton - In Aurelia, it's possible to have child DI containers created from parent containers. Each of these child containers inherits the services of the parent, but can override them with their own registrations. Every application has a root DI container from which all classes and child containers are created. An application singleton is just like a container singleton, except that the instance is referenced by the root DI container in the application. This means that the root and all child containers will return the same singleton instance, provided that a child container doesn't explicitly override it with its own registration. Transient - Any DI container can create transient instances. These instances are created each time they are needed. The container holds no references to them and always creates a new instance for each request. Any class can be registered in a container as singleton or transient (or custom). We'll look at explicit configuration in the next section. Most classes in your application, however, are auto-registered by Aurelia. That is, there is no upfront configuration, but when an instance of class A is first needed, it is registered automatically at that point in time and then immediately resolved to an instance. What does this process look like? Let's look at a couple of examples to see how things work in practice. Example 1 - Root Container Resolution Imagine that we have a single instance of Container called root. If a developer (or Aurelia) invokes root.get(A) to resolve an instance of A, the root will first check to see if it has a Resolver for A. If one is found, the Resolver is used to get the instance, which is then returned to the developer. If one is not found, the container will auto-register a Resolver for A. This resolver is configured with a singleton lifetime behavior. Immediately after auto-registration, the Resolver is used to get the instance of A which is returned to the developer. Subsequent calls to root.get(A) will now immediately find a Resolver for A which will return the singleton instance. Example 2 - Child Container Resolution Now, imagine that we have a Container named root and we call root.createChild() to create a child container named child. Then, we invoke child.get(A) to resolve an instance of A. What will happen? First, child checks for a Resolver for A. If none is found, then it calls get(A) on its parent which is the root container from which it was created. root then checks to see if it has a Resolver. If not, it auto-registers A in root and then immediately calls the Resolver to get an instance of A. Example 3 - Child Container Resolution with Override Let's start with an instance of Container named root. We will then call root.createChild() to create a child container named child. Next we will call child.createChild() to create a grandchild container from it named grandchild. Finally, we'll call child.registerSingleton(A, A). What happens when we call grandchild.get(A)? First, grandchild checks for a Resolver. Since it doesn't find one, it delegates to its parent which is the child from which it was created. child then checks for a Resolver. Since child.registerSingleton(A, A) was called on child this means that child will have a Resolver for A. At this point child's resolver is used to get an instance of A which is returned to the developer. As you can see from these examples, the Container basically walks its hierarchy until it either finds a Resolver or reaches the root. If no Resolver is found in the root, it auto-registers the class as a singleton in the root. This means that all auto-registered classes are application-wide singletons, unless they are overriden by a child container."},{"articleName":"Dependency Injection","articleHref":"docs/fundamentals/dependency-injection","sectionName":"How Aurelia Uses Containers","sectionId":"how-aurelia-uses-containers","id":1615,"text":"Aurelia makes extensive use of DI throughout the framework. All view-models, components, services, etc. are created with DI. Aurelia also makes heavy use of child containers. The key to understanding the lifetime of your objects is in knowing how Aurelia uses child containers. There are basically three cases where child containers get created and used by Aurelia, all essentially having to do with components. Custom Elements and Custom Attributes When Aurelia creates a View, that view may contain occurrences of custom elements and custom attributes. Any time an HTML element is found to either be a custom element or have custom attributes, Aurelia creates a child container for that element, parented to the closest custom element container (or the view itself). It then manually registers the elements/attributes in the child container as singletons. This ensures that the elements and attributes aren't singletons at the application level or even the view level, which would not make sense. Instead, they are scoped to their location in the DOM. As a result of this, the HTML behaviors have access to classes registered above them in the DOM and on the same element. Likewise, they can be injected into classes that are created through their child element containers. Info Aurelia does not create child containers when there are plain HTML elements, or elements with only binding expressions, value converters, etc. It only creates them when the element itself is a custom element or if the element has custom attributes. Warning Despite that fact that the child container hierarchy is present in the DOM, you should be very wary of creating structural coupling between components in this way. The child container mechanism primarily exists to provide override services needed by custom elements and attributes such as Element/DOM.Element, BoundViewFactory, ViewSlot, ElementEvents/DOM.Events, ViewResources and TargetInstruction. Routed Components Each time the Router navigates to a screen, it creates a child container to encapsulate all the resources related to that navigation event and then auto-registers the screen's view-model in that child container. As you know, auto-registration, by default, results in the view-model being registered as a singleton. However, it is possible to override this with explicit configuration, unlike custom elements and custom attributes, which are always container singletons. Dynamic Components Dynamic composition, whether through the <compose> element or through the CompositionEngine, also creates child containers with auto-registration behavior, just like the Router. In fact, the RouteLoader simply calls the CompositionEngine internally to do the heavy lifting. The General Rule for Aurelia Everything is an application-level singleton except for those things which are classified as \"components\", essentially  custom elements, custom attributes and view-models created through the router or composition engine. You can change the lifetime of router and composition created components through explicit configuration."},{"articleName":"Dependency Injection","articleHref":"docs/fundamentals/dependency-injection","sectionName":"Explicit Configuration","sectionId":"explicit-configuration","id":1616,"text":"For the most part, Aurelia's DI will do what you want with object lifetime. However, you may desire to change the behavior of individual classes for the specific needs of your application. This is easy to do by either directly using the Container API or by decorating your class with a Registration. The Container Registration API The usual way to configure a class's lifetime is to use the Container API directly. Typically, you will want to do this configuration up-front in your application's main configure method. The Aurelia instance that is provided during configuration has a container property which points to the root DI container for your application. Recall that any Resolver configured at the application root will apply unless a child container has explicitly overriden the behavior. Here's a survey of the registration APIs you have available through a Container instance: container.registerSingleton(key: any, fn?: Function): void - This method allows you to register a class as a singleton. This is the default, as discussed above, so there's rarely a reason to call this method. It is provided in the API for completeness. When calling, provide the key that will be used to look up the singleton and the class which should be used. It's common for the key and class to be the same. If they are the same, then only the key needs to be provided. Here are some examples: container.registerSingleton(History, BrowserHistory); container.registerSingleton(HttpClient); container.registerTransient(key: any, fn?: Function): void - This method allows you to register a class as transient. This means that every time the container is asked for the key, it will return a brand new instance of the class. As with the singleton behavior, the key is requried but the class is optional. If left off, the key will be treated as the class to be instantiated. Here's an example of using transient registration: container.registerTransient(LinkHandler, DefaultLinkHandler); container.registerInstance(key: any, instance?: any): void - If you already have an existing instance, you can add that to the container with this method. You just need to pick a key that the instance will be retrievable by. If no key is provided then the key becomes the instance. container.registerHandler(key: any, handler: (container?: Container, key?: any, resolver?: Resolver) => any): void - In addition to simply declaring behaviors, you can also provide a custom function (a handler) that will respond any time the container is queried for the key. This custom handler has access to the container instance, the key and the internal resolver which stores the handler. This enables just about any sort of custom lifetime to be implemented by supplying a custom function. Here's an example: container.registerHandler('Foo', () => new Bar()); container.registerResolver(key: any, resolver: Resolver): void - You can also register a custom Resolver instance for the key. Under the hood, all previously discussed methods translate to using a built-in Resolver instance. However, you can always supply your own. We'll discuss this in more detail in the DI customization article. container.autoRegister(fn: any, key?: any): Resolver - As you know, if a container can't find a registration during its resolution stage, it will auto-register the requested type. That is done internally through the use of autoRegister. However, you can use it yourself to auto-register a type with a particular container instance. By default, this will result in a singleton registration, on the container this API is called on. However, if the type has registration decorators, that could provide an alternate registration. Whatever Resolver is established during auto-registration will be returned. Info: Registration Keys All registration APIs take a key. This key is typically the class itself (for convenience). However, the key can be any type, including strings and objects. This is possible because Aurelia's DI implementation uses a Map object to correlate a key to a Resolver. When using class-oriented registration APIs, if the key is not a class, you must provide the class to be created as the second argument to the API call. Registration Decorators As an alternative to explicitly registering types with the container, you can rely on auto-registration, but specify the auto-registration behavior you desire, overriding the default container-root-singleton behavior. To provide auto-registration behavior, you simply decorate your type with an auto-registration decorator. What follows is a basic explanation of built-in registration decorators: transient() - Simply decorate your class with transient() and when it's requested from the container, a new instance will be created for each request. singleton(overrideChild?:boolean) - Normally, types are auto-registered as singletons in the root container. So, why do we provide this decorator? This decorator allows you to specify true as an argument to indicate that the singleton should be registered not in the root container, but in the immediate container to which the initial request was issued. registration(registration: Registration) - In addition to the built-in singleton and transient registrations, you can create your own and associate it with a class. We'll discuss this in more detail in the DI customization article. Warning: Registration Decorator Usage At present, the Decorators spec allows for decorators to use parens or not depending on whether or not the decorator requires arguments. This means that decorator invocation is dependent on how the decorator was implemented internally, which can be confusing from time to time. As a result of the way that the registration decorators are implemented, you must use them with parens."},{"articleName":"Dependency Injection","articleHref":"docs/fundamentals/dependency-injection","sectionName":"Resolvers","sectionId":"resolvers","id":1617,"text":"As mentioned above, the DI container uses Resolvers internally to provide all instances. When explicitly configuring the container, you are actually specifying what Resolver should be associated with a particular lookup key. However, there's a second way that resolvers are useful. Instead of supplying a key as part of the inject decorator, you can provide a Resolver instead. This resolver then communicates with the container to provide special resolution behavior, specific to the injection. Here's a list of the resolvers you can use in this capacity: Lazy - Injects a function for lazily evaluating the dependency. ex. Lazy.of(HttpClient) All - Injects an array of all services registered with the provided key. ex. All.of(Plugin) Optional - Injects an instance of a class only if it already exists in the container; null otherwise. ex. Optional.of(LoggedInUser) Parent - Skips starting dependency resolution from the current container and instead begins the lookup process on the parent container. ex. Parent.of(MyCustomElement) Factory - Used to allow injecting dependencies, but also passing data to the constructor. ex. Factory.of(CustomClass) NewInstance - Used to inject a new instance of a dependency, without regard for existing instances in the container. ex. NewInstance.of(CustomClass).as(Another) If using TypeScript, keep in mind that @autoinject won't allow you to use Resolvers. Instead, you may use argument decorators, without duplicating argument order, which you otherwise have to maintain when using the class decorator or the static inject property. You also can use inject as argument decorator for your own custom resolvers, eg constructor(@inject(NewInstance.of(HttpClient)) public client: HttpClient){...}. Available build-in function parameter decorators are: lazy(key) all(key) optional(checkParent?) parent factory(key) newInstance(asKey?, dynamicDependencies: [any]) Here's an example of how we might express a dependency on HttpClient that we may or may not actually need to use, depending on runtime scenarios: In this case, the Lazy resolver doesn't actually provide an instance of HttpClient directly. Instead, it provides a function that can be invoked at some point in the future to obtain an instance of HttpClient if needed. "},{"articleName":"Securing Your App","articleHref":"docs/fundamentals/security","sectionName":"Introduction","sectionId":"introduction","id":1618,"text":"The first rule of securing client-side applications: the client cannot be trusted. Your backend should never trust the input coming from the front-end, under any circumstance. Malicious individuals often know how to use browser debug tools and manually craft HTTP requests to your backend. You may even find yourself in a situation where a disgruntled employee (or former employee), who is a developer with intimate knowledge of the system, is seeking revenge by attempting a malicious attack. Your primary mechanism for securing any SPA application, Aurelia or otherwise, is to work hard on securing your backend services. Danger: Security Advice This article, more or less, contains only a few quick warnings. It is in no way exhaustive, nor should it be your only resource on securing your application. The bulk of the work in security relates to your server-side technology. You should spend adequate time reading up on and understanding security best practices for whatever backend tech you have chosen."},{"articleName":"Securing Your App","articleHref":"docs/fundamentals/security","sectionName":"Authentication and Authorization","sectionId":"authentication-and-authorization","id":1619,"text":"When designing your application, consider which backend API calls can be made anonymously, which require a logged-in user and which roles or permissions are required for various authenticated requests. Ensure that your entire API surface area is explicitly covered in this way. Your front-end can facilitate the login process, but ultimately this is a backend task. Here are a few related recommendations: Make sure your server is configured to transmit sensitive resources over HTTPS. You may want to transmit all resources this way. It is more server-intensive, but it will be more secure. You must decide what is appropriate for your application. Don't transmit passwords in plain text. There are various ways to accomplish CORS. Prefer to use a technique based on server-supported CORS, rather than client-side hacks. Control cross-domain requests to your services. Either disallow them or configure your server based on a strict whitelist of allowed domains. Require strong passwords Never, ever store passwords in plain text. Do not allow an endless number of failed login attempts to the same account. Consider outsourcing your auth requirements to a cloud provider with greater expertise. You can improve the user-experience by plugging into Aurelia's router pipeline with your security specifics. Again, remember, this doesn't secure your app, but only provides a smooth user experience. The real security is on the backend. Here's a quick example of how you might use Aurelia's router to disallow client-side routes based on user role: Info: Route Settings Developers can add a settings property to any route configuration object and use it to store any data they wish to associate with the route. The value of the settings property will be preserved by Aurelia's router and also copied to the navigation model."},{"articleName":"Securing Your App","articleHref":"docs/fundamentals/security","sectionName":"Validation and Sanitization","sectionId":"validation-and-sanitization","id":1620,"text":"The backend should always perform validation and sanitization of data. Do not rely on your client-side validation and sanitization code. In reality, your client-side validation/santization code should not be seen as anything more than a User Experience enhancement, designed to aid honest users. It will have no affect on anyone who is malicious. Here's a few things you should do though: Use client-side validation. This will make your users happy. Avoid data-binding to innerHTML. If you do, be sure to use a value converter to sanitize the input from the user. Be extra careful anytime you are dynamically creating and compiling client-side templates based on user input. Be extra careful anytime you are dynamically creating templates on the server based on user input, which will later be processed by Aurelia on the client. Info: We Are Trying To Help You Internally, Aurelia makes no use of eval or the Function constructor. Additionally, all binding expressions are parsed by our strict parser which does not make globals like window or document available in binding expressions. We've done this to help prevent some common abuses."},{"articleName":"Securing Your App","articleHref":"docs/fundamentals/security","sectionName":"Secret Data","sectionId":"secret-data","id":1621,"text":"Do not embed private keys into your JavaScript code. While the average user may not be able to access them, anyone with true ill intent can simply download your client code, un-minifiy it and use basic regular expressions on the codebase to find things that look like sensitive data. Perhaps they've discovered what backend technology you are using or what cloud services your product is based on simply by studying your app's HTTP requests or looking at the page source. Using that information they may be able to refine their search based on certain patterns well-known to users of those technologies, making it easier to find your private keys. If you have a need to acquire any secret data on the client, it should be done with great care. Here is a (non-exhaustive) list of recommendations: Always use HTTPS to transmit this information. Restrict which users and roles can acquire this information to an absolute minimum. Always use time-outs on any secret keys so that, at most, if an attacker gains access, they can't use them for long. Be careful how you store these values in memory. Do not store these as class property values or on any object that is linked to the DOM through data-binding or otherwise. Doing so would allow an attacker to gain access to the information through the debug console. If you must store this information, keep it inside a private (non-exported) module-level variable. If you need to store this information anywhere, encrypt it first."},{"articleName":"Securing Your App","articleHref":"docs/fundamentals/security","sectionName":"Deployment","sectionId":"deployment","id":1622,"text":"When deploying your apps, there are a few things you can do to make it more difficult for attackers to figure out how your client works: Bundle your application and minify it. This is the most basic obfuscation you can do. Do not deploy the original client-side source files. Only deploy your bundled, minified app. For additional security or IP protection, you may want to look into products such as jscrambler."},{"articleName":"Securing Your App","articleHref":"docs/fundamentals/security","sectionName":"Prepare for the Inevitable","sectionId":"prepare-for-the-inevitable","id":1623,"text":"Even with the most skilled, security-proficient development team, your app will never be 100% protected. This is a fundamental assumption that you should have from the beginning. Expect to be attacked and expect someone to succeed at some point in time. What will you do if this happens? How will you respond? Will you be able to track down the culprit? Will you be able to identify the issue and quickly seal up the breach? You need a plan. Again, most of this come down to server-side implementation. Here are a few basic ideas: Configure server-side logging and make sure it will provide you with useful information. Such information can be very helpful in tracking down how an attack was performed. Make sure you have tools available to you to quickly search through your logs. Make sure that all logins are logged. If you are using an auth-token scheme, make sure that all requests log this information. Never log sensitive data. Consider timing out logins or auth tokens. You can provide refresh mechanisms in order to help the user experience. Configure server insight tooling so that threats can be detected earlier."},{"articleName":"Securing Your App","articleHref":"docs/fundamentals/security","sectionName":"Do Not Be Nice to Bad Guys","sectionId":"do-not-be-nice-to-bad-guys","id":1624,"text":"Be careful what information you give out, especially when something goes wrong. For example, if there's a failed login attempt, do not tell the user whether they got their username or password incorrect. That's too much information. Just tell them they had an incorrect login. Furthermore, be careful with what error information you send to end-users. You should keep detailed, internal error logs, but most of that information should not be sent to the end user. Too much information can help an attacker take a step closer to causing real damage. Beyond this, you are under no obligation to provide nice messages of any kind when you know a user is doing something malicious. Just let the application crash. It's fitting for them."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"Introduction","sectionId":"introduction","id":1625,"text":"This article covers the basics of data-binding with Aurelia. You'll learn how to bind to HTML attributes, DOM Events and element content. You'll also see how to give your view-models references to DOM elements, making it easy work with elements directly."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"HTML and SVG Attributes","sectionId":"html-and-svg-attributes","id":1626,"text":"Aurelia supports binding HTML and SVG attributes to JavaScript expressions. Attribute binding declarations have three parts: attribute.command=\"expression\". attribute:  an HTML or SVG attribute name. command: one of Aurelia's attribute binding commands: one-time: flows data one direction: from the view-model to the view, once. to-view / one-way: flows data one direction: from the view-model to the view. from-view: flows data one direction: from the view to the view-model. two-way: flows data both ways: from view-model to view and from view to view-model. bind: automically chooses the binding mode. Uses two-way binding for form controls and to-view binding for almost everything else. expression: a JavaScript expression. Typically you'll use the bind command since it does what you intend most of the time.  Consider using one-time in performance critical situations where the data never changes because it skips the overhead of observing the view-model for changes. Below are a few examples. The first input uses the bind command which will automatically create two-way bindings for input value attribute bindings. The second and third input uses the two-way / from-view commands which explicitly set the binding modes. For the first and second inputs, their value will be updated whenever the bound view-model firstName / lastName properties are updated, and the those properties will also be updated whenever the inputs change. For the third input, changes in the bound view-model middleName property will not update the input value, however, changes in the input will update the view-model. The first anchor element uses the bind command which will automatically create a to-view binding for anchor href attributes. The other two anchor elements use the to-view and one-time commands to explicitly set the binding's mode."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"DOM Events","sectionId":"dom-events","id":1627,"text":"The binding system supports binding to DOM events.  A DOM event binding will execute a JavaScript expression whenever the specified DOM event occurs. Event binding declarations have three parts: event.command=\"expression\". event:  the name of a DOM event, without the \"on\" prefix. command: one of Aurelia's event binding commands: trigger: attaches an event handler directly to the element. When the event fires, the expression will be invoked. delegate: attaches a single event handler to the document (or nearest shadow DOM boundary) which handles all events of the specified type in bubbling phase, properly dispatching them back to their original targets for invocation of the associated expression. capture: attaches a single event handler to the document (or nearest shadow DOM boundary) which handles all events of the specified type in capturing phase, properly dispatching them back to their original targets for invocation of the associated expression. expression: a JavaScript expression. Use the special $event property to access the DOM event in your binding expression. Below are a few examples. The cancel button uses the trigger command to attach an event listener to the button element that will call the view-model's cancel method.  The yes and no buttons use the delegate command which will use the event delegation pattern.  The input elements have binding expressions that use the special $event property to access the DOM event. Aurelia will automatically call preventDefault() on events handled with delegate or trigger binding. Most of the time this is the behavior you want. To turn this off, return true from your event handler function."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"Function References","sectionId":"function-references","id":1628,"text":"While developing custom elements or custom attributes you may encounter a situation where you have a @bindable property that expects a reference to a function. Use the call binding command to declare and pass a function to the bindable property. The call command is superior to the bind command for this use-case because it will execute the function in the correct context, ensuring this is what you expect it to be. Your custom element or attribute can invoke the function that was passed to the @bindable property using standard call syntax: this.go();. If you need to invoke the function with arguments, create an object whose keys are the argument names and whose values are the argument values, then invoke the function with this \"arguments object\". The object's properties will be available for data-binding in the call binding expression.  For example, invoking the function with this.go({ x: 5, y: -22, z: 11})) will make x, y and z available for binding:"},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"Referencing Elements","sectionId":"referencing-elements","id":1629,"text":"Use the ref binding command to create a reference to a DOM element. The ref command's most basic syntax is ref=\"expression\". When the view is data-bound the specified expression will be assigned the DOM element. The ref command has several qualifiers you can use in conjunction with custom elements and attributes: element.ref=\"expression\": create a reference to the DOM element (same as ref=\"expression\"). attribute-name.ref=\"expression\": create a reference to a custom attribute's view-model. view-model.ref=\"expression\": create a reference to a custom element's view-model. view.ref=\"expression\": create a reference to a custom element's view instance (not an HTML Element). controller.ref=\"expression\": create a reference to a custom element's controller instance."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"String Interpolation","sectionId":"string-interpolation","id":1630,"text":"String interpolation expressions enable interpolating (surprise!) the result of an expression with text.  The best way to demonstrate this capability is with an example. Below are two span elements with data-bound textcontent: The first span uses the bind command. The second uses string interpolation.  The interpolated version is much easier to read and easy to remember because the syntax matches the template literal syntax standardized in ES2015/ES6. String interpolation can be used within html attributes as an alternative to to-view binding. By default, the mode of an interpolation binding is to-view and the result of the expression is always coerced to a string. Results that are null or undefined will result in empty string."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"Element Content","sectionId":"element-content","id":1631,"text":"The previous example compared string interpolation binding with textcontent.bind. Interpolation is easier to read but textcontent.bind can come in handy when you need to two-bind a contenteditable element: You may also need to bind html text to an element's innerHTML property: Danger Always use HTML sanitization. We provide a simple converter that can be used. You are encouraged to use a more complete HTML sanitizer such as sanitize-html. Warning Binding using the innerhtml attribute simply sets the element's innerHTML property.  The markup does not pass through Aurelia's templating system.  Binding expressions and require elements will not be evaluated."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"Contextual Properties","sectionId":"contextual-properties","id":1632,"text":"The binding system makes several properties available for binding in your templates, depending on the context. $this - The binding context (the view-model). $parent - Explicitly accesses the outer scope from within a compose or repeat template. You may need this when a property on the current scope masks a property on the outer scope. Chainable- eg $parent.$parent.foo is supported. $event - The DOM Event in delegate or trigger bindings. $index - In a repeat template, the index of the item in the collection. $first - In a repeat template, is true if the item is the first item in the array. $last - In a repeat template, is true if the item is the last item in the array. $even - In a repeat template, is true if the item has an even numbered index. $odd - In a repeat template, is true if the item has an odd numbered index."},{"articleName":"Binding Basics","articleHref":"docs/binding/basics","sectionName":"Expression Syntax","sectionId":"expression-syntax","id":1633,"text":"Aurelia's expression parser implements a subset of ECMAScript Expressions. For the features that are supported, you can typically expect the JavaScript in your view to work the same way as it would in your view model, or in the browser console. In addition there are two adjustments: The Ampersand & represents a BindingBehavior (instead of Bitwise AND) The Bar | represents a ValueConverter (instead of a Bitwise OR) Non-expression syntax (statements, declarations, function and class definitions) is not supported. As an overview of various expressions that are possible, the following list is for illustrative purposes and not exhaustive (and not necessarily recommended, either), but should give you a fairly good idea of what you can do: Primary Expressions Identifiers foo - The foo variable in the current view-model  - The  variable in the current view-model Info non-ASCII characters in the Latin script are supported. This script contains 1,350 characters covering the vast majority of languages. Other Non-BMP characters / Surrogate Pairs are not supported. Identifiers with special meaning in Aurelia $this - The current view-model $parent - The parent view-model Primitive literals true - The literal value true false - The literal value false null - The literal value null undefined - The literal value undefined String literals and escape sequences 'foo' or \"foo\" - The literal string foo '\\n' - The literal string [NEWLINE] '\\t' - The literal string [TAB] '\\'' - The literal string ' '\\\\' - The literal string \\ '\\\\n' - The literal string \\n '\\u0061' - The literal string a Warning Unsupported string literals include '\\x61' (2-point hex escape), '\\u{61}' or '\\u{000061}' (n-point braced unicode escape), and Non-BMP characters and Surrogate Pairs. Template literals `foo` - Equivalent to 'foo' `foo${bar}baz${qux}quux` - Equivalent to 'foo'+bar+'baz'+qux+'quux' Numeric literals 42 - The literal number 42 42. or 42.0 - The literal number 42.0 .42 or 0.42 - The literal number 0.42 42.3 - The literal number 42.3 10e3 or 10E3 - The literal number 1000 Warning Unsupported numeric literals include 0b01 (binary integer literal), 0o07 (octal integer literal), and 0x0F (hex integer literal). Array literals [] - An empty array [1,2,3] - An array containing the literal numbers 1, 2 and 3 [foo, bar] - An array containing the variables foo and bar [[]] - An array containing an empty array Warning Unsupported array literals include [,] - Elision Object literals {} - An empty object {foo} or {foo,bar} - ES6 shorthand notation, equivalent to {'foo':foo} or {'foo':foo,'bar':bar} {42:42} - Equivalent to {'42':42} Warning Unsupported object literals include {[foo]: bar} or {['foo']: bar} (computed property names). Unary expressions foo here represents any valid primary expression or unary expression. +foo or +1 - Equivalent to foo or 1 (the + unary operator is always ignored) -foo or -1 - Equivalent to 0-foo or 0-1 !foo - Negates foo typeof foo - Returns the primitive type name of foo void foo - Evaluates foo and returns undefined Warning Unary increment (++foo or foo++), decrement (--foo or foo--), bitwise (~), delete, await and yield operators are not supported. Binary expressions (from highest to lowest precedence) a and b here represent any valid primary, unary or binary expression. a*b or a/b or a%b - Multiplicative a+b or a-b - Additive a<b or a>b or a<=b or a>=b or a in b or a instanceof b - Relational a==b or a!=b or a===b or a!==b - Equality a&&b - Logical AND a||b - Logical OR Warning Exponentiation (a**b) and bitwise operators are not supported. Conditional expressions foo etc here represent any valid primary, unary, binary or conditional expression. foo ? bar : baz foo ? bar : baz ? qux : quux Assignment expressions foo here must be an assignable expression (a simple accessor, a member accessor or an indexed member accessor). bar can any valid primary, unary, binary, conditional or assignment expression. foo = bar foo = bar = baz Member and Call expressions Member expressions with special meaning in Aurelia: $parent.foo - Access the foo variable in the parent view-model $parent.$parent.foo - Access the foo variable in the parent's parent view-model $this - Access the current view-model (equivalent to simply this inside the view-model if it's an ES class) Normal member and call expressions: foo here represents any valid member, call, assignment, conditional, binary, unary or primary expression (provided the expression as a whole is also valid JavaScript). foo.bar - Member accessor foo['bar'] - Keyed member accessor foo() - Function call foo.bar() - Member function call foo['bar']() - Keyed member function call Tagged template literals: foo here should be a function that can be called. The string parts of the template are passed as an array to the first argument and the expression parts are passed as consecutive arguments. foo`bar` - Equivalent to foo(['bar']) foo`bar${baz}qux` - Equivalent to foo(['bar','qux'], baz) foo`bar${baz}qux${quux}corge` - Equivalent to foo(['bar','qux','corge'],baz,quux) foo`${bar}${baz}${qux}` - Equivalent to foo(['','','',''],bar,baz,qux) Binding Behaviors and Value Converters These are not considered to be a part of normal expressions and must always come at the end of an expression (though multiple can be chained). Furthermore, BindingBehaviors must come after ValueConverters. (note: BindingBehavior and ValueConverter are abbreviated to BB and VC for readability) Valid BB expressions: foo & bar & baz - Applies the BB bar to the variable foo, and then applies the BB baz to the result of that. foo & bar:'baz' - Applies the BB bar to the variable foo, and passes the literal string 'baz' as an argument to the BB foo & bar:baz:qux - Applies the BB bar to the variable foo, and passes the variables baz and qux as arguments to the BB 'foo' & bar - Applies the BB bar to the literal string 'foo' Valid VC expressions (likewise): foo | bar | baz foo | bar:'baz' foo | bar:baz:qux 'foo' | bar Combined BB and VC expressions: foo | bar & baz foo | bar:42:43 & baz:'qux':'quux' foo | bar | baz & qux & quux Invalid combined BB and VC expressions (BB must come at the end): foo & bar | baz foo | bar & baz | qux"},{"articleName":"Class and Style","articleHref":"docs/binding/class-and-style","sectionName":"Class","sectionId":"class","id":1634,"text":"You can bind an element's class attribute using string interpolation or with .bind/.to-view. To ensure maximum interoperability with other JavaScript libraries, the binding system will only add or remove classes specified in the binding expression. This ensures classes added by other code (eg via classList.add(...)) are preserved. This \"safe by default\" behavior comes at a small cost but can be noticeable in benchmarks or other performance critical situations like repeats with lots of elements. You can opt out of the default behavior by binding directly to the element's className property using class-name.bind=\"....\" or class-name.one-time=\"...\". This will be marginally faster but can add up over a lot of bindings."},{"articleName":"Class and Style","articleHref":"docs/binding/class-and-style","sectionName":"Style","sectionId":"style","id":1635,"text":"You can bind a css string or object to an element's style attribute. Use css custom attribute when doing string interpolation in your view to ensure your application is compatible with Internet Explorer and Edge. If you don't use interpolation in css - it won't get processed, so if you are just using inline style - use the proper style attribute of HTMLElement."},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Configuration and Startup","sectionId":"configuration-and-startup","id":1636,"text":"Warning: Promises in Edge Currently, the Edge browser has a serious performance problem with its Promise implementation. This deficiency can greatly increase startup time of your app. If you are targeting the Edge browser, it is highly recommended that you use the bluebird promise library to replace Edge's native implementation. You can do this by simply referencing the library prior to loading system.js."},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Creating Components","sectionId":"creating-components","id":1637,"text":"UI components consist of two parts: a view-model and a view. Simply create each part in its own file. Use the same file name but different file extensions for the two parts. For example: hello${context.language.fileExtension} and hello.html. The Component Lifecycle Components have a well-defined lifecycle: constructor() - The view-model's constructor is called first. created(owningView: View, myView: View) - If the view-model implements the created callback it is invoked next. At this point in time, the view has also been created and both the view-model and the view are connected to their controller. The created callback will receive the instance of the \"owningView\". This is the view that the component is declared inside of. If the component itself has a view, this will be passed second. bind(bindingContext: Object, overrideContext: Object) - Databinding is then activated on the view and view-model. If the view-model has a bind callback, it will be invoked at this time. The \"binding context\" to which the component is being bound will be passed first. An \"override context\" will be passed second. The override context contains information used to traverse the parent hierarchy and can also be used to add any contextual properties that the component wants to add. It should be noted that when the view-model has implemented the bind callback, the databinding framework will not invoke the changed handlers for the view-model's bindable properties until the \"next\" time those properties are updated. If you need to perform specific post-processing on your bindable properties, when implementing the bind callback, you should do so manually within the callback itself. attached() - Next, the component is attached to the DOM (in document). If the view-model has an attached callback, it will be invoked at this time. detached() - At some point in the future, the component may be removed from the DOM. If/When this happens, and if the view-model has a detached callback, this is when it will be invoked. unbind() - After a component is detached, it's usually unbound. If your view-model has the unbind callback, it will be invoked during this process."},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Dependency Injection","sectionId":"dependency-injection","id":1638,"text":"Available Resolvers Lazy - Injects a function for lazily evaluating the dependency. ex. Lazy.of(HttpClient) All - Injects an array of all services registered with the provided key. ex. All.of(Plugin) Optional - Injects an instance of a class only if it already exists in the container; null otherwise. ex. Optional.of(LoggedInUser) Parent - Skips starting dependency resolution from the current container and instead begins the lookup process on the parent container. ex. Parent.of(MyCustomElement) Factory - Used to allow injecting dependencies, but also passing data to the constructor. ex. Factory.of(CustomClass) NewInstance - Used to inject a new instance of a dependency, without regard for existing instances in the container. ex. NewInstance.of(CustomClass).as(Another)"},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Templating Basics","sectionId":"templating-basics","id":1639,"text":"Info: Invalid Table Structure When Dynamically Creating Tables When the browser loads in the template it very helpfully validates the structure of the HTML, notices that you have an invalid tag inside your table definition, and very unhelpfully removes it for you before Aurelia even has a chance to examine your template. Use of the as-element attribute ensures we have a valid HTML table structure at load time, yet we tell Aurelia to treat its contents as though it were a different tag. For the above example we can then programmatically choose the embedded template based on an element of our data: Note that when a containerless attribute is used, the container is stripped after the browser has loaded the DOM elements, and as such this method cannot be used to transform non-HTML compliant structures into compliant ones!"},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Databinding","sectionId":"databinding","id":1640,"text":"bind, one-way, two-way  Use on any HTML attribute. .bind - Uses the default binding. One-way binding for everything but form controls, which use two-way binding. .one-way - Flows data one direction: from the view-model to the view. .two-way - Flows data both ways: from view-model to view and from view to view-model. .one-time - Renders data once, but does not synchronize changes after the initial render. Info At the moment inheritance of bindables is not supported. For use cases where class B extends A and B is used as custom Element/Attribute @bindable properties cannot be defined only on class A. If inheritance is used, @bindable properties should be defined on the instantiated class. delegate, trigger Use on any native or custom DOM event. (Do not include the \"on\" prefix in the event name.) .trigger - Attaches an event handler directly to the element. When the event fires, the expression will be invoked. .delegate - Attaches a single event handler to the document (or nearest shadow DOM boundary) which handles all events of the specified type, properly dispatching them back to their original targets for invocation of the associated expression. Info The $event value can be passed as an argument to a delegate or trigger function call if you need to access the event object. call Passes a function reference. ref Creates a reference to an HTML element, a component or a component's parts. ref=\"someIdentifier\" or element.ref=\"someIdentifier\" - Create a reference to the HTMLElement in the DOM. attribute-name.ref=\"someIdentifier\"- Create a reference to a custom attribute's view-model. view-model.ref=\"someIdentifier\"- Create a reference to a custom element's view-model. view.ref=\"someIdentifier\"- Create a reference to a custom element's view instance (not an HTML Element). controller.ref=\"someIdentifier\"- Create a reference to a custom element's controller instance. String Interpolation Used in an element's content. Can be used inside attributes, particularly useful in the class and css attributes. Binding to Select Elements A typical select element is rendered using a combination of value.bind and repeat. You can also bind to arrays of objects and synchronize based on an id (or similar) property. Binding Radios Binding Checkboxes Warning You cannot use a click.delegate on checkboxes if you want to attach a method to it. You need to use change.delegate. Binding innerHTML and textContent Danger Always use HTML sanitization. We provide a simple converter that can be used. You are encouraged to use a more complete HTML sanitizer such as sanitize-html. Warning Binding using the innerhtml attribute simply sets the element's innerHTML property.  The markup does not pass through Aurelia's templating system.  Binding expressions and require elements will not be evaluated. Binding Style You can bind a css string or object to an element's style attribute. Use the style attribute's alias, css when doing string interpolation to ensure your application is compatible with Internet Explorer. Declaring Computed Property Dependencies"},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Templating View Resources","sectionId":"templating-view-resources","id":1641,"text":"Contextual items available inside a repeat template: $index - The index of the item in the array. $first - True if the item is the first item in the array. $last - True if the item is the last item in the array. $even - True if the item has an even numbered index. $odd - True if the item has an odd numbered index. Info: Containerless Template Controllers The if and repeat attributes are usually placed on the HTML elements that they affect. However, you can also use a template tag to group a collection of elements that don't have a parent element and place the if or repeat on the template element instead."},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Routing","sectionId":"routing","id":1642,"text":"Route Pattern Options static routes ie 'home' - Matches the string exactly. parameterized routes ie  'users/:id/detail' - Matches the string and then parses an id parameter. Your view-model's activate callback will be called with an object that has an id property set to the value that was extracted from the url. wildcard routes ie 'files*path' - Matches the string and then anything that follows it. Your view-model's activate callback will be called with an object that has a path property set to the wildcard's value. The Route Screen Activation Lifecycle canActivate(params, routeConfig, navigationInstruction) - Implement this hook if you want to control whether or not your view-model can be navigated to. Return a boolean value, a promise for a boolean value, or a navigation command. activate(params, routeConfig, navigationInstruction) - Implement this hook if you want to perform custom logic just before your view-model is displayed. You can optionally return a promise to tell the router to wait to bind and attach the view until after you finish your work. canDeactivate() - Implement this hook if you want to control whether or not the router can navigate away from your view-model when moving to a new route. Return a boolean value, a promise for a boolean value, or a navigation command. deactivate() - Implement this hook if you want to perform custom logic when your view-model is being navigated away from. You can optionally return a promise to tell the router to wait until after you finish your work. Warning: Root Screen Activation Unlike the mapped routes, the root's view-model only has access to the activate() hook. However this can also be used to implement logic for attaching the component by returning a promise for a boolean value. The params object will have a property for each parameter of the route that was parsed, as well as a property for each query string value. routeConfig will be the original route configuration object that you set up. routeConfig will also have a new navModel property, which can be used to change the document title for data loaded by your view-model. For example: Configuring PushState Add a base tag to the head of your html document. If you're using JSPM, you will also need to configure it with a baseURL corresponding to your base tag's href. Finally, be sure to set the config.options.root to match your base tag's setting. Warning PushState requires server-side support. Don't forget to configure your server appropriately. Reusing an Existing View Model Since the view model's navigation lifecycle is called only once, you may have problems recognizing that the user switched the route from Product A to Product B (see below). To work around this issue implement the method determineActivationStrategy in your view model and return hints for the router about what you'd like to happen. Available return values are replace and invoke-lifecycle. Remember, \"lifecycle\" refers to the navigation lifecycle. Info Alternatively, if the strategy is always the same and you don't want that to be in your view model code, you can add the activationStrategy property to your route config instead. Rendering multiple ViewPorts Info If you don't name a router-view, it will be available under the name 'default'. Generating Route URLs"},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Custom Attributes","sectionId":"custom-attributes","id":1643,"text":""},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"Custom Elements","sectionId":"custom-elements","id":1644,"text":"Custom Element Without View-Model Declaration Aurelia will not search for a JavaScript file if you reference a component with an .html extension. Custom Element Variable Binding It's worth noting that when binding variables to custom elements, use camelCase inside the custom element's View-Model, and dash-case on the html element. See the following example: Custom Element Options @children(selector) - Decorates a property to create an array on your class that has its items automatically synchronized based on a query selector against the element's immediate child content. @child(selector) - Decorates a property to create a reference to a single immediate child content element. @processContent(false|Function) - Tells the compiler that the element's content requires special processing. If you provide false to the decorator, the compiler will not process the content of your custom element. It is expected that you will do custom processing yourself. But, you can also supply a custom function that lets you process the content during the view's compilation. That function can then return true/false to indicate whether or not the compiler should also process the content. The function takes the following form function(compiler, resources, node, instruction):boolean @useView(path) - Specifies a different view to use. @noView() - Indicates that this custom element does not have a view and that the author intends for the element to handle its own rendering internally. @inlineView(markup, dependencies?) - Allows the developer to provide a string that will be compiled into the view. @useShadowDOM() - Causes the view to be rendered in the ShadowDOM. When an element is rendered to ShadowDOM, a special DOMBoundary instance can optionally be injected into the constructor. This represents the shadow root. @containerless() - Causes the element's view to be rendered without the custom element container wrapping it. This cannot be used in conjunction with @child, @children or @useShadowDOM decorators. It also cannot be uses with surrogate behaviors. Use sparingly. SVG Elements SVG (scalable vector graphic) tags can support Aurelia's custom element <template> tags by  nesting the templated code inside a second <svg> tag. For example if you had a base <svg> element and wanted to add a templated <rect> inside it, you would first put your custom tag inside the main <svg> tag. Also, make sure the custom element class uses the @containerless() decorator. Template Parts Observable decorator Aurelia exposes a decorator named observable to allow watching for changes to a property and reacting to them.  By convention it will look for a matching method name ${name}Changed - The developer can also specify a different method name to use -"},{"articleName":"Cheat Sheet","articleHref":"docs/fundamentals/cheat-sheet","sectionName":"The Event Aggregator","sectionId":"the-event-aggregator","id":1645,"text":"If you include the aurelia-event-aggregator plugin using \"basicConfiguration\" or \"standardConfiguration\" then the singleton EventAggregator's API will be also present on the Aurelia object. You can also create additional instances of the EventAggregator, if needed, and \"merge\" them into any object. To do this, import includeEventsIn and invoke it with the object you wish to turn into an event aggregator. For example includeEventsIn(myObject). Now my object has publish and subscribe methods and can be used in the same way as the global event aggregator, detailed below."},{"articleName":"Binding Checkboxes","articleHref":"docs/binding/checkboxes","sectionName":"Introduction","sectionId":"introduction","id":1646,"text":"Aurelia supports two-way binding a variety of data-types to checkbox input elements."},{"articleName":"Binding Checkboxes","articleHref":"docs/binding/checkboxes","sectionName":"Booleans","sectionId":"booleans","id":1647,"text":"Bind a boolean property to an input element's checked attribute using checked.bind=\"myBooleanProperty\"."},{"articleName":"Binding Checkboxes","articleHref":"docs/binding/checkboxes","sectionName":"Array of Numbers","sectionId":"array-of-numbers","id":1648,"text":"A set of checkbox elements is a multiple selection interface. If you have an array that serves as the \"selected items\" list, you can bind the array to each input's checked attribute. The binding system will track the input's checked status, adding the input's value to the array when the input is checked and removing the input's value from the array when the input is unchecked. To define the input's \"value\", bind the input's model attribute: model.bind=\"product.id\"."},{"articleName":"Binding Checkboxes","articleHref":"docs/binding/checkboxes","sectionName":"Array of Objects","sectionId":"array-of-objects","id":1649,"text":"Numbers aren't the only type of value you can store in a \"selected items\" array. The binding system supports all types, including objects.  Here's an example that adds and removes \"product\" objects from a selectedProducts array using the checkbox data-binding."},{"articleName":"Binding Checkboxes","articleHref":"docs/binding/checkboxes","sectionName":"Array of Objects with Matcher","sectionId":"array-of-objects-with-matcher","id":1650,"text":"You may run into situations where the object your input element's model is bound to does not have reference equality to any of the objects in your checked array. The objects might match by id, but they may not be the same object instance. To support this scenario you can override Aurelia's default \"matcher\" which is a equality comparison function that looks like this: (a, b) => a === b. You can substitute a function of your choosing that has the right logic to compare your objects."},{"articleName":"Binding Checkboxes","articleHref":"docs/binding/checkboxes","sectionName":"Array of Strings","sectionId":"array-of-strings","id":1651,"text":"Finally, here's an example that adds and removes strings from a selectedProducts array using the checkbox data-binding. This is example is unique because it does not use model.bind to assign each checkbox's value. Instead the input's standard value attribute is used. Normally we cannot use the standard value attribute in conjunction with checked binding because it coerces anything it's assigned to a string. This example uses an array of strings so everything works just fine."},{"articleName":"Binding Radios","articleHref":"docs/binding/radios","sectionName":"Introduction","sectionId":"introduction","id":1652,"text":"A group of radio inputs is a type of \"single select\" interface. Aurelia supports two-way binding any type of property to a group of radio inputs. The examples below illustrate binding number, object, string and boolean properties to sets of radio inputs. In each of the examples there's a common set of steps: Group the radios via the name property. Radio buttons that have the same value for the name attribute are in the same \"radio button group\"; only one radio button in a group can be selected at a time. Define each radio's value using the model property. Two-way bind each radio's checked attribute to a \"selected item\" property on the view-model."},{"articleName":"Binding Radios","articleHref":"docs/binding/radios","sectionName":"Numbers","sectionId":"numbers","id":1653,"text":"Let's start with an example that uses a numeric \"selected item\" property. In this example each radio input will be assigned a number value via the model property. Selecting a radio will cause it's model value to be assigned to the selectedProductId property."},{"articleName":"Binding Radios","articleHref":"docs/binding/radios","sectionName":"Objects","sectionId":"objects","id":1654,"text":"The binding system supports binding all types to radios, including objects. Here's an example that binds a group of radios to a selectedProduct object property."},{"articleName":"Binding Radios","articleHref":"docs/binding/radios","sectionName":"Objects with Matcher","sectionId":"objects-with-matcher","id":1655,"text":"You may run into situations where the object your input element's model is bound to does not have reference equality to any of the object in your checked attribute is bound to. The objects might match by id, but they may not be the same object instance. To support this scenario you can override Aurelia's default \"matcher\" which is a equality comparison function that looks like this: (a, b) => a === b. You can substitute a function of your choosing that has the right logic to compare your objects."},{"articleName":"Binding Radios","articleHref":"docs/binding/radios","sectionName":"Booleans","sectionId":"booleans","id":1656,"text":"In this example each radio input is assigned one of three literal values: null, true and false. Selecting one of the radios will assign it's value to the likesCake property."},{"articleName":"Binding Radios","articleHref":"docs/binding/radios","sectionName":"Strings","sectionId":"strings","id":1657,"text":"Finally, here's an example using strings. This is example is unique because it does not use model.bind to assign each radio's value. Instead the input's standard value attribute is used. Normally we cannot use the standard value attribute in conjunction with checked binding because it coerces anything it's assigned to a string."},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Introduction","sectionId":"introduction","id":1658,"text":"A <select> element can serve as a single-select or multiple-select \"picker\" depending on whether the multiple attribute is present. The binding system supports both use cases. The samples below demonstrate a variety scenarios, all use a common series of steps to configure the select element: Add a <select> element to the template and decide whether the multiple attribute should be applied. Bind the select element's value attribute to a property. In \"multiple\" mode, the property should be an array. In singular mode it can be any type. Define the select element's <option> elements. You can use the repeat or add each option element manually. Specify each option's value via the model property: <option model.bind=\"product.id\">${product.name}</option> You can use the standard value attribute instead of model, just remember- it will coerce anything it's assigned to a string."},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Select Number","sectionId":"select-number","id":1659,"text":""},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Select Object","sectionId":"select-object","id":1660,"text":""},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Select Object with Matcher","sectionId":"select-object-with-matcher","id":1661,"text":"You may run into situations where the object your select element's value is bound does not have reference equality with any of the objects your option element model properties are bound to. The select's value object might \"match\" one of the option objects by id, but they may not be the same object instance. To support this scenario you can override Aurelia's default \"matcher\" which is a equality comparison function that looks like this: (a, b) => a === b. You can substitute a function of your choosing that has the right logic to compare your objects."},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Select Boolean","sectionId":"select-boolean","id":1662,"text":""},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Select String","sectionId":"select-string","id":1663,"text":""},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Multiple Select Numbers","sectionId":"multiple-select-numbers","id":1664,"text":""},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Multiple Select Objects","sectionId":"multiple-select-objects","id":1665,"text":""},{"articleName":"Binding Selects","articleHref":"docs/binding/selects","sectionName":"Multiple Select Strings","sectionId":"multiple-select-strings","id":1666,"text":""},{"articleName":"Delegate vs. Trigger","articleHref":"docs/binding/delegate-vs-trigger","sectionName":"Delegate vs Trigger","sectionId":"delegate-vs-trigger","id":1667,"text":"A couple frequently asked questions are: What's the difference between delegate and trigger? When should I use delegate and when should I use trigger? The short answer is: Use delegate except when you cannot use delegate. Event delegation is a technique used to improve application performance. It drastically reduces the number of event subscriptions by leveraging the \"bubbling\" characteristic of most DOM events. With event delegation, handlers are not attached to individual elements. Instead, a single event handler is attached to a top-level node such as the body element. When an event bubbles up to this shared top-level handler the event delegation logic calls the appropriate handler based on the event's target. To find out if event delegation can be used with a particular event, google mdn [event name] event. In fact, preceding any web platform related google search with mdn often returns a high quality result from the Mozilla Developer Network. Once you're on the event's MDN page, check whether the event bubbles. Only events that bubble can be used with Aurelia's delegate binding command. The blur, focus, load and unload events do not bubble so you'll need to use the trigger binding command to subscribe to these events. Here's the MDN page for blur. It has further info on event delegation techniques for the blur and focus events. Exceptions to the general guidance above: Use  You need to disable the button. The button's content is made up of other elements (as opposed to just text). This will ensure clicks on disabled button's children won't bubble up to the delegate event handler.  More info here. Use  iOS does not bubble click events on elements other than a, button, input and select. If you're subscribing to click on a non-input element like a div and are targeting iOS, use the trigger binding command. More info here and here."},{"articleName":"Delegate vs. Trigger","articleHref":"docs/binding/delegate-vs-trigger","sectionName":"Event delegation with ","sectionId":"event-delegation-with","id":1668,"text":"In most situations, delegate and trigger are enough for you to handle user interaction. However, delegate and trigger can be sometime too late to react to an event. Some other times, events may never reach to your delegate or trigger handlers, this is the case when you interact with content (elements) generated by 3rd party plugins. delegate and trigger will fail in the following example: This is where you may need another way to listen to click event, via binding command capture: In the 2nd example, onClickPluginContainer() is guaranteed to happen no matter event.stopPropagation() is called or not inside the container. With the introduction of capture binding command, you may ask \"Which is best command for event handling ?\". Well, the short answer above remains true, Use delegate except when you cannot use delegate. capture is not needed normally and may even be confusing as it's not how we normally works with browser events."},{"articleName":"Computed Properties","articleHref":"docs/binding/computed-properties","sectionName":"Introduction","sectionId":"introduction","id":1669,"text":"Sometimes it is desirable to return a dynamically computed value when accessing a property, or you may want to reflect the status of an internal variable without requiring the use of explicit method calls. In JavaScript, this can be accomplished with the use of a getter. Here's an example Person class that exposes a fullName property that computes it's value using the firstName and lastName properties. There isn't anything special you need to do to bind to a computed property like fullName. The binding system will examine the property's descriptor, determine that the value of the property is computed by a function and choose the dirty checking observation strategy. Dirty checking means the binding system will periodically check the property's value for changes and update the view as-needed. This means your property's getter function will be executed many times, approximately once every 120 milliseconds. Most of the time this isn't an issue, however, if you're using a lot of computed properties or if your getter functions are sufficiently complex you may want to consider giving the binding system hints on what to observe so that it doesn't need to use dirty checking. This is where the @computedFrom decorator comes in: @computedFrom tells the binding system which expressions to observe. When those expressions change, the binding system will re-evaluate the property (execute the getter). This eliminates the need for dirty checking and can improve performance. The @computedFrom parameters can be simple property names as shown above or more complex expressions like @computedFrom('event.startDate', 'event.endDate')."},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Introduction","sectionId":"introduction","id":1670,"text":"In Aurelia, user interface elements are composed of view and view-model pairs. The view is written with HTML and is rendered into the DOM. The view-model is written with JavaScript and provides data and behavior to the view. Aurelia's powerful data-binding links the two pieces together, allowing changes in your data to be reflected in the view and vice versa. Here's a simple data-binding example using the bind (.bind=\"expression\") and interpolation (\\${expression}) techniques: Sometimes the raw data exposed by your view-model isn't in a format that's ideal for displaying in the UI. Rendering date and numeric values are common scenarios: Ideally, the date would be in a more readable format and the amount would be formatted as currency. One solution to this problem would be to compute the formatted values and expose them as properties of the view-model. This is certainly a valid approach; however, defining extra properties and methods in your models can get messy, especially when you need to keep the formatted values in sync when the original property value change. Fortunately, Aurelia has a feature that makes solving this problem quite easy."},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Value Converters","sectionId":"value-converters","id":1671,"text":"A value converter is a class whose responsibility is to convert view-model values into values that are appropriate to display in the view and vice versa. Most commonly you'll be creating value converters that translate model data to a format suitable for the view; however, there are situations where you'll need to convert data from the view to a format expected by the view-model, typically when using two-way binding with input elements. If you've used value converters in other languages such as Xaml, you'll find Aurelia value converters are quite similar, although with a few notable improvements: The Aurelia ValueConverter interface uses toView and fromView methods, which make it quite clear which direction the data is flowing.  This is in contrast to Xaml's IValueConverter, which uses Convert and ConvertBack. In Aurelia, converter parameters can be data-bound.  This is something that was missing in Xaml and enables more advanced binding scenarios. Aurelia value converter methods can accept multiple parameters. Multiple value converters can be composed using pipes (|). Aurelia value converter can have a class field named signals, which accepts an array of string that will be used to manually trigger updating the view. This is to handle the situations where the value converter relies on variables that are defined outside of Aurelia application, such as language, locale etc."},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Simple Converters","sectionId":"simple-converters","id":1672,"text":"Before we get too far into the details, let's rework the previous example to use a couple of basic value converters.  Aurelia and the popular Moment and Numeral libraries will take care of the heavy lifting, we just need to wire things up... OK, the result looks much better, but how did this all work? Well, first we created a couple of value converters:  DateFormatValueConverter and CurrencyFormatValueConverter.  Each has a toView method that the Aurelia framework will apply to model values before displaying them in the view. Our converters use the MomentJS and NumeralJS libraries to format the data. Next, we updated the view to require the converters so they can be used in the view.  When requiring a resource such as a value converter, you supply the path to the resource in the require element's from attribute. When Aurelia processes the resource, it examines the class's metadata to determine the resource type (custom element, custom attribute, value converter, etc). Metadata isn't required, and in fact our value converters didn't expose any. Instead, we relied on one of Aurelia's simple conventions:  export names ending with ValueConverter are assumed to be value converters.  The convention registers the converter using the export name, camel-cased, with the ValueConverter portion stripped from the end. DateFormatValueConverter registers as dateFormat CurrencyFormatValueConverter registers as currencyFormat Finally, we applied the converter in the binding using the pipe | syntax: Info: Conventional Names The name that a resource is referenced by in a view derives from its export name. For Value Converters and Binding Behaviors, the export name is converted to camel case (think of it as a variable name). For Custom Elements and Custom Attributes the export name is lower-cased and hyphenated (to comply with HTML element and attribute specifications)."},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Converter Parameters","sectionId":"converter-parameters","id":1673,"text":"The converters in the previous example worked great, but what if we needed to display dates and numbers in multiple formats?  It would be quite repetitive to define a converter for each format we needed to display.  A better approach would be to modify the converters to accept a format parameter.  Then we'd be able to specify the format in the binding and get maximum reuse out of our format converters. With the format parameter added to the toView methods, we are able to specify the format in the binding using the [expression] | [converterName]:[parameterExpression] syntax:"},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Binding Converter Parameters","sectionId":"binding-converter-parameters","id":1674,"text":"Converter parameters needn't be literal values.  You can bind parameter values to achieve dynamic results:"},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Multiple Parameters / Composing Converters","sectionId":"multiple-parameters-composing-converters","id":1675,"text":"Value converters can accept multiple parameters and multiple converters can be composed in the same binding expression, providing a lot of flexibility and opportunity for reuse. In the following example, we have a view-model exposing an array of Aurelia repos. The view uses a repeat binding to list the repos in a table. A SortValueConverter is used to sort the array based on two arguments: propertyName and direction.  A second converter, TakeValueConverter accepting a count argument is applied to limit the number of repositories listed: Here's the full example:"},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Object Parameters","sectionId":"object-parameters","id":1676,"text":"Aurelia supports object converter parameters. An alternate implementation of the SortValueConverter using a single config parameter would look like this: There are a couple of advantages to this approach: you don't need to remember the order of the converter parameter arguments, and anyone reading the markup can easily tell what each converter parameter represents."},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Bi-directional Value Converters","sectionId":"bi-directional-value-converters","id":1677,"text":"So far we've been using converters with to-view bindings. The data flows in a single direction, from the model to the view.  When using a converter in an input element's value binding, we need a way to convert the user's data entry to the format expected by the view-model. This is where the value converter's fromView method comes into play, taking the element's value and converting it to the format expected by the view-model. In the example below, we have a view-model that exposes colors in an object format, with properties for the red, green and blue components. In the view, we want to bind this color object to an HTML5 color input. The color input expects hex format text, so we'll use an RgbToHexValueConverter to facilitate the binding."},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Globally Accessible Value Converters","sectionId":"globally-accessible-value-converters","id":1678,"text":"In all of our examples, we've been using the require element to import converters we need into our view.  There's an easier way.  If you have some commonly used value converters that you'd like to make globally available, use Aurelia's globalResources function to register them.  This will eliminate the need for require elements at the top of every view."},{"articleName":"Value Converters","articleHref":"docs/binding/value-converters","sectionName":"Signalable Value Converters","sectionId":"signalable-value-converters","id":1679,"text":"In some scenarios, a global parameter that is unobservable by Aurelia is used inside a value converter, such as timezone, or a new USB was connected to the device etc. In some other scenarios, we need to update all bindings that use a certain value converter at once, for example: language translation value converters when application language has changed. Aurelia value converters have an API to trigger the bindings, with value converters that have signals property declared on it, to update. In the example below, we have a view-model that exposes a list of flights with information of each flight. In the view, we want to bind display each of those flights, as a clock, with correct date format based on global variable name currentLocale. We can trigger all of the flight display to change based on signals of the value converter. We do this via export signalBindings of the framework. Following is the example code"},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"Introduction","sectionId":"introduction","id":1680,"text":"Binding behaviors are a category of view resource, just like value converters, custom attributes and custom elements.  Binding behaviors are most like value converters in that you use them declaratively in binding expressions to affect the binding. The primary difference between a binding behavior and a value converter is binding behaviors have full access to the binding instance, throughout it's lifecycle. Contrast this with a value converter which only has the ability to intercept values passing from the model to the view and visa versa. The additional \"access\" afforded to binding behaviors gives them the ability to change the behavior of the binding, enabling a lot of interesting scenarios which you'll see below."},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"throttle","sectionId":"throttle","id":1681,"text":"Aurelia ships with a handful of behaviors out of the box to enable common scenarios.  The first is the throttle binding behavior which limits the rate at which the view-model is updated in two-way bindings or the rate at which the view is updated in to-view binding scenarios. By default throttle will only allow updates every 200ms. You can customize the rate of course.  Here are a few examples. The first thing you probably noticed in the example above is the & symbol, which is used to declare binding behavior expressions. Binding behavior expressions use the same syntax pattern as value converter expressions: Binding behaviors can accept arguments: firstName & myBehavior:arg1:arg2:arg3 A binding expression can contain multiple binding behaviors: firstName & behavior1 & behavior2:arg1. Binding expressions can also include a combination of value converters and binding behaviors: \\${foo | upperCase | truncate:3 & throttle & anotherBehavior:arg1:arg2}. Here's another example using throttle, demonstrating the ability to pass arguments to the binding behavior: The throttle behavior is particularly useful when binding events to methods on your view-model.  Here's an example with the mousemove event:"},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"debounce","sectionId":"debounce","id":1682,"text":"The debounce binding behavior is another rate limiting binding behavior. Debounce prevents the binding from being updated until a specified interval has passed without any changes. A common use case is a search input that triggers searching automatically.  You wouldn't want to make a search API on every change (every keystroke).  It's more efficient to wait until the user has paused typing to invoke the search logic. Like throttle, the debounce binding behavior really shines in event binding. Here's another example with the mousemove event:"},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"updateTrigger","sectionId":"updatetrigger","id":1683,"text":"Update trigger allows you to override the input events that cause the element's value to be written to the view-model. The default events are change and input. Here's how you would tell the binding to only update the model on blur: Multiple events are supported:"},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"signal","sectionId":"signal","id":1684,"text":"The signal binding behavior enables you to \"signal\" the binding to refresh. This is especially useful when a binding result is impacted by global changes that are outside of the observation path. For example, if you have a \"translate\" value converter that converts a key to a localized string- eg \\${'greeting-key' | translate} and your site allows users to change the current language, how would you refresh the bindings when that happens? Another example is a value converter that uses the current time to convert a record's datetime to a \"time ago\" value:  posted \\${postDateTime | timeAgo}. The moment this binding expression is evaluated it will correctly result in posted a minute ago.  As time passes, it will eventually become inaccurate. How can we refresh this binding periodically so that it correctly displays 5 minutes ago, then 15 minutes ago, an hour ago, etc? Here's how you would accomplish this using the signal binding behavior: In the binding expression above we're using the signal binding behavior to assign the binding a \"signal name\" of my-signal. Signal names are arbitrary, you can give multiple bindings the same signal name if you want to signal multiple bindings at the same time. Here's how we can use the BindingSignaler to signal the bindings periodically:"},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"oneTime","sectionId":"onetime","id":1685,"text":"With the oneTime binding behavior you can specify that string interpolated bindings should happen once. Simply write: This is an important feature to expose. One-time bindings are the most efficient type of binding because they don't incur any property observation overhead. There are also binding behaviors for toView and twoWay which you could use like this: Warning: Binding Mode Casing The casing for binding modes is different depending on whether they appear as a binding command or as a binding behavior. Because HTML is case-insensitive, binding commands cannot use capitals. Thus, the binding modes, when specified in this place, use lowercase, dashed names. However, when used within a binding expression as a binding behavior, they must not use a dash because that is not a valid symbol for variable names in JavaScript. So, in this case, camel casing is used."},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"self","sectionId":"self","id":1686,"text":"With the self binding behavior, you can specify that event handler will only response to the target where listener was attached to, not its descendants. For example, in the following markup onMouseDown is your event handler and it will be called not only when user mousedown on header element, but also all elements inside it, which in this case are the buttons settings and close. However, this is not always desired behavior. Sometimes you want the component to only react when user click on the header itself, not the buttons. In order to achieve this, onMouseDown method needs some modification: This works, but now business/ component logic are mixed up with DOM event handling, which are not necessary. Using self binding behavior can help you achieve the same goal without filling up your methods with unnecessary code:"},{"articleName":"Binding Behaviors","articleHref":"docs/binding/binding-behaviors","sectionName":"Custom binding behaviors","sectionId":"custom-binding-behaviors","id":1687,"text":"You can build custom binding behaviors just like you can build value converters. Instead of toView and fromView methods you'll create bind(binding, scope, [...args]) and unbind(binding, scope) methods. In the bind method you'll add your behavior to the binding and in the unbind method you should cleanup whatever you did in the bind method to restore the binding instance to it's original state. The binding argument is the binding instance whose behavior you want to change. It's an implementation of the Binding interface. The scope argument is the binding's data-context. It provides access to the model the binding will be bound to via it's bindingContext and overrideContext properties. Here's a custom binding behavior that calls a method on your view model each time the binding's updateSource / updateTarget and callSource methods are invoked."},{"articleName":"Observable Properties","articleHref":"docs/binding/binding-observable-properties","sectionName":"Observable Properties","sectionId":"observable-properties","id":1688,"text":"Have you ever needed to perform an action when a property is changed? If you have, that's a great use of property observation. To observe a property, you need to decorate it with the @observable decorator and define a method as the change handler. This method can receive 2 parameters: the new value and the old value. You can put any business logic inside this method. By convention, the change handler is a method whose name is composed of the property_name and the literal value 'Changed'. For example, if you decorate the property color with @observable, you have to define a method named colorChanged() to be the change handler. Here's an example of that: Info You do not have to check if newValue and oldValue are different. The change handler will not be called if you assign a value that the property already has. If you do not want to use the convention, you can define the callback name for the change handler by setting the changeHandler property of the @observable decorator: If you prefer, can also put the @observable on classes: Info The @observable only tracks changes to the value of a property, not changes in the value itself. This means that if the property is an array, the change handler will not fire when adding, removing or editing items."},{"articleName":"Observable Properties","articleHref":"docs/binding/binding-observable-properties","sectionName":"Observing Collections","sectionId":"observing-collections","id":1689,"text":"Use the Collection Observer to observe changes to a collection. Collection types that can be observed are Array, Map, and Set. Create a subscription by providing the collection to observe and a callback function. The callback will receive an array of splices which provides information about the change that was detcted. The properties of the splice may vary depending on the type of collection being observed. Here you can see example callback functions used to observe each of the different collection types. Warning If you were to overwrite the value of the collection after the subscription has been created, changes wil no longer be detected. For example, running this.myCollection = [] after this.bindingEngine.collectionObserver(this.myCollection) will fail to observe changes to myCollection."},{"articleName":"How it Works","articleHref":"docs/binding/how-it-works","sectionName":"End to End","sectionId":"end-to-end","id":1690,"text":"This article explains how the binding system works. There is a lot to cover here, and to start we're actually going to look at a component outside of the binding system so you can gain a full understanding of the process. A good place to start is in the templating module, with a component called the ViewCompiler. The ViewCompiler's job is to compile views into a ViewFactory which will be used to instantiate instances of your templates, called Views. Some view factories will be used to instantiate only one instance of a particular template. The ViewFactory that resulted from compiling your app.html template typically falls into this category. Other view factories for templates used with repeat.for may be used to instantiate tens, hundreds or even thousands of View instances. A ViewFactory is comprised, among other things, of a template (a document fragment), a set of HTML behavior instructions (instructions for creating custom elements or custom attributes that appear in the template), binding expressions (factories for creating bindings that appear in the template), and dependencies (things you've <require from=\"...\">). When Aurelia loads one of your HTML templates the markup is parsed by the browser into a document fragment. The document fragment is the browser's object representation of your HTML. It is a tree structure and all the node names and attribute names have been lower-cased by the browser's HTML parser (except for SVG elements). The ViewCompiler traverses each DOM node in the tree and checks whether the node's name matches the name of a custom element. For now we won't go into the details of what happens when a custom element is discovered because it doesn't really matter to the binding system whether an element is custom or built-in. In addition to checking for custom elements, the ViewCompiler asks the BindingLanguage implementation to examine each node's attributes and content. The standard BindingLanguage implementation that ships with Aurelia looks for attributes whose name ends with .bind, .to-view, .delegate, .trigger or starts with ref, etc. These attribute postfixes and prefixes are known as \"binding commands\". The standard BindingLanguage also checks the element's content for string interpolation expressions. When a binding command or string interpolation is discovered, the attribute's value (text) or interpolation's content (also text) is sent to the binding system's Parser. If you've written your binding expression correctly the parser will be able to tokenize the text (split it into a series of interesting parts) and convert the tokens to an abstract syntax tree (AST). The AST is the object representation of your JavaScript binding expression. We'll dive into the AST in a minute. What is important to understand now is that by this point the ViewCompiler has gathered a whole bunch of information about each binding expression in your template. It knows the name of the DOM element, the name of the element's attribute you intend to bind to (if applicable), the binding command (bind/trigger/etc) and it has the AST representation of your JavaScript binding expression. All of these parts are used to construct a BindingExpression which is a factory for creating binding instances. Once the ViewCompiler has completely traversed the document fragment it returns the ViewFactory instance, which will be cached until it is needed. Aurelia compiles templates on an as-needed basis so it is likely to be used soon after it is compiled. Orchestrating all the work described above and the steps to follow is the CompositionEngine in conjunction with a Controller, which are parts of the templating module. The CompositionEngine is a high level component that creates controllers and executes composition instructions. Composition instructions are the result of application bootstrapping, routing and the <compose> element. They tell Aurelia to compose a view with a view-model. The Controller is a little bit lower level. It \"owns\" a View and its corresponding view-model, and takes us through the created, bind, attached, detached and unbind composition lifecycle events that occur when composing a view and view-model, injecting the view into the DOM and later removing it when it is no longer needed. Let's go through these steps, one-by-one, focusing on what happens with respect to data-binding. The ViewFactory's create method will be called to create a View instance. A View in this sense is a JavaScript class with methods for all of the composition lifecycle events. Creating a View involves several steps. First the ViewCompiler's document fragment is cloned to create the element that will ultimately be injected into the DOM and data-bound. This is the element that is given to your view-model's constructor when you use @inject(Element). Next, the ViewCompiler will execute all its instructions: creating custom element instances, custom attribute instances, and binding instances. Creating a binding instance is accomplished by invoking the createBinding method on each BindingExpression, passing in the specific DOM element, custom element or custom attribute that is relevant to the BindingExpression. The createBinding method uses the ObserverLocator to locate the appropriate property observer for the combination of DOM element and property. Property observers expose a subscribe, unsubscribe, getValue and setValue interface. Each property observer has a specific observation strategy tailored for certain types of objects or elements and their various properties. For example, if you were binding an input element's value attribute there is an observer implementation that will subscribe to the input's change and input DOM events. With the property observer in hand createBinding will instantiate a Binding instance, passing the property observer to the Binding's constructor. This observer is known as the Binding's targetObserver. A few other items are passed to the Binding's constructor: the DOM element, known as the binding's target, the attribute name, the binding mode (to-view/two-way/one-time) and last but not least, the BindingExpression's AST, which is known as the binding's sourceExpression. Once the ViewFactory's create method has finished executing all the instructions and creating all the bindings it will instantiate the View, whose constructor will receive the DOM element, bindings, controllers, and a few other items. With the View created the Controller can execute the view's bind method, passing in the binding context and override context. The binding context and override context tuple is known as the scope- more on that in a minute... The view's bind method loops through all of its binding instances and calls their bind method, passing in the binding context and override context. This is where the AST in the binding's sourceExpression becomes important. The abstract syntax tree is the heart of the binding system. It is the object representation of your binding's JavaScript expression. Each node in the tree is an implementation of a very binding-specific interface. There are about 20 different AST node types, each tailored to a particular type of JavaScript expression. The AST can be evaluated by calling the root AST node's evaluate method and passing in the scope. Each node in the AST knows how to evaluate its piece of the expression using the scope and the end result will be the value of the JavaScript expression. After the binding gets the model value by evaluating the sourceExpression it assigns this value to the view by calling the targetObserver's setValue method. Next the binding will check its binding mode. If it is one-time, there is nothing left to do. If it is to-view or two-way the binding will use the AST's connect method to subscribe to changes in the view-model. Each node in the AST knows which view-model properties to observe and will use the ObserverLocator to create property observers to subscribe to property change events. Finally, if the binding mode is two-way the binding will call the targetObserver's subscribe method. At this point the view and view-model are data-bound. When changes occur in the model, the property observers created when the AST was connected will fire change events, triggering the binding to update the target by calling targetObserver.setValue. When changes occur in the view the property observer known as the targetObserver will trigger the binding to update the source by calling sourceExpression.assign(scope, value). All that remains is for the Controller to attach the view to the DOM. Later, when the view is no longer needed it will be detached from the DOM and unbind will be invoked, unbinding all the views, which will unsubscribe all the property observers."},{"articleName":"How it Works","articleHref":"docs/binding/how-it-works","sectionName":"Abstract Syntax Tree","sectionId":"abstract-syntax-tree","id":1691,"text":"The abstract syntax tree is a key part of the binding system, we've discussed how it is used but it is easier to understand if you can visualize it. Below is a demo where you can enter any binding expression and see the AST resulting from parsing the expression. Click on the buttons to view some example expressions we put together or enter your own."},{"articleName":"How it Works","articleHref":"docs/binding/how-it-works","sectionName":"Binding Context / Scope","sectionId":"binding-context-scope","id":1692,"text":"The \"scope\" in aurelia is made up of two objects: the bindingContext (almost always a view-model instance) and the overrideContext which can be thought of as an \"overlay\" of the bindingContext. Properties on the overrideContext \"override\" corresponding properties on the bindingContext. It is actually rare for there to be a property on the overrideContext that is \"hiding\" a property on the bindingContext beneath. Most of the time the overrideContext is storing extra contextual properties such as $index, $first, $last, $odd, $even in the case of the repeat, $event when event bindings are firing, etc. The other purpose of the overrideContext is to enable scope traversal. The overrideContext also has a reference to the parent overrideContext and to its corresponding bindingContext which enables the binding system to traverse the scope as-needed when it evaluates a binding expression. If you've been using Aurelia for a while you might remember needing to use $parent to access the outer scope. It is not needed anymore because the binding system knows how to traverse the scope (read: traverse the bindingContext/overrideContext hierarchy) automatically. When are bindingContexts created? Not often. The repeat is the only thing that creates them on the fly. The rest of the time the bindingContext is the view-model instance you'd expect it to be. On the other hand, overrideContexts are created on an as-needed basis, typically when it is time to compose a view and view-model. "},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"Introduction","sectionId":"introduction","id":1693,"text":"Aurelia's templating system is simple to learn, and yet powerful enough to build even the most complex applications. This article will walk you through the construction of a static template, importing that template into parent templates, binding and manipulating data through the view-model, and the use of conditionals, repeaters, and events."},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"A Simple Template","sectionId":"a-simple-template","id":1694,"text":"All Aurelia templates must be wrapped with a <template> element. The most basic template is a component that prints \"Hello World\": This template could be a page in an Aurelia application, or it could be the view for a custom element. A template containing only boilerplate could be useful as a footer containing copyright information or disclaimers, but where's the fun in a static template? All Aurelia templates work with a view-model, so let's create one: Let's bind the name property in our view-model into our template using Aurelia's string interpolation: One of the key features of Aurelia's templating system is helping to reduce context switching between your javascript code and your template markup. String interpolation using the \\${} operator is a new feature in ES2015 that makes it simple to insert values into a string. Thus, Aurelia uses this standard syntax in your templates. When this template is run, Aurelia will insert the value of the name property into the template where \\${name} appears. Pretty simple, right? But what if we want logic in our string interpolation. Can we add our own expressions? Absolutely! In our template, when arriving is true, the ternary operator makes our result 'Hello', but when it's false, it makes our result 'Goodbye'. Our view-model code initializes arriving to true and changes it to false after 5 seconds (5000 milliseconds). So when we run the template, it will say \"Hello, John Doe!\" and after 5 seconds, it will say \"Goodbye, John Doe!\". Aurelia re-evaluates the string interpolation when the value of arriving changes! But don't worry, there is no dirty-checking. Aurelia uses an observable-based binding system that reacts to changes as they happen without having to do dirty-checking. This means that Aurelia doesn't slow down as you add more complex functionality to your template and view-model."},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"Binding","sectionId":"binding","id":1695,"text":"Binding in Aurelia allows data from the view-model to drive template behavior. The most basic example of binding is linking a text box to the view model using value.bind. What if we let the user decide who they want to greet, and whether to say Hello or Goodbye? Above, we have a text box that asks for the name of the person to greet, and a checkbox indicating whether they're arriving. Because we defined name as \"John Doe\" in our view-model, the initial value of the text-box will be \"John Doe\", and with arriving set to true, our checkbox will start checked. When we change the name, the person we're greeting will change with it: \"Hello, Jane Doe!\". If we uncheck the box, the greeting will change: \"Goodbye, Jane Doe!\" Notice that the way we set up the binding was by using value.bind and checked.bind. That . within the attribute is important: whenever you see the ., Aurelia is going to do something with that attribute. The most important thing to take away from this section is understanding that Aurelia will link attributes to the left of the . with actions to the right of the .. You can learn more about data-binding in the Binding section of our docs. Binding Focus We can also use two-way data binding to communicate whether or not an element has focus: When we click the input field, we see \"true\" printed. When we click elsewhere, it changes to \"false\". Binding Scopes Using  We can also declare that certain parts of our markup will be referencing properties of an object in the view model, as below: Using with is basically shorthand for \"I'm working on properties of this object\", which lets you reuse code as necessary."},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"Composition","sectionId":"composition","id":1696,"text":"In order to live by the DRY (Don't Repeat Yourself) Principle, we don't necessarily want to rely on tight coupling between our view and view-model pairs. Wouldn't it be great if there was a custom element that would arbitrarily combine an HTML template, a view-model, and maybe even some initialization data for us? As it turns out, we're in luck: Note that the view-model we're composing into has an activate method. When we use model.bind, the contents are passed to activate. We then pull the exact value that we need out of the passed model and assign it."},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"The as-element Attribute","sectionId":"the-as-element-attribute","id":1697,"text":"In some cases, especially when creating table rows out of Aurelia custom elements, you may need to have a custom element masquerade as a standard HTML element. For example, if you're trying to fill table rows with data, you may need your custom element to appear as a <tr> row or <td> cell. This is where the as-element attribute comes in handy: The as-element attribute tells Aurelia that we want the content of the table row to be exactly what our hello-row template wraps. The way different browsers render tables means this may be necessary sometimes."},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"The View Resource Pipeline","sectionId":"the-view-resource-pipeline","id":1698,"text":"The basic idea behind the View Resource Pipeline is that we're not limited to HTML or JavaScript. A basic example would be pulling in Bootstrap: Here, the <require> tag is taking a CSS file, instead of html or a view model. The View Resource Pipeline is the part of Aurelia that's responsible for recognizing that it's CSS, and handling it appropriately. One of the most powerful features of Aurelia is that the View Resource Pipeline is completely extensible, allowing you to define your own handler for any type of view resource you might want to define!"},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"View and Compilation Spies","sectionId":"view-and-compilation-spies","id":1699,"text":"If you've installed the aurelia-testing plugin, you have access to two special templating behaviors: view-spy drops Aurelia's copy of the View object into the console, while compile-spy emits the compiler's TargetInstruction. This is especially useful for debugging any new View Resources you've created using the View Resource Pipeline."},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"Conditionals","sectionId":"conditionals","id":1700,"text":"Aurelia has two major tools for conditional display: if, and show. The difference is that if removes the element entirely from the DOM, and show toggles the aurelia-hide CSS class which controls the element's visibility. The difference is subtle but important in terms of speed and usability. When the state changes in if, the template and all of its children are deleted from the DOM, which is computationally expensive if it's being done over and over. However, if show is being used for a very large template, such as a dashboard containing thousands of elements with their own bound data, then keeping those elements loaded-but-hidden may not end up being a useful approach. Here's our basic \"Hello World\" that asks the user if they want to greet the world first: However, if we just want to hide the element from view instead of destroying it completely, we should use show instead of if. When unchecked, our \"Hello World\" div will have the aurelia-hide class, which sets display: none if you're using Aurelia's CSS libraries. However, if you don't want to do that, you can also define your own CSS rules that treat aurelia-hide differently, like setting visibility: none or height: 0px. Conditionals can also be one-time bound, so that parts of the template are fixed when they're instantiated: There's a 50-50 chance that we'll greet the world, or put it off until later. Once the page loads, this is fixed, because the data is one-time bound. Why don't we use show.one-time? If we think about what show does, it doesn't really make sense. We're saying we want a CSS class to be applied that will hide an element, and that it will never change. In most cases, we want if to refuse to create an element we'll never use. Complementing if, there is else. Used in conjunction with if, else will render its content when if does not evaluate to true. Elements using the else template modifier must follow an if bound element to make contextual sense and function properly."},{"articleName":"Templating Basics","articleHref":"docs/templating/basics","sectionName":"Repeaters","sectionId":"repeaters","id":1701,"text":"Repeaters can be used on any element, including custom elements, and template elements too! Here are a few different data types that can be iterated with a repeater. Arrays Aurelia is also able to repeat elements for each element in an array. This allows me to list out my friends and greet them one by one, rather than attempting to greet all 7 billion inhabitants of the world at once. As mentioned before, we can also use the template element as our repeater - but we have to wrap it in a surrogate <template> element: Info Aurelia will not be able to observe changes to arrays using the array[index] = value syntax. To ensure that Aurelia can observe the changes on your array, make use of the Array methods: Array.prototype.push, Array.prototype.pop and Array.prototype.splice. Two-way binding with arrays requires a special syntax due to the nature of the for-of loop in javascript. Do not use repeat.for=\"item of dataArray\";doing so will result in one-way binding only - values typed into an input will not be bound back. Instead use the following syntax: Range We can also iterate over a numerical range: Note that the range will start at 0 with a length of 10, so our countdown really does start at 10 and end at 1 before blast off. Sets I can also use an ES6 Set in the same way: We can use repeaters with arrays, which is useful - but we can also use repeaters with other iterable data types, including objects, plus new ES6 standards such as Map and Set. Map One of the more useful iterables is the Map, because you can decompose your key and value into two variables directly in the repeater. Although you can repeat over objects straightforwardly, Maps can be two-way bound much more straightforwardly than Objects, so you should try to use Maps where possible. One thing to notice in the example above is the dereference operator in [greeting, friend] - which breaks apart the map's key-value pair into greeting, the key, and friend, the value. Note that because all of our values are objects with the name property set, we can get our friend's name with \\${friend.name}, just as if we were getting it from JavaScript! Objects Let's do the same thing, except with a traditional JavaScript object in our view-model: We just introduced something called a \"value converter\". Basically, we take the object in our view model, friends, and run it through our keys value converter. Aurelia looks for a class named KeysValueConverter and tries to call its toView() method with our friends object. That method returns an array of keys- which we can iterate. In a pinch, we can use this to iterate over Objects. A common question pops up here: Why can't we just dereference the object into [key, value] like we did with Maps? The short answer is that JavaScript objects aren't iterable in the same way that Arrays, Maps, and Sets are. So in order to iterate over JavaScript objects, we have to transform them into something that is iterable. The way you approach it will change based on what exactly you want to do with that object. There is also a plugin that can be included, which will transform Objects to become iterable maps that can be dereferenced using the [key, value] syntax. "},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"Introduction","sectionId":"introduction","id":1702,"text":"The term \"HTML Behavior\" in Aurelia encompasses two basic concepts: Custom Elements and Custom Attributes. HTML Behaviors are a fundamental part of nearly every Aurelia application. They help to create componentized applications with highly reusable code. In this introductory document, we will explore some basic topics to help you build an understanding of working with these concepts in an Aurelia application."},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"What is an HTML Behavior?","sectionId":"what-is-an-html-behavior","id":1703,"text":"HTML Behaviors are how you extend HTML with Custom Elements and Custom Attributes in an Aurelia application. Custom Elements are, as their name suggests, their own element in your markup. They generally have a view with some markup that will be rendered as part of a page in your application. Custom Attributes, on the other hand, can be used on standard HTML elements (such as div or button) or Custom Elements to change the behavior of the element. Both Custom Elements and Custom Attributes support Aurelia's strong data-binding. HTML Behaviors, with one exception, require you to create a class for the behavior. This class is called a \"ViewModel\" for both Custom Elements and Custom Attributes. A Custom Element's ViewModel is typically paired with an HTML \"View\". A Custom Attribute's ViewModel is not paired with a view. Aurelia provides a naming convention for classes that allows you to tell the framework that a class is a ViewModel for a Custom Element or a Custom Attribute. This naming convention is very simple: append CustomElement or CustomAttribute to your ViewModel's name. It really is that simple. Info: Custom Elements as Default Actually, you don't even need to append CustomElement to a class to turn it into a custom element. The reason for this is that if Aurelia can't match any other convention, and finds no explicit configuration, it will assume that the class is a custom element. If you are using the naming convention for your HTML Behavior's class, then Aurelia will use the class's name to determine the name your behavior will have in an HTML view. The standard naming convention for JavaScript classes is InitCaps, meaning you start each word with a capital letter; however, HTML is case-insensitive, usually normalized to lower-case. To bridge this gap, Aurelia will take the class name, strip the CustomElement or CustomAttribute postfix from it, and then convert the class name to dash-case. This means that HelloWorldCustomElement becomes hello-world and RedSquareCustomAttribute becomes red-square when you use it in a template. You can override the naming convention and explicitly name your HTML Behavior by using a @customAttribute or @customElement decorator on your HTML Behavior's ViewModel. You pass a string to the decorator and this becomes the name your behavior will use. Aurelia will not alter this string in any way. This means that @customElement('helloworld') will give you a custom element named <helloworld>. These two decorators can be imported from the aurelia-framework module. When you use one of these decorators, there is no need to follow the naming convention mentioned above, as the use of the decorator tells Aurelia that you are creating a Custom Element or Custom Attribute. In fact, when you're using these decorators, the name of your class doesn't matter to Aurelia! Let's look at an example of using the @customAttribute decorator to explicitly name a custom attribute. As you see here, the custom attribute's name will be red-square even though the class is named BlueSquare. You obviously would not want to give a contradictory name like this in real code, but it's done here to show that the class name doesn't matter when you use the decorator to explicitly name your behavior. Info: Naming Practices It's generally recommended that custom elements and custom attributes be named so that the HTML behavior has a hyphen in the name. Use hello-world as apposed to helloworld. While nothing in Aurelia or the browser is going to stop you, in order to be forward compatible with Web Components, we recommend always using a hyphenated name. A common practice is to adopt a two-letter prefix and use it throughout your company or application."},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"Getting the DOM Element for your Behavior","sectionId":"getting-the-dom-element-for-your-behavior","id":1704,"text":"When you are creating an HTML Behavior, there will be many instances where you will need to perform some manipulation of the DOM Element associated with your behavior. Initially, you might think, \"No big deal! I'll just use document.querySelector or jQuery to get the DOM Element.\" But this would fall apart very quickly, as an HTML Behavior is likely to be used repeatedly on a page. How would you figure out exactly which element to query for? Well, luckily, Aurelia gives you an extremely easy way to get a reference to the element your Behavior is associated with: just have it injected in to your ViewModel. When you tell Aurelia to inject an instance of the Element class in to your class, Aurelia will inject the DOM Element your HTML Behavior is associated with. So no need to futz around with DOM queries! Let's take our red-square attribute and have it actually set it's element to be a red square. Just assign the passed in object to a property on your class, and you're good to go. Remember, you don't need jQuery to get the Element your HTML Behavior is attached to. Aurelia can provide it to you! Warning: Try to Avoid Browser Globals In the above examples, we used a browser global: Element. Sometimes using browser globals can cause testing issues. That's not the case here. However, should you desire to leverage server-side rendering, you'll need to have a codebase free of browser globals. You may want to prepare for this in advance. To help you avoid browser globals, Aurelia provides a Platform Abstraction Layer (PAL) that provides three exports DOM, FEATURE and PLATFORM. In the case above, you could substitute Element for DOM.Element."},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"Making an HTML Behavior Available in a View","sectionId":"making-an-html-behavior-available-in-a-view","id":1705,"text":"So far, we've merely talked about creating HTML Behaviors, but creating a behavior isn't very useful if you can't use it. So how do you use one? Well, first we have to make it available in a view. HTML Behaviors (and other view resources) are not available globally by default. This means that you must let Aurelia know which resources will be available in each view. This is done using the require element. The require element has two attributes from and as. You must supply a value for the from attribute, while as is optional. You cannot use data-binding with the from or as attributes on require.  When you \"require in\" a view resource with a require element, Aurelia will make it available for use in your view. The path you supply in the from attribute can take one of two forms: It can be relative to the root of your application or relative to the path of the view you are currently in. A path that does not have a ./ or ../ to start the path will be relative to the root of your application, while a path with ./ or ../ will be relative to your view's path. Note that you can use multiple ..s to traverse up a directory tree as needed. The name the resource will take in your view is determined in one of three ways: by Aurelia convention, by explicit naming in the resource, or by being overridden using the as attribute. If you happen to be using multiple resources that have the same name, you must provide a value for the as attribute for all but one of the conflicting resources. The as attribute can also be used whenever you would like to alias the name of a resource. Perhaps the standard name for an HTML Behavior is really long and you want to give it a shorter name. The as attribute can help you out. You will typically not provide a file extension to the from attribute. There are multiple reasons for this. First, the file extension for files in your development environment may be different from the file extension the browser runs (such as .ts files when using TypeScript). Second, most (but not all) custom elements will require Aurelia to pull in both a javascript ViewModel as well as an HTML View. Aurelia's loader will determine which file extension needs to be appended to the file name you provide. There is one exception to this rule, though, Aurelia provides for \"HTML-only Custom Elements.\" You must tell Aurelia that you are utilizing an HTML-only custom element by providing the .html extension in the from attribute. This is common source of confusion for Aurelia developers, so it is important to remember this nuance to using the require element! Info: The Inspiration for Require Aurelia's require element was inspired by the import statement in ES 2015. In the same way that modern JavaScript has modules which contain imports, so Aurelia's views are also modularized and can contain imports, which we accomplish via require. You may wonder why we didn't just name our element import instead of require. Those who have been using Aurelia for a while may remember that the initial name was in fact 'import'. The name was changed in order to enable compatibility with older version of Internet Explorer, which didn't like the use of import."},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"Global Resources","sectionId":"global-resources","id":1706,"text":"You are likely to have certain resources that you will use in multiple views while developing an Aurelia application. In these instances it might be wise to make these resources available globally in your application. Luckily, Aurelia provides you with this capability in a simple fashion. This is typically done at application startup in your main.js file (or whatever you call your application startup file). The FrameworkConfiguration class provides the globalResources which takes one or more strings that are paths to a resource as parameters. Globalized resources do not need to be required into a template. The file you use to configure Aurelia will have a configure method. Aurelia will call this method and pass an instance of the Aurelia class to it. This class provides a fluent interface for accessing the FrameworkConfiguration object via its use property. The methods on the FrameworkConfiguration object return the FrameworkConfiguration object to allow you to chain multiple calls together as shown below. Note that the same rules regarding file extensions (only include it for HTML-only custom elements) apply for the paths passed to globalResources.  You can globalize anything you would use the require element for, including Custom Elements, HTML-only Custom Elements, Custom Attributes, Value Converters and Binding Behaviors."},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"Creating Bindable Properties on an HTML Behavior","sectionId":"creating-bindable-properties-on-an-html-behavior","id":1707,"text":"As you likely know by now, one of Aurelia's key features is its strong data-bind system, and I'm sure you're itching to know how to create bindable properties on your HTML Behaviors. Well, you're in luck, as we're now ready to discuss the @bindable decorator. One last thing though: this section is a very basic introduction to creating bindable properties, and does not fully explore the topic. For a full explanation, we encourage you to check out the Custom Element and Custom Attribute documentation. The @bindable decorator can be imported from the aurelia-framework module. When you put the @bindable decorator on a property in your ViewModel, Aurelia will now allow you to bind to this property using all the binding commands Aurelia offers (bind, two-way, one-way, one-time, etc.). Let's look at a simple example in a Custom Element. The page's name property will be bound to the customerName property of the greet-customer Custom Element. Note that the previously mentioned convention of converting JavaScript names to dash-case applies with bindable property names. They are converted from camelCase to dash-case when they appear as attributes in HTML. By default, bindable properties only allow one-way data binding. This means that data will flow into the HTML Behavior, but not out of the custom element. Luckily, this can be overridden, or be made explicit by passing a configuration object to the @bindable decorator with a property named defaultBindingMode set to one of the values of the bindingMode enumeration. This enumeration is located in the aurelia-framework module and has three values: oneWay, twoWay, and oneTime. Here is a quick example of how to set the default binding mode for a property to two-way: Binding with Custom Attributes is a bit more nuanced than Custom Elements in that Custom Attributes support three types of binding: single value, options binding, and dynamic options binding. In this document, we will only look at single value binding. Please check out the Custom Attribute documentation for examples of how to implement and use all three types of bindings. The @bindable decorator isn't used when doing single value binding with a Custom Attribute because all attributes have a value property by default. This is ensured by Aurelia. Instead, we implement a valueChanged callback function that Aurelia calls to alert us that the bound value of the Custom Attribute has changed. Aurelia will set the value to the value property of the Custom Attribute's ViewModel, and will pass two parameters to the valueChanged callback: the new value and the old value. Let's look at an example. Aurelia will call the valueChanged callback whenever the bound value changes. This gives the attribute a chance to change the background color of the element. In this example, we don't even need to use the value property that Aurelia has set for us."},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"Inheritance with HTML Behaviors","sectionId":"inheritance-with-html-behaviors","id":1708,"text":"For developers who want to leverage inheritance, bindable properties can be inherited through the class hierarchy for custom elements only (not custom attributes). In the following example we create a generic icon button component, icon-button, that is integrated with font awesome. The next component extends the generic button, setting its default icon as well as a different onClick behavior. First, notice that in the above example, we declared @useView('./icon-button.html') to use the same view as the base class. If we had not supplied this, the framework would look for ./add-button.html instead. Second, notice that we explicitly declared @customElement(). Any time you inherit a custom element, you must add the customElement decorator. Here's how these components would be used in a view:"},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"HTML-Only Custom Elements","sectionId":"html-only-custom-elements","id":1709,"text":"Earlier, we said that there is one exception to the rule that all HTML Behaviors must have a JavaScript class to act as a ViewModel, but we never explained just what that exception is. The exception is HTML Only Custom Elements. Aurelia provides you with the ability to create Custom Elements without needing to create a ViewModel class. This is great for those cases where you want to encapsulate something in to its own Custom Element, but whatever you are encapsulating isn't complex enough to need any complex logic and doesn't have any dependencies like data services. Creating an HTML Only Custom Element is as simple as creating an HTML view file and then requiring it in to your view with the .html extension, as mentioned in the \"Making an HTML Behavior Available in a View\" section above. You can even have bindable properties on your HTML Only Custom Element. These properties default to one-way databinding, but you can't change the default, though you are still free to explicitly set the binding direction when you bind to the Custom Element. To create bindable properties, just supply a comma separated list of property names to the bindable attribute on the template element as shown below."},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"HTML Behavior Lifecycle","sectionId":"html-behavior-lifecycle","id":1710,"text":"All HTML Behaviors have a well defined lifecycle. Using this lifecycle, you can tap in and trigger code to run when appropriate. Below is a listing of the standard lifecycle callbacks: constructor() - The view-model's constructor is called first. created(owningView: View, myView: View) - If the view-model implements the created callback it is invoked next. If your behavior is a custom element, it's view has also been created and both the view-model and the view are connected to their controller. The created callback will receive the instance of the \"owningView\". This is the view that the component is declared inside of. If the component itself has a view, this will be passed second. bind(bindingContext: Object, overrideContext: Object) - Databinding is then activated on the view and view-model. If the view-model has a bind callback, it will be invoked at this time. The \"binding context\" to which the component is being bound will be passed first. An \"override context\" will be passed second. The override context contains information used to traverse the parent hierarchy and can also be used to add any contextual properties that the component wants to add. It should be noted that when the view-model has implemented the bind callback, the databinding framework will not invoke the changed handlers for the view-model's bindable properties until the \"next\" time those properties are updated. If you need to perform specific post-processing on your bindable properties, when implementing the bind callback, you should do so manually within the callback itself. attached() - Next, the component is attached to the DOM (in document). If the view-model has an attached callback, it will be invoked at this time. detached() - At some point in the future, the component may be removed from the DOM. If/When this happens, and if the view-model has a detached callback, this is when it will be invoked. unbind() - After a component is detached, it's usually unbound. If your view-model has the unbind callback, it will be invoked during this process. Info: Bind callback stops initial \"Changed\" callbacks It should be noted that when the view-model has implemented the bind callback, the databinding framework will not invoke the changed handlers for the view-model's bindable properties until the \"next\" time those properties are updated. If you need to perform specific post-processing on your bindable properties, when implementing the bind callback, you should do so manually within the callback itself. For example, if you have a bindable property foo, implement the fooChanged callback, and you want fooChanged to be called on initial binding, then you will need to call it from within your bind() callback. Tapping into a lifecycle event is as simple as implementing any of the above methods on the behavior's view-model class. Here's an example of a custom attribute that uses the attached and detached callbacks, something common when wrapping jQuery plugins:"},{"articleName":"HTML Behaviors","articleHref":"docs/templating/html-behaviors-introduction","sectionName":"Conclusion","sectionId":"conclusion","id":1711,"text":"If you've made it this far, you should have the basics down of creating HTML Behaviors. HTML Behaviors in Aurelia can be a Custom Element or a Custom Attribute. Both of these have ViewModels, while only Custom Elements can have Views. There is no need to use jQuery or document.querySelector to get the DOM Element your behavior is associated with, as you can simply have Aurelia inject it in to your ViewModel. You must make sure that an HTML Behavior is accessible to the template you are using it in, either by using the require element or by making the behavior a global resource. When doing either of these, you do not provide a file extension in the path for the behavior, unless you are specifying an HTML Only Custom Element. You can create bindable properties for your Custom Elements by using the @bindable decorator, while Aurelia will call the valueChanged callback on your CustomAttribute's ViewModel if you are doing single-value binding to your Custom Attribute. And finally, HTML Only Custom Elements can have bindable properties if you specify them in the bindable attribute on the template element. Now that you've got a solid foundation, we encourage you to read the more advanced and in-depth documentation regarding both Custom Elements and Custom Attributes! Happy Coding! "},{"articleName":"Custom Elements","articleHref":"docs/templating/custom-elements","sectionName":"Introduction","sectionId":"introduction","id":1712,"text":"Custom elements are the primary tool an Aurelia application developer will utilize for componentizing an application."},{"articleName":"Custom Elements","articleHref":"docs/templating/custom-elements","sectionName":"HTML Only Custom Element","sectionId":"html-only-custom-element","id":1713,"text":"The simplest way to create an Aurelia custom element is to create an Aurelia view template in an HTML file and then require it in to another Aurelia view template. HTML only custom elements are a highly useful strategy for dealing with functionality that has no need for ViewModel logic but is likely to be reused. The element name will be the same as the HTML file name, without the extension. When requiring an HTML only custom element in to a view, you must include the .html extension.  It is even possible to create bindable properties for an HTML only custom element by putting a comma separated list of property names on the bindable attribute of the template element. The Aurelia convention of converting camelCase bindable properties to dash-case applies to properties provided to the bindable attribute, as shown in the following example. HTML only custom elements may require in other custom elements and attributes as well as utilizing any other view resource just like any other Aurelia component may. HTML only custom elements also support explicit two-way databinding for properties, though it is not possible to create properties that default to two-way databinding with HTML only custom elements. For that type of functionality, you will need to provide a ViewModel for your custom element. The following example shows an Aurelia view utilizing two-way databinding to an example HTML only custom element. The example HTML only custom element itself requires in other custom elements, and utilizes two-way databinding to those custom elements. Note that it is possible to use the full power of Aurelia's templating engine from an HTML custom element, such as using the debounce binding behavior."},{"articleName":"Custom Elements","articleHref":"docs/templating/custom-elements","sectionName":"Custom Element Basics","sectionId":"custom-element-basics","id":1714,"text":"Creating custom elements using Aurelia is extremely simple. Simply creating a JavaScript and HTML file pair with the same name is all that is necessary to create an Aurelia custom element. The HTML file must contain an Aurelia template wrapped in a template element. The JavaScript file must export a JavaScript class. Aurelia's standard naming convention for custom element VM classes is to append CustomElement to the end of the class name, e.g. SecretMessageCustomElement. Aurelia will take the JavaScript class name, strip CustomElement from the end, and convert it from InitCaps to dash-case for the custom element's name. Note that this means it is possible for the custom element name to not match the file name. Thus, it is recommended to name your custom element files to match the custom element name. It is acceptable to export more than one class from the JavaScript file for a custom element. Aurelia will use the first class exported from the file as the custom element's view-model (VM). Note that each instance of a custom element will receive its own separate VM instance. Custom elements are not allowed to be self-closing. This means that <secret-message> will not work. When using a custom element, you must provide a closing tag as shown in app.html below. It is also possible to explicitly name your custom element by using the customElement decorator on the VM class. Simply pass a string to this decorator with the exact name you wish to use for your custom element. Aurelia will not convert the string you pass it to dash-case. This means that @customElement('SecretMessage') is not converted to secret-message but to secretmessage. If any uppercase letters are passed to the decorator and development logging is enabled, Aurelia will log a message alerting you that it has lowercased the name. This is because the DOM is not case-sensitive. Thus you must be explicit about any dashes in the attribute name when using this decorator, e.g. @customElement('secret-message'). Aurelia custom elements do not need to follow the naming conventions for Web Components custom elements. Namely, Aurelia allows you to create custom elements that do not have a dash in their name. This is because the Web Components specs reserve all single-word element names for the browser. Thus, you are free to create a foo custom element with Aurelia; however, it is recommended to refrain from creating single-world custom elements to avoid any chance of a possible naming clash in the future. Also, any Aurelia custom elements that are intended to be used as standalone Web Components custom elements MUST have a dash in their name. Before we move on, let's discuss just how easy it is to create a custom element in Aurelia and the impact it has on Aurelia's naming conventions for custom element view-model classes. One capability of the Aurelia framework is that it can take components that were originally created for use as a page in an application and use them as custom elements. When this happens, Aurelia will use the component's VM class name, dash-case it and use that as the custom element's name. Let's say there is an Aurelia application that provides various pages, one of which is the Contact page. All it takes to use the Contact page as a custom element on any page in the application is to require it in to the view. At that point, it is available as the contact custom element in that view. It is even possible to provide bindable properties for the page that can be used when using the page as a custom element. This means that, if you wish, you may ignore the Aurelia naming convention for your custom elements. In the example above, we could have simply named the class SecretMessage. The custom element would still be named secret-message. Given this capability, it might be considered wise to utilize Aurelia's naming convention for custom elements or use the customElement decorator to be explicit when creating a component that is only meant to be used as a custom element and not as a standalone page."},{"articleName":"Custom Elements","articleHref":"docs/templating/custom-elements","sectionName":"Bindable Properties","sectionId":"bindable-properties","id":1715,"text":"Any properties or functions of the VM class may be used for binding within the custom element's view; however, a custom element must specify the properties that will be bindable as attributes on the custom element. This is done by decorating each bindable property with the bindable decorator. The default binding mode for bindable properties is one-way. This means that a property value can be bound in to your custom element, but any changes the custom element makes to the property value will not be propogated out of the custom element. This default may be overridden, if needed, by passing a settings object to the bindable decorator with a property named defaultBindingMode set. This property should be set to one of the three bindingMode options: oneTime, oneWay, or twoWay. Both bindable and bindingMode may be imported from the aurelia-framework module. Let's look at an example custom element with a bindable property that defaults to two-way binding. In this example, the secret-message custom element will check every ten seconds to see if it needs to destroy (set to an empty string) the message it receives via databinding. When told to destroy the message, Aurelia's databinding system will update the bound property of the component using the custom element, thanks to the custom element specifying that this property's default binding mode is two-way. Thus, the text box will be cleared when the message \"self destructs.\"  Of course, the component using the custom element is free to override this default by explicitly specifying the binding direction via the one-way, two-way, or one-time binding commands. Whether a secret message that is only shown to the person who writes the message is very useful is for you to decide."},{"articleName":"Custom Elements","articleHref":"docs/templating/custom-elements","sectionName":"Surrogate Behaviors","sectionId":"surrogate-behaviors","id":1716,"text":"Surrogate behaviors allow you to add attributes, event handlers, and bindings on the template element for a custom element. This can be extremely useful in many cases, but one particular area that it is helpful is with dealing with aria attributes to help add accessibility to your custom elements. When using surrogate behaviors, you add attributes to the template element for your custom element. These attributes will be placed on the custom element itself at runtime. For example, consider the view for a my-button custom element: The role=\"button\" attribute will automatically be set on the my-button element whenever it used in an Aurelia application. If you were to check your browser's Dev Tools while running a template that used the my-buttom custom element, you will see something that looks like the below It is important to note that Surrogate Behaviors cannot be used with a custom element that is using the @containerless decorator discussed below as this decorator removes the wrapping custom element from the DOM, and thus there is nowhere for the Surrogate Behaviors to be placed."},{"articleName":"Custom Elements","articleHref":"docs/templating/custom-elements","sectionName":"Basic Content Projection","sectionId":"basic-content-projection","id":1717,"text":"So far, we've only talked about custom elements that look like <custom-element attr.bind=\"vmProp\"></custom-element>. Now it's time to look at creating custom elements that have content inside them. Let's create a name tag custom element. When the name-tag element is used, it will take the name it will display as content in the element. Aurelia custom elements utilize the \"slot based\" content projection standard from the Web Component specifications. Let's look at how this will work with our name-tag element. This custom element utilizes a single slot, so we simply need to add a <slot></slot> element in our template where we would like content to be projected. Aurelia will project the element's content in to the template where the <slot></slot> element is located."},{"articleName":"Custom Elements","articleHref":"docs/templating/custom-elements","sectionName":"Decorators for Customizing Aurelia Custom Element Processing","sectionId":"decorators-for-customizing-aurelia-custom-element-processing","id":1718,"text":"There are lots of options that allow you to change how custom elements work. These are expressed by decorators added to the custom element's viewmodel or properties on the viewmodel. @children(selector) - Decorates a property to create an array on your class that has its items automatically synchronized based on a query selector against the element's immediate child content. @child(selector) - Decorates a property to create a reference to a single immediate child content element. @processContent(false|Function) - Tells the compiler that the element's content requires special processing. If you provide false to the decorator, the compiler will not process the content of your custom element. It is expected that you will do custom processing yourself. But, you can also supply a custom function that lets you process the content during the view's compilation. That function can then return true/false to indicate whether or not the compiler should also process the content. The function takes the following form function(compiler, resources, node, instruction):boolean @useView(path) - Specifies a different view to use. @noView(dependencies?) - Indicates that this custom element does not have a view and that the author intends for the element to handle its own rendering internally. This is extremely useful when \"wrapping\" legacy JavaScript widgets that programatically create their markup @inlineView(markup, dependencies?) - Allows the developer to provide a string that will be compiled into the view. @useShadowDOM() - Causes the view to be rendered in the ShadowDOM. When an element is rendered to ShadowDOM, a special DOMBoundary instance can optionally be injected into the constructor. This represents the shadow root. @containerless() - Causes the element's view to be rendered without the custom element container wrapping it. This cannot be used in conjunction with @child, @children or @useShadowDOM decorators. It also cannot be used with surrogate behaviors. Use sparingly. @viewResources(...dependencies) - Adds dependencies to the underlying View. Same as: <require from=\"...\"></require>, but declared in the ViewModel. Arguments can either be strings with moduleIds, Objects with src and optionally as properties, or classes of the module to be included."},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Introduction","sectionId":"introduction","id":1719,"text":"Custom attributes are a category of view resource, just like value converters, binding behaviors and custom elements.  Custom attributes provide the ability to alter the behavior or add functionality to any DOM element. Custom attributes may work by simply being added to a DOM element, or they may require that a value be set for the attribute. The value may be a simple value, or a complex set of options. These options may or may not be known when a custom attribute is developed. Aurelia provides simple APIs to create custom attributes of all of these types, while the Aurelia templating engine provides strong databinding capabilities for custom attributes. Many custom attributes will work directly on the DOM element they are attached to. It is not necessary to search the DOM for the element a custom attribute is attached to. This is accomplished simply by requesting the element be injected into the attribute by Aurelia's Dependency Injection system. Simply request for an object of type Element to be injected in to your attribute. Aurelia will ensure you are provided with the DOM element the attribute has been attached to."},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Simple Custom Attribute","sectionId":"simple-custom-attribute","id":1720,"text":"The simplest custom attribute to create is one that changes the behavior of an element merely by being added to the element. The following attribute will make an HTML element be displayed as a 100 pixel square with a red background. The attribute name is inferred via an Aurelia convention. This convention is \\${Name}CustomAttribute for the ECMAScript class name. The class name is in \"init caps\" format. Aurelia converts this to \"dash-case\" format for use in HTML. Thus, RedSquareCustomAttribute becomes red-square."},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Explicit Attribute Naming","sectionId":"explicit-attribute-naming","id":1721,"text":"Overriding the default naming convention is possible by utilizing the @customAttribute decorator. Provide this decorator with the exact name for your attribute as below. Note that Aurelia does not convert from \"init caps\" to \"dash-case\" when using this decorator. It uses the exact value passed to the decorator."},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Single Value Binding","sectionId":"single-value-binding","id":1722,"text":"Aurelia custom attributes support three different types of binding: single value binding, options binding, and dynamic options binding. The simplest of the three binding types is single value binding. Aurelia will automatically set the value property on the attribute's view-model. Note that this property is not set until databinding is complete. This means the value property will not be set in the custom attribute's constructor or in its created lifecycle event. It is available in the bind and later lifecycle events. Note that in the above code sample, the color of the square will not be updated, even if the bound value is changed. This is because the attribute is not notified when the value property changes. Aurelia can notify a custom attribute when its value has changed, via the valueChanged(newValue, oldValue) callback function. The valueChanged callback function, if implemented on the view-model, will be called whenever the attribute's value changes. This function has two optional parameters, newValue and oldValue. These parameters will be set to the new value of the attribute and old value of the attribute, respectively. The value property is still set by Aurelia even if the valueChanged function is implemented. Note that if you implement both the bind and valueChanged callbacks, only bind will be called when the value is initially bound. If you implement only the valueChanged function, then it will be called when the value is initially bound. When the user updates the value of the color property via the textbox, Aurelia will call the valueChanged method on the custom attribute to alert the custom attribute to the change."},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Options Binding","sectionId":"options-binding","id":1723,"text":"Options binding provides a custom attribute the ability to have multiple bindable properties. Each bindable property must be specified using the bindable decorator. The attribute view-model may implement an optional \\${propertyName}Changed(newValue, oldValue) callback function for each bindable property. When binding to these options, separate each option with a semicolon and supply a binding command or literal value as in the example below. It is important to note that bindable properties are converted to dash-case when used in the DOM, while the VM property they are bound to are kept with their original casing."},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Default Option","sectionId":"default-option","id":1724,"text":"A single bindable property can be made the default among all the options in an options binding.  Thus, when you use a custom attribute that would otherwise require using the options HTML syntax, and you want to provide a value or binding only for the default property, then you can use the simpler HTML syntax of a single value binding. With options bindings each bindable property must be decorated with the bindable decorator.  To specify that you want a bindable property to be the default among all the other bindable properties, use the primaryProperty configuration parameter of the bindable decorator, as shown below: Then when you use the custom attribute, instead of this: You can do this: Or if you don't care about binding, then this:"},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Dynamic Options Binding","sectionId":"dynamic-options-binding","id":1725,"text":"Utilizing dynamic options, a custom attribute may deal with bindable properties where the name of the property is not known when creating the attribute. Simply decorate the attribute's view-model with the dynamicOptions decorator and implement the propertyChanged(name, newValue, oldValue) callback function. Aurelia will provide the name of the option that has changed along with new and old values for the option. Binding to a dynamic options attribute works exactly the same as binding to an options attribute in the DOM."},{"articleName":"Custom Attributes","articleHref":"docs/templating/custom-attributes","sectionName":"Globally Accessible Custom Attributes","sectionId":"globally-accessible-custom-attributes","id":1726,"text":"In all of our examples, we've been using the require element to import custom attributes we need into our view.  There's an easier way.  If you have some commonly used custom attributes that you'd like to make globally available, use Aurelia's globalResources function to register them.  This will eliminate the need to require elements at the top of every view."},{"articleName":"Content Projection","articleHref":"docs/templating/content-projection","sectionName":"Introduction","sectionId":"introduction","id":1727,"text":"Most of the standard HTML elements allow for content inside them. Custom Elements would be of limited use if we couldn't put content inside them. Thus, we need a way to take this content and place it inside our custom element's template. The Shadow DOM spec provides the slot processing instruction for doing this. Let's explore the various strategies available for utilizing content projection."},{"articleName":"Content Projection","articleHref":"docs/templating/content-projection","sectionName":"Basic Content Projection","sectionId":"basic-content-projection","id":1728,"text":"Let's create a name tag custom element. When the name-tag element is used, it will take the name it will display as content in the element. Aurelia custom elements utilize the \"slot based\" content projection standard from the Web Component specifications. Let's look at how this will work with our name-tag element. This custom element utilizes a single slot, so we simply need to add a <slot></slot> element in our template where we would like content to be projected. Aurelia will project the element's content in to the template where the <slot></slot> element is located."},{"articleName":"Content Projection","articleHref":"docs/templating/content-projection","sectionName":"Named Slots","sectionId":"named-slots","id":1729,"text":"The scenario above uses a \"default\" slot because the slot has no name attribute. In Shadow DOM, you can create as many slots as you want, provided that you give them different names. Then, the content that gets projected into the Shadow DOM must specify which slot it wants using a slot attribute. If it indicates no particular slot (or is plain text) it will get projected into the default slot. Here's an example of named slots:"},{"articleName":"Content Projection","articleHref":"docs/templating/content-projection","sectionName":"Fallback Slots","sectionId":"fallback-slots","id":1730,"text":"A nice feature of slots is that they can have fallback content. If nothing gets projected into the slot, the slot will render its fallback content: Ok, now it's time to get crazy. What if the fallback content generates more slots!? Those fallback slots can be targeted by the content. Here's an example based on a post from the WebKit team: That was fun! But we can go deeper. What about slots, that target other slots with fallback content that generates slots..."},{"articleName":"Content Projection","articleHref":"docs/templating/content-projection","sectionName":"Slot Implementation Limitations","sectionId":"slot-implementation-limitations","id":1731,"text":"At the time this document is written, no browser supports Shadow DOM v1 slots. Thus, Aurelia has implemented the specification. We haven't attempted to create a \"generic\" polyfill designed to be used outside of Aurelia. Our slots implementation is baked into Aurelia's templating compiler and renderer so that it can provide maximum performance and meet the needs of our community. We haven't attempted to implement all the APIs of the spec, but rather to emulate the declarative rendering capabilities of slots. By programming against Aurelia in this way, you don't need to worry about whether or not your browser does or does not support slots natively. Aurelia will take care of it for you. Known limitations of our implementation are as follows: You cannot data-bind the slot's name attribute. You cannot data-bind the slot attribute. You cannot dynamically generate slot elements inside a component's view. For example, the following would fail because the slot cannot be dynamic, however show.bind would be okay as the slot is generated but show hides it using css. Using template parts would be another alternative or applying if.bind to the content inside the slot."},{"articleName":"Dynamic UI Composition","articleHref":"docs/templating/dynamic-ui-composition","sectionName":"Introduction","sectionId":"introduction","id":1732,"text":"In this section, we are going to be learning how you can dynamically render components in your applications by utilizing Aurelia's dynamic composition functionality. In many respects, dynamic composition closely resembles that of how Aurelia's routing works. The big exception, of course, is dynamic composition allows you to dynamically render views and view-models after the page has loaded. When using Aurelia's <compose> element, inside of the view-model being used, you have access to all of Aurelia's standard view lifecycle events, such as attached, as well as the other callback hooks."},{"articleName":"Dynamic UI Composition","articleHref":"docs/templating/dynamic-ui-composition","sectionName":"Basic Composition","sectionId":"basic-composition","id":1733,"text":"Using the <compose> element, we are going to be dynamically composing a view. Inside of our hello-world.html template, we are using the <compose> element and passing through a view-model (without file extension) to be rendered. The view-model is just a standard class, like you create elsewhere in an Aurelia application. Because Aurelia is a convention based framework, the <compose> element knows to use the default convention of loading the matching view for our view-model of the same name."},{"articleName":"Dynamic UI Composition","articleHref":"docs/templating/dynamic-ui-composition","sectionName":"Composing Without a View-Model","sectionId":"composing-without-a-view-model","id":1734,"text":"If you're wanting to dynamically compose just a view template without specifying a view-model, all you need to do is omit the view-model property and supply a view. The result will be that the current view-model will be used as the binding context for our view, allowing you to create HTML partials that take the current properties and methods. For the view property, we need to specify a file extension, unlike the view-model property, which does not have an extension. The above example will work the same way as our first example, except we're not supplying our own view-model, it's inheriting the binding context from where the compose element is used."},{"articleName":"Dynamic UI Composition","articleHref":"docs/templating/dynamic-ui-composition","sectionName":"Passing Through Data","sectionId":"passing-through-data","id":1735,"text":"Using what we learned above, we can dynamically compose view-models and views and pass through additional data via the model property on the <compose> element. We are going to be building an example which will dynamically render a view/view-model pair and accept an object of provided values. If you have worked with the Aurelia router before and router parameters, you will notice we obtain the provided model object the same way: as the first argument of the activate method. We then store the object on our class itself, making it available in our HTML view under a property called data. Notice how we are referencing values on our provided object, name and company, and then looping over an array of provided strings for likes. Info While the full view lifecycle (created, bind, attached, detached, unbind) is supported during dynamic composition, the full navigation lifecycle is not. Only the activate hook is enabled. It receives a single parameter which is the model and can optionally return a promise if executing an asynchronous task. "},{"articleName":"HTTP","articleHref":"docs/plugins/http-services","sectionName":"Options","sectionId":"options","id":1736,"text":"When building front-end applications, it's often necessary to leverage HTTP services to acquire data or persist state. There are many ways to accomplish this. You could use an advanced data library that implements object-relational mapping, an opinionated restful client or just a simple HTTP library. All these options are provided by the global web community and all of them can be used in an Aurelia application. That said, the Aurelia team felt the need to provide a simple solution out of the box. We wanted our community to have a directly supported option while still keeping Aurelia open so that our own community could innovate or leverage any other library developed elsewhere. Along these lines, the Aurelia project provides two options: aurelia-http-client - A basic HttpClient based on XMLHttpRequest. It supports all HTTP verbs, JSONP and request cancellation. aurelia-fetch-client - A more forward-looking HttpClient based on the Fetch specification. It supports all HTTP verbs and integrates with Service Workers, including Request/Response caching. How should you choose between these two options? We recommend using aurelia-fetch-client if possible. It is based on the Fetch specification which will be the preferred way of handling all AJAX going forward. However, if you need request cancellation or download progress, the Fetch spec does not currently support these features. While these improvements to the spec are being considered for the future, it isn't available at present. So, if you need these capabilities, you may need to use aurelia-http-client instead."},{"articleName":"HTTP","articleHref":"docs/plugins/http-services","sectionName":"aurelia-fetch-client","sectionId":"aurelia-fetch-client","id":1737,"text":"As previously stated, the aurelia-fetch-client library aims to embrace and expose the new Fetch API, while providing features important in web applications: default configuration of request parameters, interceptors and centralized request tracking. The main method, HttpClient#fetch(), has the same signature as window.fetch(). The difference is that our HttpClient will apply default configuration values, execute any registered interceptors and track the number of active requests. Info: Learn About The Fetch Spec If you are looking for some information on the Fetch API specification, we recommend that you start with the MDN documentation. You may also find Jake Archibald's intro to the Fetch API useful. Bring Your Own Polyfill This library relies on the Fetch API, which is not yet supported by all popular browsers. This library does not include a polyfill for Fetch. If you need to support browsers that have not implemented Fetch, you will need to install a polyfill like GitHub's Fetch polyfill. First, install the polyfill using your package manager. Second, make sure to import the polyfill into your application code so that it's correctly initialized before you use our fetch client. The best place to load the polyfill is typically in your application's main module. That might look something like this: Info: Encapsulate HttpClient Use Generally, we recommend that you don't litter your application code with usage of the HttpClient. Instead, we reccommend that you create one or more service classes that encapsulate all HTTP access behind a friendly, application-specific API. If you do this, we also recommend that you import the fetch polyfill inside these service modules rather than in your application's main module. This helps to preserve the encapsulation. Basic Use Data requests are accomplished by calling the fetch method on an instance of HttpClient. By default, fetch makes GET requests. All calls to fetch return a Promise which will resolve to a Response object. Using this Response object, you can easily parse content, read headers and inspect status codes. See the Fetch API spec for more information. Below is a simple sample demonstrating a basic GET request to a JSON file, including parsing of the response content and writing data values out to the console. Configuration An HttpClient instance can be configured with several options, such as default headers and interceptors to be run on requests or responses. In the example above, withBaseUrl() is used to specify a base url that all fetches will be relative to. withDefaults() allows passing an object that can include any properties described in the optional init parameter to the Request constructor, and will be merged into the new Request before it is passed to the first request interceptor. withInterceptor() enables passing an object which can provide any of these four optional methods: request, requestError, response, and responseError. Here's an explanation of how each of these methods work: request takes the Request that will be passed to window.fetch() after interceptors run. It should return the same Request, or create a new one. It can also return a Response to short-circuit the call to fetch() and complete the request immediately. Errors thrown in request interceptors will be handled by requestError interceptors. requestError acts as a Promise rejection handler during Request creation and request interceptor execution. It will receive the rejection reason, and can either re-throw, or recover by returning a valid Request. response will be run after fetch() completes, and will receive the resulting Response. As with request, it can either pass the Response along, return a modified response, or throw. responseError is similar to requestError, and acts as a Promise rejection handler for response rejections. These methods on the interceptor object can also return Promises for their respective return values. Helpers The Fetch API has a couple gotchas, documented by the GitHub Fetch polyfill docs. aurelia-fetch-client provides configuration helpers to apply the changes suggested by the polyfill docs. config.rejectErrorResponses() will add a response interceptor that causes responses with unsuccessful status codes to result in a rejected Promise. config.useStandardConfiguration() will apply rejectErrorResponses(), and also configure credentials: 'same-origin' as a default on all requests. The Fetch API has no convenient way of sending JSON in the body of a request. Objects must be manually serialized to JSON, and the Content-Type header set appropriately. aurelia-fetch-client includes a helper called json for this. A Complete Example This example creates a new HttpClient and configures it for use with an imaginary JSON API for managing comments at api/. The client is then used to POST a new comment to the API and display an alert dialog with the assigned comment ID. Limitations This library does not include a polyfill for Fetch. If you need to support browsers that have not implemented Fetch, you will need to install a polyfill like GitHub's Fetch polyfill. This library does not work around any of the existing limitations in the Fetch API, including: Fetch does not currently support aborting requests or specifying request timeouts. Fetch does not currently support progress reporting. JSONP support is not currently provided by this library. The Request constructor provides its own default values, so if a Request is created before invoking HttpClient#fetch (eg, the HttpClient#fetch(request) signature is used instead of the HttpClient#fetch(url, params) signature), there is no way for the client to know which default values to merge into the Request. The base URL and headers can be merged, but currently no other defaults will be applied in this case. If your application has requirements that don't fit within these limitations, then you may want to look into using aurelia-http-client instead."},{"articleName":"HTTP","articleHref":"docs/plugins/http-services","sectionName":"aurelia-http-client","sectionId":"aurelia-http-client","id":1738,"text":"In addition to aurelia-fetch-client, Aurelia includes a basic HttpClient to provide a comfortable interface to the browser's XMLHttpRequest object. Like aurelia-fetch-client, aurelia-http-client is not included in the modules that Aurelia's bootstrapper installs, since it's completely optional and many apps may choose to use a different strategy for data retrieval. So, if you want to use it, first you must install it with your preferred package manager. Basic Use Once installed, you can use it like this: The HttpClient has a variety of methods. The following is a description of the APIs available. As you can see, the API provides convenience methods for all the standard verbs as well as jsonp. Each of these methods sends an HttpRequestMessage except jsonp which sends a JSONPRequestMessage. The result of sending a message is a Promise for an HttpResponseMessage. The HttpResponseMessage has the following properties: response - Returns the raw content sent from the server. responseType - The expected response type. content - Formats the raw response content based on the responseType and returns it. headers - Returns a Headers object with the parsed header data. statusCode - The server's response status code. statusText - The server's textual status message. isSuccess - Indicates whether or not the status code falls within the success range. reviver - A function used to transform the raw response content. requestMessage - A reference to the original request message. Info: JSON By Default By default, the HttpClient assumes you are expecting a JSON responseType. Configuration You can use configure to access a fluent api for configuring all requests sent by the client. You can also use createRequest to custom configure individual requests. Here's an example of configuration: In this case, all requests from the client will have the base url of 'http://aurelia.io' and will have the specified Authorization header. The same API is available via the RequestBuilder. So, you can accomplish the same thing on an individual request like this: The fluent API has the following chainable methods: asDelete(), asGet(), asHead(), asOptions(), asPatch(), asPost(), asPut(), asJsonp(), withUrl(), withBaseUrl(), withContent(), withParams(), withResponseType(), withTimeout(), withHeader(), withCredentials(), withReviver(), withReplacer(), withProgressCallback(), and withCallbackParameterName(). It is possible to hook into requests and responses with interceptors as well. Here's an example: All interceptors used with a client form a chain. The return value of an intercept method is passed on as the argument to the next. Interceptors are called in the order they were added. See the aurelia-fetch-client interceptor documentation for more information on interceptors."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Basic Configuration","sectionId":"basic-configuration","id":1739,"text":"To use Aurelia's router, your component view must have a <router-view></router-view> element. In order to configure the router, the component's view-model requires a configureRouter() function. config.map() adds route(s) to the router. Although only route, name, moduleId, href and nav are shown above there are other properties that can be included in a route. The interface name for a route is RouteConfig. You can also use config.mapRoute() to add a single route. route - is the pattern to match against incoming URL fragments. It can be a string or array of strings. The route can contain parameterized routes or wildcards as well. Parameterized routes match against a string with a :token parameter (ie: 'users/:id/detail'). An object with the token parameter's name is set as property and passed as a parameter to the route view-model's activate() function. A parameter can be made optional by appending a question mark :token? (ie: users/:id?/detail would match both users/3/detail and users/detail). When an optional parameter is missing from the url, the property passed to activate() is undefined. Wildcard routes are used to match the \"rest\" of a path (ie: files/*path matches files/new/doc or files/temp). An object with the rest of the URL after the segment is set as the path property and passed as a parameter to activate() as well. name - is a friendly name that you can use to reference the route with, particularly when using route generation. moduleId - is the id (usually a relative path) of the module that exports the component that should be rendered when the route is matched. href - is a conditionally optional property. If it is not defined then route is used. If route has segments then href is required as in the case of files because the router does not know how to fill out the parameterized portions of the pattern. nav - is a boolean or number property. When set to true the route will be included in the router's navigation model. When specified as number, the value will be used in sorting the routes. This makes it easier to create a dynamic menu or similar elements.  The navigation model will be available as array of NavModel in router.navigation. These are the available properties in NavModel: isActive flag which will be true when the associated route is active. title which will be prepended in html title when the associated route is active. href can be used on a tag. config is the object defined in config.map. settings is equal to the property settings of config object. router is a reference for AppRouter. Other properties includes relativeHref and order. title - is the text to be displayed as the document's title (appears in your browser's title bar or tab). It is combined with the router.title and the title from any child routes. titleSeparator - is the text that will be used to join the title and any active route.titles. The default value is ' | '. Navigation States The router contains a number of additional properties that indicate the current status of router navigation. These properties are only set on the base router, i.e. not in child routers. Additionally, these properties are all with respect to browser history which extends past the lifecycle of the router itself. router.isNavigating: true if the router is currently processing a navigation. router.isNavigatingFirst: true if the router is navigating into the app for the first time in the browser session. router.isNavigatingNew: true if the router is navigating to a page instance not in the browser session history. This is triggered when the user clicks a link or the navigate function is called explicitly. router.isNavigatingForward: true if the router is navigating forward in the browser session history. This is triggered when the user clicks the forward button in their browser. router.isNavigatingBack: true if the router is navigating back in the browser session history. This is triggered when the user clicks the back button in their browser or when the navigateBack() function is called. router.isNavigatingRefresh: true if the router is navigating due to a browser refresh. router.isExplicitNavigation: true if the router is navigating due to explicit call to navigate function(s). router.isExplicitNavigationBack: true if the router is navigating due to explicit call to navigateBack function. Webpack Configuration When using Webpack it is necessary to help Aurelia create a path that is resolvable by the loader. This is done by wrapping the moduleId string with PLATFORM.moduleName(). You can import PLATFORM into your project from either aurelia-framework or aurelia-pal. See Managing dependencies for more information on PLATFORM.moduleName()."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Options","sectionId":"options","id":1740,"text":"Push State Set config.options.pushState to true to activate push state and add a base tag to the head of your html document. If you're using JSPM, RequireJS or a similar module loader, you will also need to configure it with a base url, corresponding to your base tag's href. Finally, be sure to set the config.options.root to match your base tag's setting. Warning PushState requires server-side support. Don't forget to configure your server appropriately."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Dynamically Specify Route Components","sectionId":"dynamically-specify-route-components","id":1741,"text":"You can add a navigationStrategy to a route to allow dynamic routes. Within the navigation strategy Aurelia requires you to configure instruction.config with the desired moduleId, viewPorts or redirect."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Adding Additional Data To A Route","sectionId":"adding-additional-data-to-a-route","id":1742,"text":"Although Aurelia does allow you to pass any additional property to a route's configuration object, settings is the default parameter to which you should add arbitrary data that you want to pass to the route."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Case Sensitive Routes","sectionId":"case-sensitive-routes","id":1743,"text":"You can set a route to be case sensitive, should you wish: In the above example, our route will only match URL fragment of /users and not /Users, but since the route home is not case sensitive the URL /Home would match. By default Aurelia's routes are not case sensitive."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Handling Unknown Routes","sectionId":"handling-unknown-routes","id":1744,"text":"Aurelia allows you to map any unknown routes. Parameters passed to mapUnknownRoutes() can be: A string to a moduleId. This module will be navigated to any time a route is not found. A routeConfig object. This configuration object will be used any time a route is not found. A function which is passed the NavigationInstruction object and can decide the route dynamically. Using a  The above example will make any unmatched routes to load the not-found component module. Using A Function For Unknown Routes The function passed to mapUnknownRoutes() has to return: A string representing moduleId. An object with property moduleId of type string. A RouteConfig object. A Promise that resolves to any of the above."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Redirecting Routes","sectionId":"redirecting-routes","id":1745,"text":"Aurelia allows redirecting of routes to URL fragments by specifying redirect with a string consisting of a URL fragment. Info: Use Redirect On Empty Routes with Child Routers The redirect is particularly useful when you have an \"empty\" route pattern (such as the first route above) that maps to a component with a child router. In this case, create a non-empty route and then redirect the empty route to the non-empty route (as above). This will enable the child router to consistently match child routes without getting confused in scenarios where the empty route was matched."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Pipelines","sectionId":"pipelines","id":1746,"text":"Aurelia has two router classes, AppRouter and Router. AppRouter extends the Router class and is the main application router. Router is used for any child routers including nested child routers. One of the main differences between the two is pipelines are only allowed on the AppRouter and not any child routers. The default pipeline slots in order are authorize, preActivate, preRender, and postRender. For each slot, Aurelia has convenience functions for creating a pipeline step for these slots: addAuthorizeStep, addPreActivateStep, addPreRenderStep, addPostRenderStep. You can create your own pipeline steps using addPipelineStep, but the step's name must match one of the default pipeline's slots. authorize is called between loading the route's step and calling the route view-model' canActivate function if defined. preActivate is called between the route view-model' canActivate function and the previous route view-model's deactivate function if defined. preRender is called between the route view-model's activate function and before the component is rendered/composed. postRender is called after the component has been render/composed. A pipeline step must be an object that contains a run(navigationInstruction, next) function."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Rendering View Ports","sectionId":"rendering-view-ports","id":1747,"text":"Every instance of a router-view custom element essentially defines a \"view port\". When you give a router-view a name, you can refer to it in the viewPorts property of the route configuration in your javascript. The value of a viewPorts property is an object where each property name is the name of a view port (ie, router-view) and each value is the moduleId destination of the route. Thus you can specify any number of view ports on a single route configuration. Info If you don't name a router-view, it will be available under the name 'default'. Following is an example of the use of view ports: Empty View Ports You can empty a view port by setting moduleId null in the route configuration for that view port. View Port Defaults The empty view port is actually the out-of-the-box default. You can override this default to load a specific moduleId whenever moduleId is null by passing a view port configuration to the router configuration. These overrides can be set specifically to each view port. Optional View Ports If a view port configuration is not defined on a route, the router will skip routing on that particular view port leaving the view port untouched. If there is no existing content in the view port, i.e. when the application is first loaded, the view port will be populated with the view port default configuration, which is empty if not otherwise specified (see View Port Defaults). Info In addition to the moduleId, you can also specify a \"layout\" in the configuration of a view port (see Layouts)."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Layouts","sectionId":"layouts","id":1748,"text":"Similar to MVC-style master/layout pages, Aurelia allows you to use a \"layout\" view like an MVC \"master template\" for a set of views. The set of views subject to being part of a layout is defined in Aurelia as a set of views referenced by one or more routes in a router configuration. There are two ways to associate a layout with routes. The first is via HTML, the second is via view model code. Info We're going to be a little sloppy here in terminology. Technically, routes refer to \"moduleIds\", not \"views\". Since the router resolves a moduleId to a view, indirectly the router does reference a view. It is easy to picture a view visually contained within a layout, so in this topic to we'll refer to views referenced by a route, not modules. We'll look at using HTML first. We know that the router-view custom HTML element is always associated with a set of one or more views referenced in a router configuration given in its parent view's view model. By associating a layout with a router-view one can thus associate a layout with the same set of views with which the router-view is associated. To specify a layout on the router-view custom element, we use the following attributes: layout-view - specifies the file name (with path) of the layout view to use. layout-view-model - specifies the moduleId of the view model to use with the layout view. layout-model - specifies the model parameter to pass to the layout view model's activate function. Info All of these layout attributes are bindable. Following is an example of HTML in which we specify that we want all destination views reachable under the router-view to be laid-out inside a view with file name layout.html, located in the same directory as the view contianing the router-view: Here is the layout view itself: And here we define a view that we want to appear within the layout: Observe how we use the slot mechanism for associating parts of the layout to parts of the views that are to be contained within the layout. (Happy for developers, this is conveniently the same mechanism and syntax we use in Aurelia when providing content to custom elements.) Now we just have to define the route configuration that will be associated with the router-view: Thus when we navigate to the module \"home\" we find that it is laid-out as desired inside the layout view. Note there is nothing different about the above route configuration with or without the layout.  It may reference any number of views that would all be included by default in the layout. So that is how we use HTML to associate a layout view with a set of views referenced in a router configuration. We can also associate layouts with route configurations using code in our view model. Suppose we like what we've done above, but we have a couple views that we would like to associate with a different layout and would thus like to partially override the configuration given in the HTML. The following code is an example of how we can do that: The above example will assign different layouts to the \"login\" and \"users\" views, overriding the HTML while leaving \"home\" to remain as configured in the HTML. Noticing we're using camel-cased property names here, unlike in the HTML. You can also specify a layout in the viewPorts configuration of a route. See a simple example, below:"},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"View Swapping and Animation","sectionId":"view-swapping-and-animation","id":1749,"text":"When the Aurelia router navigates from one view to another, we refer to this as \"swapping\" one view for another.  Aurelia gives us an optional set of strategies dictating how a swap proceeds, or more specifically, how animation plays out during the swap.  We refer to these strategies more precisely as the \"swap order\". Info If there is no animation defined, then swap-order has no visible impact. You can apply a swap strategy to one or more routes by applying the swap-order attribute to a router-view custom HTML element.  The strategy will then be applied in any transition between two views accessible under the router-view. Info swap-order is bindable. The following swap order strategies are available: before - animate the next view in before removing the current view with - animate the next view at the same time the current view is removed after - animate the next view in after the current view has been removed (the default) Here is an example of setting the swap order strategy on a router-view:"},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Internationalizing Titles","sectionId":"internationalizing-titles","id":1750,"text":"If your application targets multiple cultures or languages, you probably want to translate your route titles. The Router class has a transformTitle property that can be used for this. It is expected to be assigned a function that takes the active route's title as a parameter and then returns the translated title. For example, if your app uses aurelia-i18n, its routes' titles would typically be set to some translation keys and the AppRouter's transformTitle would be configured in such a way that the active route's title is translated using the I18N's tr method. Additionally you can listen to a custom event published by the I18N service to react on locale changes using the EventAggregator: The default value of thetransformTitle property does the following: For the child Router, it delegates to its parent's transformTitle function. For the AppRouter, it returns the title untransformed. In the previous example, the AppRouter's transformTitle is set, so all child Routers will delegate down to it by default. However, this means that the transformTitle can be overridden for specific child Routers if some areas of your app need custom transformation."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Configuring a Fallback Route","sectionId":"configuring-a-fallback-route","id":1751,"text":"Whenever navigation is rejected, it is redirected to a previous location. However in certain cases a previous location doesn't exist, e.g. when it happens as the first navigation after the startup of application. To handle this scenario, you can set up a fallback route."},{"articleName":"Router Configuration","articleHref":"docs/routing/configuration","sectionName":"Reusing an Existing View Model","sectionId":"reusing-an-existing-view-model","id":1752,"text":"Since the view model's navigation lifecycle is called only once, you may have problems recognizing that the user switched the route from Product A to Product B (see below). To work around this issue implement the method determineActivationStrategy in your view model and return hints for the router about what you'd like to happen. Available return values are replace and invoke-lifecycle. Remember, \"lifecycle\" refers to the navigation lifecycle. Info Alternatively, if the strategy is always the same and you don't want that to be in your view model code, you can add the activationStrategy property to your route config instead."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Introduction","sectionId":"introduction","id":1753,"text":"This article covers the Store plugin for Aurelia. It is built on top of two core features of RxJS, namely Observables and the BehaviorSubject. You don't have to delve into the reactive universe - in fact, you'll barely notice it at the beginning. But you can certainly benefit from having some knowledge about RxJS in order to use it wisely. Various examples, demonstrating individual pieces of the plugin, can be found in the samples repository. Reasons for state management A lot of modern development approaches leverage a single store, which acts as a central basis of your app. The idea is that it holds all data that makes up your application. The content of your store is your application's state. If you will, the app state is a snapshot of all data at a specific moment in time. You modify that by using Actions, which are the only way to manipulate the global state, and create the next app state. Contrast this to classic service-oriented approaches, where data is split amongst several service entities. What turns out to be a simpler approach, in the beginning, especially combined with a powerful IoC Container, can become a problem once the size of the app grows. Not only do you start to get increased complexity and inter-dependency of your services, but keeping track of who modified what and how to notify every component about a change can become tricky. Leveraging a single store approach, there is only one source of truth for your data and all modifications happen in a predictable way, potentially leading to a more side-effect-free overall application. Why is RxJS used for this plugin? As mentioned in the intro this plugin uses RxJS as a foundation. The main idea is having a BehaviorSubject store._state which will store the current state. It starts with some initial state and emits new states as they come. The BehaviorSubject cannot be accessed directly - it is defined as private - but instead a public Observable named state should be consumed. This way consumers only have reading access to streamed values but cannot directly manipulate the streaming queue through the Subjects next method. But besides these core features, RxJS itself can be described as Lodash/Underscore for events. As such all of the operators and objects can be used to manipulate the state in whatever way necessary. As an example pluck can be used to pierce into a sub-section of the state, whereas methods like skip and take are great ways to unit test the stream of states over time. The main reason for using RxJS though is that observables are delivered over time. This promotes a reactive approach to how you'd design your application. Instead of pursuing an imperative approach like a click on button A should trigger a re-rendering on component B, we follow an Observer Pattern where component B observes a global state and acts on changes, which are triggered through actions by button A. Broken down to the concepts of Aurelia, as depicted in the following chart, this means that a ViewModel subscribes to the single store and sets up a state subscription. The view directly binds to properties of the state. Actions can be dispatched and trigger the next state emit. Now the initial subscription receives the next state and changes the bound variable, Aurelia automatically figures out what changed and triggers a re-render. The next dispatch will then trigger the next cycle and so on. This way the system behaves in a cyclic, reactive way and sees state changes as requests for a re-rendering. Chart workflow A fundamental benefit of that approach is that you as a developer do not need to think of signaling individual components about changes, but rather they will all listen and react to changes by themselves if the respective part of the state gets modified. Think of it as an event dispatch, where multiple recipients can listen for and perform changes but with the benefit of a formalized global state. As such, all you need to focus on is the state and the rest will be handled automatically. Another benefit is the async nature of the subscription. No matter whether the action is a synchronous operation, like changing the title of your page, an Ajax request to fetch the latest products or a long-running web-socket for your next chat application: whenever you dispatch the next action, listeners will react to these changes."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Getting Started","sectionId":"getting-started","id":1754,"text":"Install the npm dependency via or using Yarn Info If you're not using RxJS at all so far it is recommended to run npm install rxjs which should install the latest available rxjs (currently 6.x.x) version as a project dependency. If your app is based on the Aurelia CLI and the build is based on RequireJS or SystemJS, you can setup the plugin using the following automatic dependency import: alternatively, you can manually add these dependencies to your vendor bundle: Info With the recent release of RxJS v.6, which this plugin depends on, quite a lot has changed. There are new ways to import dependencies and ways to keep compatibility with previous API versions. Take a look at the following upgrade instructions for further details. In case you're using a classic Require.js based Aurelia CLI project setup, make sure to configure rxjs-compat in aurelia.json as a dependency and use it as the main include file. If you do on the other hand already use the newest APIs you'll have to adjust your aurelia.json or do a fresh new au import aurelia-store to get the rxjs dependencies properly auto-setup."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Bring your own polyfills (BYOP)","sectionId":"bring-your-own-polyfills-byop","id":1755,"text":"This plugin depends on the Object.entries feature which is not available in Internet Explorer out of the box. Since it's not actually needed for the core of Aurelia, it won't be part of aurelia-polyfills and you should add the following polyfill by yourself. In case of the Aurelia CLI with RequireJS/SystemJS you can either create a new object.entries.polyfill.js file in the root of your project and add it into the configuration file aurelia.json in the prepend section. Alternatively you can include the file via a script tag as one of the first scripts in your index.html."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"What is the State?","sectionId":"what-is-the-state","id":1756,"text":"A typical application consists of multiple components, which render various data. Besides actual data though, your components also contain various statuses. An \"active\" status for a toggle button for example, but also high-level statuses like the selected theme or the current page. State that is contained within the component is a good thing, as long as only that single component instance cares about it. But the moment you reference that state from another component, you're going to need a way to communicate about that state, like service classes. Pub-sub mechanisms like the EventAggregator are another example of inter-component communication. In contrast to that, the Store plugin operates on a single overall application state. Think of it as a large object containing all the sub-states reflecting your applications condition at a specific moment in time. This state object needs to only contain serializable properties. With that you gain the benefit of having snapshots of your app, which allow all kinds of cool features like time-traveling, save/reload and so on. How much you put into your state is up to you, but a good rule of thumb is that as soon as two different areas of your application consume the same data or affect the same component state you should store them. Your app will typically start with an initial state, which is then manipulated throughout the app's lifecycle. As mentioned this state can be pretty much anything, like shown in the example below. Whether you prefer TypeScript or pure JavaScript is up to you, but having a typed state allows for easier refactoring and better autocompletion support."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Configuring your app","sectionId":"configuring-your-app","id":1757,"text":"In order to tell Aurelia how to use the plugin, we need to register it. This is done in your app's main file, specifically the configure method. We'll have to register the Store using our previously defined State entity: With this done we're ready to consume our app state and dive into the world of state management."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Subscribing to the stream of states","sectionId":"subscribing-to-the-stream-of-states","id":1758,"text":"As explained in the beginning, the Aurelia Store plugin provides a public observable called state which will stream the app's states over time. So in order to consume it, we first need to inject the store via dependency injection into the constructor. Next, inside the bind lifecycle method we are subscribing to the store's state property. Inside the subscription's handler we'll have the actually streamed state and may assign it to the component's local state property. And let's not forget to dispose of the subscription once the component becomes unbound. This happens by calling the subscription's unsubscribe method. Info Note that in the TypeScript version we didn't have to type-cast the state variable provided to the subscription handler since the initial store was injected using the State entity as a generic provider. With that in place the state can be consumed as usual directly from within your template: Since you've subscribed to the state, every new version of the state that arrives will again be assigned to the component's state property and the UI automatically re-rendered, based on the details that changed."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Subscribing with the connectTo decorator","sectionId":"subscribing-with-the-connectto-decorator","id":1759,"text":"In the previous section, you've seen how to manually bind to the state observable for full control. But instead of handling subscriptions and disposal of those by yourself, you may prefer to use the connectTo decorator. What it does is to connect your store's state automatically to a class property called state. It does so by overriding the bind and unbind life-cycle methods for a proper setup and teardown of the state subscription, which will be stored in a property called _stateSubscription. The above ViewModel example could look like this using the connectTo decorator: Info Notice how we've declared the public state property of type State in the TS version. The sole reason for that is to have proper type hinting during compile time. In case you want to provide a custom selector instead of subscribing to the whole state, you may provide a function, which will receive the store and should return an observable to be used instead of the default store.state. The decorator accepts a generic interface which matches your State, for a better TypeScript workflow. If you need more control and for instance want to override the default target property state, you can pass a settings object instead of a function, where the sub-state selector matches above function and target specifies the new target holding the received state. If you want to have multiple selectors, you can pass an object to the selector, where each property in that selector object defines a new target receiving the slice of the state. The value of each property should be a function as shown above matching above. You can still provide a target with multiple selectors, which changes the behavior of multiple selectors. Instead of having multiple target properties on your view model for each selector name, the target will be an object on your view model and the multiple selector names will be the properties on that object. Not only the target but also the default setup and teardown methods can be specified, either one or both. The hooks bind and unbind act as the default value. Info The provided action names for setup and teardown don't necessarily have to be one of the official lifecycle methods but should be used as these get called automatically by Aurelia at the proper time. Last but not least you can also handle changes from the state in multiple ways The decorator will attempt to call stateChanged(newState, oldState) when no settings are passed, a function is used or an object settings is used with selector. Providing a target name without multiple selectors calls thetargetChanged method instead. With multiple selectors, you get the same change handling per selector. However, providing a target with multiple selectors changes the prior behavior by calling the targetChanged method with 3 arguments instead of each individual selector with 2 arguments. You get access to individual state being changed from the first argument. Last but not least you can also define a callback to be called with the next state once a state change happens. For any one of these configuration, you can add an additional change handling function called propertyChanged that will be called last. This has 3 arguments, the state name being changed, the new state and the old state. Info Your change handler function will be called before the target property is changed. This way you have access to both the current and previous state. If you provide an onChanged handler, then you could have up to 3 change handling methods in your view model (called in order): the onChanged method, the targetChanged method and the propertyChanged method. Next, let's find out how to produce state changes."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"What are actions?","sectionId":"what-are-actions","id":1760,"text":"Actions are the primary way to create a new state. They are essentially functions which take the current state and optionally one or more arguments. Their job is to create the next state and return it. By doing so they should not mutate the passed-in current state but instead use immutable functions to create a proper clone. The reason for that is that each state represents a unique snapshot of your app in time. By modifying it, you'd alter the state and wouldn't be able to properly compare the old and new state. It would also mean that advanced features such as time-traveling through states wouldn't work properly anymore. So keep in mind ... don't mutate your state. Info In case you're not a fan of functional approaches take a look at libraries like Immer.js, and the Aurelia store example using it: this lets you act like you're mutating the state object but secretly you're getting a proper clone. Continuing with above framework example, let's say we want to make an action to add an additional framework to the list. You can create a \"shallow\" clone of the state by using Object.assign. By saying shallow we mean that the actual frameworks array in the new state object will just be a reference to the original one. So in order to fix that we can use the array spread syntax with the name of the new framework to create a fresh array. Next, we need to register the created action with the store. That is done by calling the store's registerAction method. By doing so we can provide a name which will be used for all kinds of error-handlers, logs, and even Redux DevTools. As a second argument, we pass the action itself. You can unregister actions whenever needed by using the store's unregisterAction method"},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Async actions","sectionId":"async-actions","id":1761,"text":"Previously we mentioned that an action should return a state. What we didn't mention is that actions can also return a promise which will eventually resolve with the new state. From the above example, imagine we'd have to validate the given name, which happens in an async manner. Info You dont't have to use async/await but it's highly recommended to use it for better readability whenever you can."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Dispatching actions","sectionId":"dispatching-actions","id":1762,"text":"So far we've just created an action and registered it by several means. Now let's look at how we can actually execute one of them to trigger the next state change. We can use the store method dispatch to do exactly that. In the example below, the function dispatchDemo can be called with an argument nextFramework. Inside we call store.dispatch, passing it the action itself and all subsequent parameters required. Alternatively we can also provide the previously registered name instead. Now keep in mind that an action might be async (really any middleware might be - you'll learn more about middleware later), and as such if you depend on the state being updated right after dispatching an action, make sure to await the call to dispatch. The choice whether you dispatch using the actual action function or its previously registered name is up to you. It might be less work just forwarding a string. That way you don't need to import the action from wherever you want to dispatch it. On the other hand using the actual function is a helpful mechanism to make sure your app survives a refactoring session. Imagine you'd rename the action's name but forgot to update all the places that dispatch it. A long night of debugging might be just around the corner ;) Info Dispatching non-registered actions will result in an error."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Using the dispatchify higher order function","sectionId":"using-the-dispatchify-higher-order-function","id":1763,"text":"Perhaps you don't want to or can't obtain a reference to the store, but you'd still like to dispatch your actions. This is especially useful if you don't want your child-elements to have any knowledge of the actual logic and just receive actions via attributes. Children can then call this method directly in the template. In order to do so, you can leverage the higher order function dispatchify. What it does is return a wrapped new function which will obtain the store by itself and forward the provided arguments directly to store.dispatch. With this approach, you can design your custom elements to act either as presentational or container components. For further information take a look at this article."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Recording a navigable history of the stream of states","sectionId":"recording-a-navigable-history-of-the-stream-of-states","id":1764,"text":"Since the whole concept of this plugin is to stream states over time, it makes sense to also keep track of the historical changes. Aurelia Store supports this feature by turning on the history support during the plugin registration. Now when you subscribe to new state changes, instead of a simple State you'll get a StateHistory<state> object returned, which looks like the following:"},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Making our app history-aware","sectionId":"making-our-app-history-aware","id":1765,"text":"Now keep in mind that every action will receive a StateHistory<t> as input and should return a new StateHistory<t>. You can use the nextStateHistory helper function to easily push your new state and create a proper StateHistory representation, which will simply move the currently present state to the past, place your provided one as the present and remove the future states. Navigating through history Having a history of states is great to do state time-travelling. That means defining either a past or future state as the new present. You can do it manually as described in the full-fledged example above and switching states between the properties past, present and future, or you can import the pre-registered action jump and pass it either a positive number for traveling into the future or a negative for travelling to past states. The jump action will take care of any potential overflows and return the current history object."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Limiting the number of history items","sectionId":"limiting-the-number-of-history-items","id":1766,"text":"Having too many items could result in a memory hit. Thus you can specify the limit for when the histories past and future start to overflow. That means your past and future arrays can hold only a maximum of the provided limit and new entries start to drop out, respectively the first or last item of the history stack."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Handling side-effects with middleware","sectionId":"handling-side-effects-with-middleware","id":1767,"text":"Aurelia Store uses a concept of middleware to handle side-effects. Conceptually they are similar to Express.js middlewares in that they allow to perform side-effects or manipulate request data. As such they are registered functions, which execute before or after each dispatched action. A middleware is similar to an action, with the difference that it may return void as well. Middlewares can be executed before the dispatched action, thus potentially manipulating the current state which will be passed to the action, or afterward, modifying the returned value from the action. If they don't return anything the previous value will be passed as output. Either way, the middleware can be sync as well as async. Warning As soon as you have one async middleware registered, essentially all action dispatches will be async as well. Chart workflow Middlewares are registered using store.registerMiddleware with the middleware's function and the placement before or after. Unregistration can be done using store.unregisterMiddleware Info You can call the store.registerMiddleware function whenever you want. This means middlewares don't have to be defined upfront at the apps configuration time but whenever needed. The same applies to store.unregisterMiddleware."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Accessing the original (unmodified) state in a middleware","sectionId":"accessing-the-original-unmodified-state-in-a-middleware","id":1768,"text":"When executed, a middleware might accept a second argument which reflects the current unmodified state, the one before any other middlewares or, in case of an after positioning, the result of the dispatched action. This can be useful to determine the state diff that happened in the middleware chain or to reset the next state at certain conditions."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Defining settings for middlewares","sectionId":"defining-settings-for-middlewares","id":1769,"text":"Some middlewares require additional configurations in order to work as expected. Above we've looked at a customLogMiddleware middleware, which logs the newly created state to the console. Now if we wanted to control the log type to, let's say, output to console.debug we can make use of middleware settings. These are passed in as the third argument to the middleware function and are registered with registerMiddlware."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Reference to the calling action for middlewares","sectionId":"reference-to-the-calling-action-for-middlewares","id":1770,"text":"Last but not least the optional forth argument passed into a middleware is the calling action, meaning the action that is being dispatched. In here you get an object containing the action's name and the provided params. This is useful when you, for instance, want only certain actions to pass or be canceled under certain circumstances."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Error propagation with middlewares","sectionId":"error-propagation-with-middlewares","id":1771,"text":"By default errors thrown by middlewares will be swallowed in order to guarantee continued states. If you would like to stop state propagation you need to set the propagateError option of the plugin to true:"},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Default middlewares","sectionId":"default-middlewares","id":1772,"text":"Aurelia Store comes with a few home-baked middlewares. Others should be added as custom dependencies instead of polluting the overall package size. The Logging Middleware From the previous explanations of the inner workings of middlewares, you've come to learn about the loggingMiddleware. Instead of rebuilding it you can simply import it from Aurelia Store and register it. Remember that you can pass in a settings object to define the logType, which is also defined as a string enum in TypeScript. The Local Storage middleware The localStorageMiddleware stores your most recent emitted state in the window.localStorage. This is useful when creating apps which should survive a full page refresh. Generally, it makes the most sense to place the middleware at the end of the queue to get the latest available value stored in localStorage. In order to make use of it all, all you need to do is to register the middleware as usual. By default, the storage key will be aurelia-store-state. You can additionally provide a storage-key via the settings to be used instead. Now in order to rehydrate the stored state, all you need to do is to dispatch the provided rehydrateFromLocalStorage action which you can import and register as usual. If you used a different key then the default one, just pass it as the second argument to the dispatch call. Info Keep in mind that the store starts with an initialState. If the localStorage middleware is registered at the app's start, most likely the next refresh will immediately overwrite your localStorage and negate the effect of restoring data from previous runs. In order to avoid that, make sure to register the middleware just after the initial state has loaded."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Execution order","sectionId":"execution-order","id":1773,"text":"If multiple actions are dispatched, they will get queued and executed one after another in order to make sure that each dispatch starts with an up-to-date state. If either your actions or middlewares return a sync or async value of false it will cause the Aurelia Store plugin to interrupt the execution and not emit the next state. Use this behavior in order to avoid unnecessary state updates."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Tracking overall performance","sectionId":"tracking-overall-performance","id":1774,"text":"In order to get insights into total run durations to effectively calculate how long it takes to dispatch the next state, you can pass in the measurePerformance option in the plugin configuration section. You can choose between startEnd - which gets you a single measure with the duration of the whole dispatch queue - or all, which will log, besides the total duration, all single marks after every middleware and the actual dispatching. Measures will only be logged for successful state updates, so if an action or middleware aborts due to returning false or throwing an error, nothing gets logged."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Debugging with the Redux DevTools extension","sectionId":"debugging-with-the-redux-devtools-extension","id":1775,"text":"If you've ever worked with Redux then you know for sure about the Redux Devtools browser extension. It's a fantastic way to record and replay the states of your application's walkthrough. For each step, you get detailed information about your state at that time. This can help tremendously to debug states and replicate issues more easily. There are tons of great articles to get you started. Head over to DevTools browser extension page for instructions on how to install the extension, start your Aurelia Store plugin project and see how it works."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Defining custom devToolsOptions","sectionId":"defining-custom-devtoolsoptions","id":1776,"text":"if you use the Redux DevTools extension you can pass options to Aurelia-Store to setup the extension with your preferred configuration. In the following example, we set the serialize option to false. This way our state will not get serialized when sending it to the extension."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Defining custom LogLevels","sectionId":"defining-custom-loglevels","id":1777,"text":"For various features, Aurelia Store can log information if logging is turned on. E.g. the dispatch info of the currently dispatched action will log on info level by default. Combining the logging of many of these features might be very distracting in your console window. As such you can define the log level to be used per feature in the plugin's setup options. In the following example, we'd like to have the logLevel for the dispatchAction info set to debug instead of the default info level. Besides the control for dispatchedActions you can also set the logType for the performanceLog and devToolsStatus notifications."},{"articleName":"Store","articleHref":"docs/plugins/store","sectionName":"Comparison to other state management libraries","sectionId":"comparison-to-other-state-management-libraries","id":1778,"text":"There are a lot of other state management libraries out there, so you might ask yourself why you should favor Aurelia Store instead. As always Aurelia doesn't want to force you into a certain direction. There are good reasons to stick with something you're already familiar or using in another project. Let's look at the differences with a few of the well-known alternatives. Differences to Redux Doubtlessly Redux is one of the most favored state management libraries out there in the ecosystem. With its solid principles of being a predictable state container and thus working towards consistently behaving apps, it's a common choice amongst React developers. A lot of that is motivated by the focus on immutable states and the predictability that this brings in itself. Yet Redux is not solely bound to React and can be used with everything else, including Aurelia. There are even plugins to help you get started. Aurelia Store shares a lot of fundamental design choices from Redux, yet drastically differentiates itself in two points. For one it's the reduction of boilerplate code. There is no necessity to split Actions and Reducers, along with separate action constants. Plain functions are all that is needed. Secondly, handling async state calculations is simplified by treating the apps state as a stream of states. RxJS as such is a major differentiator, which is also slowly finding its place in the Redux eco-system. Differences to MobX MobX came up as a more lightweight alternative to Redux. With its focus on observing properties for changes and that way manipulating the app's state, it addresses the issue of reducing boilerplate and not forcing the user into a strict functional programming style. MobX, similar to Redux, is not tied specifically to a framework - although they offer React bindings out of the box - yet it is not really a great fit for Aurelia. The primary reason for this is that observing property changes is actually one of the main selling points of Aurelia. Same applies to computed values resembling Aurelia's computedFrom and reactions, being pretty much the same as propertyChanged handlers. Essentially all that MobX brings to the table might be implemented with vanilla Aurelia plus a global state service. Differences to VueX The last well-known alternative is VueX, a state management library designed specifically for use with the Vue framework. On the surface, VueX is relatively similar to MobX with some specific twists to how it handles internal changes, being mutations, although developers seem to disagree about that. Mutations very much translate function-wise to Redux reducers, with the difference that they make use of Vue's change tracking and thus nicely fit into the framework itself. Modules, on the other hand, are another way to group your actions. Aurelia Store is pretty similar to VueX in that regard. It makes use of Aurelia's dependency injection, logging and platform abstractions, but aside from that is still a plain simple TypeScript class and could be re-used for any other purpose. One of the biggest differentiators is that Aurelia Store does not force any specific style. Whether you prefer a class-based approach, using the connectTo decorator, or heavy function based composition, the underlying architecture of a private BehaviorSubject and a public Observable is flexible enough to adapt to your needs. "},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Introduction","sectionId":"introduction","id":1779,"text":"This article covers the basics of validation with Aurelia's validation plugin. You'll learn how to add validation to your applications using a fluent rule API and minimal changes to your templates. To get started you'll need to install aurelia-validation using jspm install aurelia-validation or npm install aurelia-validation --save. Afterwards, add .plugin('aurelia-validation') to the configuration in your main.js to ensure the plugin is loaded at application startup. If you're using the aurelia-cli, add the following configuration to your aurelia.json after you've installed the package with npm. If you're not sure where to put this, search your aurelia.json for aurelia-templating-resources and put it underneath."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Defining Rules","sectionId":"defining-rules","id":1780,"text":"Aurelia Validation's standard rule engine uses a fluent syntax to define a set of rules. There are five parts to the syntax: Selecting a property using .ensure Associating rules with the property using .required, .matches, etc Customizing property rules using .withMessage, .when, etc Sequencing rules using .then Applying the ruleset to a class or instance using .on ensure To begin defining a ruleset, use the ValidationRules class. Start by targeting a property using ValidationRules.ensure(...). The ensure method accepts one argument representing the property name. The argument can be a string or a simple property access expression. If you're using TypeScript you'll probably want to use a property access expression because you'll get the benefit of intellisense, refactoring and avoid using \"magic strings\" that can be a maintenance issue. displayName Once you've targetted a property using ensure you can define the property's display name using .displayName(name: string|ValidationDisplayNameAccessor). Display names are used in validation messages. Specifying a display name is optional. If you do not explicitly set the display name the validation engine will attempt to compute the display name for you by splitting the property name on upper-case letters. A firstName property's display name would be First Name. Applying Rules After targeting a property with ensure and optionally setting its display name you can begin associating rules with the property using the built-in rule methods: required() validates the property is not null, undefined or whitespace. matches(regex) validates the property matches the specified regular expression. email() validates an email address. minLength(length) and maxLength(length) validate the length of string properties. minItems(count) and maxItems(count) validate the number of items in an array. equals(expectedValue) validates the property equals the expected value. satisfies((value: any, object?: any) => boolean|Promise<boolean>) validates the supplied function returns true or a Promise that resolves to true. The function will be invoked with two arguments: the property's current value. the object the property belongs to. withMessage All rules have a standard message that can be overriden on a case-by-case basis using .withMessage(message). The message argument is a string that will be interpreted as an interpolation binding expression and evaluated against the validated object when a validation error occurs. The interpolation binding expression can access any of the object's properties as well as the contextual properties listed below: $displayName: the display name of the property. $propertyName: the name of the property. $value: the property value (at the moment the validation rule was executed). $object: the object that owns the property. $config: an object containing the rule's configuration. For example, the config for a minLength rule will have a length property. $getDisplayName:  returns a displayable name of a property given the property name (irrespective of the property's displayName), split on capital letters, first letter ensured to be capitalized. Here's an example: withMessageKey Another way to override messages on a case-by-case basis is to use the .withMessageKey(key) fluent API. Key is a string representing a key in the validationMessages dictionary. You can add new keys to the dictionary using the following code: Conditional Validation You may run into situations where you only want a rule to be evaluated when certain conditions are met. Use the .when(condition: (object) => boolean) fluent API to define a condition that must be met before the rule is evaluated. when accepts one argument, a function that takes the object and returns a boolean that indicates whether the rule should (true) or should not (false) be evaluated. Sequencing Rule Evaluation Rules are evaluated in parallel. Use the .then() method to postpone evaluation of a rule until after the preceding rules in the ensure have been evaluated. In the example above, the emailNotAlreadyRegistered custom rule will only be evaluated when the email property passes the required() and email() validations. Likewise, usernameNotInUse will be evaluated only when the required(), minLength(3) and maxLength(50) checks pass validation. Tagging Rules Use the .tag(tag: string) method to tag a specific property rule with a name. You can retrieve rules with a specific tag using let someRules = ValidationRules.taggedRules(rules, tag). To get only rules that have no tag applied to them you can use let someRules = ValidationRules.untaggedRules(rules). This can come in handy when you want to execute a specific rule or subset of rules. The documentation for the ValidationController (below) shows how to validate specific objects/properties/rules. You can also use the subset of rules with the Validator API (also documented below). on Once your ruleset has been defined you can apply them to a class using the .on method. This will ensure the validation engine can locate the rules when evaluating a particular object. .on can apply the rules to a plain JavaScript object as well: There is no requirement to apply the rules directly to an object or class, you can capture the ruleset in a variable or property using .rule instead:"},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Customizing Messages","sectionId":"customizing-messages","id":1781,"text":"The previous section showed how to customize the message of an individual property rule. You can override messages system-wide by replacing a rule's default message in the validationMessages dictionary: You can override the ValidationMessageProvider's getMessage(key: string): Expression method to enable more dynamic message logic: You can also override the ValidationMessageProvider's getDisplayName(propertyName: string, displayName: string): string method:"},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Validation Controller","sectionId":"validation-controller","id":1782,"text":"The ValidationController orchestrates the UI process of validating properties in response to various triggers and surfacing validation errors via renderers. Typically you'll have one validation controller instance per \"form\" view model. Depending on the use-case you may have multiple. Creating a Controller Validation controllers can be created using the NewInstance resolver: Or with the ValidationControllerFactory: Both techniques create a new instance of a ValidationController and register the instance in the component's container enabling other components in the validation library to access the approriate controller instance without needing a lot of boilerplate code or markup. If you'd like to be completely explicit when wiring up controllers with view models and bindings, or if you need to use multiple controllers in your component, you can use the Factory resolver or the ValidationControllerFactory's create method to create controller instances. Using these approaches will not automatically register the controller instance in the container which will prevent the automatic wire-up of controllers with bindings and renderers and will force you to specify the controller instance in your bindings and add renderers to the controller manually. Setting the Validate Trigger Once you've created a controller you can set its validationTrigger to either blur, change, changeOrBlur or manual. The default is blur which means the validation controller will validate the property accessed in a binding when the binding's associated element \"blurs\" (loses focus). When the trigger is change, each change the binding makes to the model property will trigger validation of the property. Use the throttle, debounce and updateTrigger binding behaviors in conjunction with the change validate trigger to customize the behavior. Use the manual trigger to indicate the controller should not automatically validate properties used in bindings. Errors will only be displayed when you invoke the controller's validate method and will be cleared when you invoke the controller's reset method. validate  You can force the validation controller to run validation by invoking the validate() method. Validate will run the validation, render the results and return a Promise that resolves with a ControllerValidateResult instance. The promise will only reject when there is an unexpected application error. Be sure to catch these rejections like you would any other unexpected application error. Invoking the validate method with no arguments will validate all bindings and objects registered with the controller. You can supply a validate instruction to limit the validation to a specific object, property and ruleset: Most of the time you will use the ControllerValidateResult instance's valid property to determine whether validation passed or failed. Use the results property to access the ValidateResult for every rule that was evaluated by the controller.validate(...) call. Each ValidateResult has it's own rule and valid properties that will tell you whether a particular rule passed or failed, along with message, object and propertyName properties. The opposite of the validate method is reset. Calling reset with no arguments will unrender any previously rendered validation results. You can supply a reset instruction to limit the reset to a specific object or property: addError  You may need to surface validation errors from other sources. Perhaps while attempting to save a change the server returned a business rule error. You can display the server error using the controller's addError(message: string, object: any, propertyName?: string): ValidateResult method. The method returns a ValidateResult instance which can be used to unrender the error using removeError(result: ValidateResult). addRenderer  The validation controller renders errors by sending them to implementations of the ValidationRenderer interface. The library ships with a built-in renderer that \"renders\" the errors to an array property for data-binding/templating purposes. This is covered in the displaying errors section below. You can create your own custom renderer and add it to the controller's set of renderers using the addRenderer(renderer) method. Events The validation controller has a subscribe(callback: (event: ValidateEvent) => void) method you can use to subscribe to validate and reset events. Callbacks will be invoked whenever the controller's validate and reset methods are called. Callbacks will be passed an instance ValidateEvent which contains properties you can use to determine the overall validity state as well as the result of the validate or reset invocation. Refer to the API docs for more info."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Validator","sectionId":"validator","id":1783,"text":"Validator is an interface used by the ValidationController to do the behind-the-scenes work of validating objects and properties. The aurelia-validation plugin ships with an implementation of this interface called the StandardValidator, which knows how to evaluate rules created by aurelia-validation's fluent API. When you use a Validator directly to validate a particular object or property, there are no UI side-effects- the validation results are not sent to the the validation renderers. Creating a Validator Validators can be injected: Use the Validator instance's validateObject and validateProperty methods to run validation without any render side-effects. These methods return a Promise that resolves with an array of ValidateResults."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Validate Binding Behavior","sectionId":"validate-binding-behavior","id":1784,"text":"The validate binding behavior enables quick and easy validation for two-way data-bindings. The behavior registers the binding instance with a controller, enabling the system to validate the binding's associated property when the validate trigger occurs (blur / change). The binding behavior is able to identify the object and property name to validate in all sorts of binding expressions: validate accepts a couple of optional arguments enabling you to explicitly specify the rules and controller instance: The validate binding behavior obeys the associated controller's validateTrigger (blur, change, changeOrBlur, manual). If you'd like to use a different validateTrigger in a particular binding use one of the following binding behaviors in place of & validate: & validateOnBlur: the DOM blur event triggers validation. & validateOnChange: data entry that changes the model triggers validation. & validateOnChangeOrBlur: DOM blur or data entry triggers validation. & validateManually: the binding is not validated automatically when the associated element is blurred or changed by the user."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Displaying Errors","sectionId":"displaying-errors","id":1785,"text":"The controller exposes properties that are useful for creating error UIs using standard Aurelia templating techniques: results: An array of the current ValidateResult instances. These are the results of validating individual rules. errors: An array of the current ValidateResult instances whose valid property is false. validating: a boolean that indicates whether the controller is currently executing validation. Assuming your view-model had a controller property you could add a simple error summary to your form using a repeat: To build more sophisticated error UIs you might need a list of errors specific to a particular binding or set of bindings. The validation-errors custom attribute creates an array containing all validation errors relevant to the element the validation-errors attribute appears on and its descendent elements. Here's an example using bootstrap style form markup: This first form-group div uses the validation-errors custom attribute to create a firstNameErrors property. When there are items in the array the bootstrap has-error class is applied to the form-group div. Each error message is displayed below the input using help-block spans. The same approach is used to display the lastName field's errors. The validation-errors custom attribute implements the ValidationRenderer interface. Instead of doing direct DOM manipulation to display the errors it \"renders\" the errors to an array property to enable the data-binding and templating scenarios illustrated above. It also automatically adds itself to the controller using addRenderer when its \"bind\" lifecycle event occurs and removes itself from the controller using the removeRenderer method when its \"unbind\" composition lifecycle event occurs."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Custom Renderers","sectionId":"custom-renderers","id":1786,"text":"The templating approaches described in the previous section may require more markup than you wish to include in your templates. If you would prefer use direct DOM manipulation to render validation errors you can implement a custom renderer. Custom renderers implement a one-method interface: render(instruction: RenderInstruction). The RenderInstruction is an object with two properties: the results to render and the results to unrender. Below is an example implementation for bootstrap forms: To use a custom renderer you'll need to instantiate it and pass it to your controller via the addRenderer method. Any of the controller's existing errors will be renderered immediately. You can remove a renderer using the removeRenderer method. Removing a renderer will unrender any errors that renderer had previously rendered. If you choose to call addRenderer in your view-model's activate or bind methods, make sure to call removeRenderer in the corresponding deactivate or unbind methods. Warning The renderer example uses Element.closest. You'll need to polyfill this method in Internet Explorer. Here's another renderer for bootstrap forms that demonstrates \"success styling\". When a property transitions from indeterminate validity to valid or from invalid to valid, the form control will highlight in green. When a property transitions from indeterminate validity to invalid or from valid to invalid, the form control will highlight in red, just like in the previous bootstrap form renderer example."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Entity Validation","sectionId":"entity-validation","id":1787,"text":"The examples so far show the controller validating specific properties used in & validate bindings. The controller can validate whole entities even if some of the properties aren't used in data bindings. Opt in to this \"entity\" style validation using the controller's addObject(object, rules?) method. Calling addObject will add the specified object to the set of objects the controller should validate when its validate method is called. The rules parameter is optional. Use it when the rules for the object haven't been specified using the fluent syntax's .on method. You can remove objects from the controller's list of objects to validate using removeObject(object). Calling removeObject will unrender any errors associated with the object. You may have rules that are not associated with a single property. The fluent rule syntax has an ensureObject() method you can use to define rules for the whole object."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Custom Rules","sectionId":"custom-rules","id":1788,"text":"The fluent API's satisfies method enables quick custom rules. If you have a custom rule that you need to use multiple times you can define it using the customRule method. Once defined, you can apply the rule using satisfiesRule.  Here's how you could define and use a simple date validation rule: You will often need to pass arguments to your custom rule. Below is an example of an \"integer range\" rule that accepts \"min\" and \"max\" arguments. Notice the last parameter to the customRule method packages up the expected parameters into a \"config\" object. The config object is used when computing the validation message when an error occurs, enabling the message expression to access the rule's configuration. You may have noticed the custom rule examples above consider null and undefined to be valid. This is intentional- a rule should follow the single responsibility principle and validate only one constraint. It's the .required() rule's job to validate whether the data is filled in, you shouldn't add required checking logic to your custom rule for two reasons: Rule reuse- if our \"integerRange\" rule also does \"required\" checks, we can't use it on optional fields. Messages Relevance- if our \"integerRange\" rule also does \"required\" checks the user will get \"range\" error messages when we they should have gotten \"required\" error messages. When you write a custom rule, the function should return true when the rule is \"satisfied\" / \"valid\" and false when the rule is \"broken\" / \"invalid\". Optionally you can return a Promise that resolves to true or false. The promise should not reject unless there's an unexpected exception. Promise rejection is not used for control flow or to represent \"invalid\" status. A common application of a custom rule is to confirm that two password entries match.  Here is a example showing how you can do that:"},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Multiple Validation Controllers","sectionId":"multiple-validation-controllers","id":1789,"text":"If you have two forms that need to be independently validated, it is of course recommended you implement them in separate components. However, it is technically possible to do two or more independant validations in the same component by creating multiple validation controllers. For instance: imagine you're building an order form for an Italian restaurant. The customer can order pizza or pasta. If the customer makes a mistake in ordering a pizza, they should be able to order a pasta regardless. In that case your view model would look like this: In your view you need to take care to associate each input with the correct validation controller: In the forms above you can see that each validation-errors attribute and each validateManually binding behavior is bound to the appropriate validation controller. This needs to be specified each time, since by default the attribute and the binding behavior will ask the container for a ValidationController instance not knowing which one it will get."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Integration With Other Libraries","sectionId":"integration-with-other-libraries","id":1790,"text":"In aurelia-validation the object and property validation work is handled by the StandardValidator class which is an implementation of the Validator interface. The StandardValidator is responsible for applying the rules created with aurelia-validation's fluent syntax. You may not need any of this machinery if you have your own custom validation engine or if you're using a client-side data management library like Breeze which has its own validation logic. You can replace the StandardValidator with your own implementation when the plugin is installed. Here's an example using breeze:"},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Integrating with Aurelia-I18N","sectionId":"integrating-with-aurelia-i18n","id":1791,"text":"aurelia-i18n is Aurelia's official I18N plugin. Check out the project's readme for information on how to use aurelia-i18n in your application. Integrating aurelia-i18n with aurelia-validation is easy. All standard validation messages are supplied by the ValidationMessageProvider class. To translate the messages, override the getMessage(key) and getDisplayName(propertyName, displayName) methods with implementations that use aurelia-i18n to fetch translated versions of the messages/property-names. Here's how to override the methods, in your main.js, during application startup: Creating the view and view-model Once you've overriden the necessary methods in ValidationMessageProvider you're ready to create a view and view-model. Here's a view for a simple multi-language form with first and last name fields. All static text is translated using the T binding behavior. Validation occurs on form submission and a switch language button demonstrates the i18n capabilities. Here's the view model: Translation Files Last but not least, create translation files that include translations for each propertyName and each validation message key. Below are the German and English files for the example above. Notice the errorMessages section has the translation for the required rule. In practice, you would need translations for each rule that you use. Take a look at the validationMessages export for the full list."},{"articleName":"Validation","articleHref":"docs/plugins/validation","sectionName":"Server-Side Validation","sectionId":"server-side-validation","id":1792,"text":"The fluent rule API and Validator API can be used server-side in a NodeJS application. todo: example "},{"articleName":"Integrating with Polymer","articleHref":"docs/integration/polymer","sectionName":"Setup","sectionId":"setup","id":1793,"text":"The first step is obtaining Polymer, which is generally done with the Bower package manager. The following bower.json will install Polymer's base and material design elements. Make sure Bower is installed and then use Bower to install the packages for each of the Polymer elements. Aurelia must also be configured to use the HTML Imports template loader and the aurelia-polymer plugin, both of which can be installed with JSPM. In index.html, Polymer and the webcomponents.js polyfills need to be loaded before Aurelia is, so that the aurelia-polymer plugin can hook into Polymer's element registration system. It's also a good idea to wait until the web components polyfill has loaded Polymer to bootstrap Aurelia. Instead of directly importing aurelia-bootstrapper, wait until the WebComponentsReady event fires in index.html. In main.js, the two Aurelia plugins installed before need to be loaded as well. At this point, Aurelia and Polymer are ready to go. The examples below incorporate various Polymer elements into the Aurelia skeleton navigation starter."},{"articleName":"Integrating with Polymer","articleHref":"docs/integration/polymer","sectionName":"Importing Elements","sectionId":"importing-elements","id":1794,"text":"With the normal Aurelia template loader, nothing is allowed outside the root <template> element. When using HTML imports, however, the import statements must be before the <template>."},{"articleName":"Integrating with Polymer","articleHref":"docs/integration/polymer","sectionName":"Data Binding","sectionId":"data-binding","id":1795,"text":"Given the imports above, this shows how to implement a basic layout in app.html with Polymer components. Notice that Poylmer elements such as <paper-drawer-panel> or <paper-menu>, once imported, can be used just like normal HTML elements. All of the standard Aurelia binding syntax continues to work as well. For example, repeat.for is used to populate menu items from the Aurelia router. The active.bind binding on the <paper-item> elements in the navigation menu shows that attributes defined by Polymer are also supported by Aurelia."},{"articleName":"Integrating with Polymer","articleHref":"docs/integration/polymer","sectionName":"Forms and Two-Way Binding","sectionId":"forms-and-two-way-binding","id":1796,"text":"The updated welcome.html uses Polymer input elements to enhance its form. While not strictly necessary in this case, making the form an <iron-form> ensures that Polymer input elements are submitted along with native HTML elements. Note that the <paper-input> elements have .two-way bindings, not just .bind. With the exception of native HTML form elements, Aurelia defaults to one-way bindings, so two-way data binding must be specified explicitly. A normal <button> element is used with Aurelia's submit.delegate binding, since Polymer elements cannot submit forms. If form submission semantics were not needed, another option would be to use a click.delegate on a Polymer button instead."},{"articleName":"Integrating with Polymer","articleHref":"docs/integration/polymer","sectionName":"How the Plugin Works","sectionId":"how-the-plugin-works","id":1797,"text":"The aurelia-polymer plugin is fairly simple. For each Polymer element, it registers the element's properties and what events they support with the EventManager in Aurelia's binding component. The core of the plugin, the registerElement function, loops over all properties of the element and any behavior it implements so that the Aurelia binding engine will register event listeners properly. Element properties marked with notify are eligible for Polymer's two-way data binding system and also trigger a {property-name}-changed event. This corresponds to the input and change events in Aurelia. Whenever a Polymer element is imported, it triggers a call to Polymer.telemetry._registrate, which adds the element prototype to a list of registered Polymer elements. The aurelia-polymer plugin replaces this registration function with one that also calls registerElement on the prototype so that it is configured with Aurelia as well. The need to override this function is why Polymer must be loaded before the plugin is. "},{"articleName":"I18N","articleHref":"docs/plugins/i18n","sectionName":"Introduction","sectionId":"introduction","id":1798,"text":"This documentation explains how to get up and running with Aurelia-I18N in order to provide localization and internationalization features with your app. Under the hood it uses i18next, which is a generalized open source library with an extensive set of features. By building on top of it not only can you reuse your work across various other platforms and frameworks but you are able to use an extensive eco-system full of various packages."},{"articleName":"I18N","articleHref":"docs/plugins/i18n","sectionName":"Installing the Plugin","sectionId":"installing-the-plugin","id":1799,"text":"There are various ways to setup your Aurelia app. It not only boils down to the question whether you use JavaScript or TypeScript but also which module loader and bundler is in use. Aurelia-I18N is tested and optimized to support both JS and TS, as well as the following loader/bundler scenarios: Aurelia CLI JSPM Webpack Please continue with the section which suites your setup. In addition to this, you must pick your own backend service. For this guide we're going to leverage the XHR backend plugin, or a variation of this plugin  aurelia-i18n-loader  that uses the aurelia loader, which is bundled with the aurelia-i18n plugin. We'll discuss TypeScript specifics in a later section. Aurelia CLI In order to install the Plugin with a CLI Project, first install the plugin via npm, from within the root folder of your project: Since Aurelia-I18N is backed by i18next, you should install it and a backend plugin of your choice. You can use the built-in backend that uses aurelia's loader or any of your choice. As an example we're going to leverage the i18next-xhr-backend: After that we need to tell our CLI App about the new dependencies. To do so we're going to open the file aurelia_project/aurelia.json and scroll down to the section named dependencies. In there add the following three entries: Info If you're planning to use the built-in aurelia-i18n-loader there is no need for an additional configuration and you're fine with the first two entries. JSPM In your project install the plugin via jspm using the following command: And optionally install the backend service using: Info You can skip this part if you're planning to use the built-in aurelia-i18n-loader Webpack Install the aurelia-i18n plugin in your project using npm and the following command: or if you prefer yarn Also optionally install the i18next-xhr-backend plugin: or using yarn Info You can skip this part if you're planning to use the built-in aurelia-i18n-loader Optionally, but recommended, add aurelia-i18n to your project's Aurelia bundles list in the webpack.config.babel.js (assuming you used the skeleton-navigation webpack build as your base). This will put the plugin in the Aurelia chunk, not the App chunk. An example based directly on skeleton-navigation:"},{"articleName":"I18N","articleHref":"docs/plugins/i18n","sectionName":"Setting up the Plugin","sectionId":"setting-up-the-plugin","id":1800,"text":"Now that you have installed and configured your loader, these are the steps to get started with the plugin. First, use Manual Boostrapping. Open your index.html and locate the element with the attribute aurelia-app. Change it to look like this: Info If you're using one of the Aurelia Skeletons as your base this is already done and you can safely skip this step. See here to learn more about manual bootstrapping.. Second, create a folder named locales in your project's root. Third, for each locale, create a new folder with it's name (e.g. en, de, ...). Fourth, in those subfolders create a file named translation.json which contains your language specific translations. Below you can find a sample en-EN translation file. The full potential of i18next is achieved through a specific translation-file schema. Consult the i18next docs to find out more about it. Fifth, create (if you haven't already) a file main.js in your src folder to configure the plugin. Depending on which backend you've chosen there might be slight differences. The following listings show the configuration for first the built-in aurelia loader, the second using i18next-xhr-backend. Info Notice that Aurelia I18N makes use of a non-standard attributes option, which is used to define custom aliases besides the default ones, being t and i18n. Calling TCustomAttribute.configureAliases is currently necessary in order make sure that the aliases are defined before view templates are fully processed. To have webpack serving your translation files for i18next-xhr-backend, they need to be copied into the virtual (development) or actual (production) output directory. To copy them from src/locales/ to $outputDir$/locales/, add the following entry under the plugins section of your webpack.config.js. You may also group your translations by namespaces, spread across multiple files. Say you have the standard translation.json and an additional nav.json for the navigation items, you can configure aurelia-i18n by passing the ns setting in the config object containing the different namespaces as well as the default namespace. When using namespaces, you will need to prepend string references with ns: for those strings that are not in the defaultNS. For example t='nav:profile' would access the profile string in nav.json. Reflect-Metadata Compatibility If you are using reflect-metadata, there is an outstanding compatibility issue which is resolved by ensuring reflect-metadata is loaded before Aurelia is initialized. If you are using SystemJS, this can be achieved in your index.html as follows:"},{"articleName":"I18N","articleHref":"docs/plugins/i18n","sectionName":"TypeScript Support","sectionId":"typescript-support","id":1801,"text":"In order to get proper support for autocompletion and typesafety you should install the necessary type definitions (d.ts) for the plugins dependencies. Here we show how you can do that for i18next and the i18next-xhr-backend, but this should be applicable to every other backend choice. The way to get hold of those is using using npm or perhaps Yarn as with other packages. In this case the typings are at @types/i18next, along with the instructions. The command is or if you are using Yarn but in case of yarn there might be a complication as described at https://github.com/yarnpkg/yarn/issues/4226 with a solution proposed to fix complications should they arise. Info Alternatively, you can find this file in the plugins repository doc folder: doc/i18next.d.ts As for the XHR-Backend you'll be using: or for yarn Info Alternative, you can find this file in the plugins repository doc folder: doc/i18next-xhr-backend.d.ts Note: if you decide to use the doc/*.d.ts files, you should copy them to another folder, e.g. custom_typings. If you're running a JSPM setup, in order to properly find the aurelia-i18n.d.ts file, you can alternatively install it via npm: The next step is to let the compiler know about your *.d.ts files. Add the following section to your tsconfig.json file. or if you are using TypeScript 2.0 or later, you can add them to the types section like Warning TypeScript will throw errors like Module xxx not found either for aurelia-i18n or one of the backends. This is due to the fact that TypeScript does not see proper ES6 exported defaults. So you can now either switch to alias imports import * as Backend from 'i18next-xhr-backend' or update your tsconfig with \"allowSyntheticDefaultImports\": true to maintain the same import style."},{"articleName":"I18N","articleHref":"docs/plugins/i18n","sectionName":"Using the Plugin","sectionId":"using-the-plugin","id":1802,"text":"i18next translations work by setting up an active locale, which you've setup above in the init phase with the property lng. Setting the active locale In order to change the active language you'd have to call the function setLocale(localeName) via code. Getting the active locale To get the active locale you'd go with getLocale(): Translating via code Translating stuff via code works by using the method tr. You pass in the key as its first parameter, followed by the optional second parameter options to specify in detail how the translations should be performed. Please consult the i18next docs for a detailed list of those: Translating via html attributes Translation in html can be done alternatively using attributes. By default the plugin is configured to use the t and i18n attributes. This can be configured during the plugin registration using the TCustomAttribute.configureAliases function and also the attributes property plugin instance.setup function parameter. Passing the option skipTranslationOnMissingKey during plugin initialization, will keep your original contents in place and instead add a warning in the console about trying to update an element without a matching key. Any element in your views that has one of those attributes, will be translated when the locale is changed. The plugin will use the title as the key when translating that element. Other attributes, specified in the attributes option, may be used as well. Notice in the above example that the key was set to home.title. This will make the plugin look for a translation with nested objects in your translation json, ie: Use i18n.updateTranslations() to update all translations within the children of the element that is passed to it. Specifying attributes By default the plugin will set the textContent property of an element. So in above example the html tags will be escaped and the output will be &lt;b&gt;bold&lt;/b&gt;. To allow html-markup to be used, the [html] attribute needs to be added before the translation key. This will set the innerHTML of the element instead of the textContent property, so html-markup won't be escaped. There are 4 special attributes including the shown [html]: [text]:  Sets the textContent property (default) [html]:  Sets the innerHTML property [append]:  appends the translation to the current content already present in the element (allows html). [prepend]: prepends the translation to the current content already present in the element (allows html). If the element is a custom element and the value relates to a bindable property of that, then the properties value itself will be updated. Any other values will be used as actual attributes on the element itself. The following example will not change the content of the element, but will set its alt attribute to the translated value of title when the locale changes. Specifying multiple attributes Multiple attributes for the same key can be specified by separating them with a comma. When the locale changes it will set the placeholder and the aria-placeholder of the input element to the translated value of placeholder. Multiple attributes for different keys can be specified by separating them with a semicolon. When the locale changes it will set the innerHTML to the translated value of title due to the [html] attribute and the class property to the translated value of title-class. Using nested and combined translations In order to combine two or more translations, just include them with the $t(yourkey) markup Nested keys may also be referenced and will be properly translated: Translating images Images can be translated as well, for when a different image needs to be displayed in another language. The plugin will automatically change the src attribute of the image when the locale changes. You may specify a default value for images as well. In order to do so just define an attribute called data-src with the default value. This will be picked up by the CLI when translations are extracted from the source files. (see the section on CLI Integration) Passing parameters to the attribute In order to use parameters for replaceable parts in your translation key, you can provide an additional t-params attribute and bind it to the object containing the replacement values. Also note that for whatever attribute you registered, the corresponding *-params attribute will get registered as well automatically. Info The object passed to t-params is a complex object explained in the next section. To use it via code, see Complex objects for variables via code. Translating with the TValueConverter In order to do translations in a more declarative way from within your HTML markup you can use a custom ValueConverter named t. It takes exactly the same options as the code translation method tr but of course provides the key automatically. You will find below a few examples of the available i18next features Translating with the TBindingBehavior The TValueConverter is pretty useful if you prefer a declarative way to enhance DOM elements with i18n support. But it has a lack when it comes to automatically updating itself when changes happen outside, like locale switches. This is what the TBindingBehavior can do. Essentially you do the same thing like with the TValueConverter but use the & sign instead of | to indicate usage of the binding behavior. Now aurelia-i18n will automatically emit signals when internal changes happen and you can do so as well by emiting a aurelia-translation-signal. The following example depicts how this is done internally when the current locale changes. First you need to get hold of the BindingSignaler exported by the aurelia-templating-resources module and inject it either in your constructor or via the static $inject property. Next when you want to trigger the signal just use the signalers signal method and pass it the predefined string. Info If you want to only update your relative time binding behaviors, you may use the signal aurelia-relativetime-signal which will only trigger those and safe unnecessary update roundtrips Complex objects for variables via code In some cases it might be useful to define variables via complex objects. Let's take a look at below example. It shows a validation message to hint the user that a given field should be in range of min and max. Now we could easily pass min and max as separate variables but on the other hand that involves more work you'd have to do manually if the source is a object. So in order to avoid that you may simply pass in the object as a whole and the library will pickup all the necessary information and create the proper options object. You can also mix and match it with simple variables. Formatting numbers via code For displaying numbers in different formats, this plugin makes use of the Internationalization API NumberFormat. It leverages the same locales used for the translation methods mentioned in the install process of the plugin. The API provides access to the Intl NumberFormat with the method NumberFormat. This function takes the an options object representing the formatting options as the first and the locale as the second parameter. Below is an example how to access the NumberFormat via code: Formatting numbers with NfValueConverter A more declarative way is to use the nf ValueConverter from within your HTML markup. It essentially works the same way as the code version. Take a look at the following example: Info If you provide the active locale as a bound VM property, the ValueConverter will be re-evaluated as soon as the property value changes, resulting in automatic re-formatting of your number. Formatting dates via code The Intl. API provides means to format DateTimes as well. Use the method df to access that feature with the same arguments used for NumberFormat Below you'll find an example how to use those via code: Info Remember that if you pass in undefined for the options parameter you'll get the default formatting options Formatting dates with DfValueConverter A more declarative way is to use the df ValueConverter from within your HTML markup. It essentially works the same way as the code version. Take a look at the following example, which defines a VM property myDate: Rendering relative time In order to create a representation of relative time like x days ago or in x days you can leverage the Service relativeTime. This exposes a method getRelativeTime which accepts a valid JS date. To use it via code get hold of the service via injection and call the method as needed: This is also tied in to the currentLocale of the library so changing that one will also translate relative time messages. Take a look at the file src/defaultTranslations/relative.time.js for available translations. If you're missing yours, I welcome you to provide a PR so everybody can benefit from it. A more declarative approach is to use the RtValueConverter directly in your HTML markup. It doesn't take any additional parameters, so just drop it in and you're good to go:"},{"articleName":"I18N","articleHref":"docs/plugins/i18n","sectionName":"Bundle Translation Files","sectionId":"bundle-translation-files","id":1803,"text":"When bundling is used, the built-in backend will read the translations from the bundle with the aurelia loader. Make sure that the translation.json files are packed in the bundle using the text module, by changing the aurelia.json and adding .json as an extension for the text plugin: Using JSPM If you're using JSPM as your module loader, the bundle configuration might look like. Using Aurelia CLI Same would apply to the Aurelia CLI. In order to tell it to process the locales you can create a new task process-locales.js, located in the aurelia_project/tasks folder with the contents: With that in place, edit your aurelia_project/aurelia.json file and add the task right after the markupProcessor configuration, where the source property should reflect your previously setup locales folder: Also, edit your aurelia_project/tasks/run.js (or .ts if you're using Typescript) file and add a new gulp.watch task to the watch function: By doing this, if you're running your project with the --watch flag, your bundles will be rebuilt whenever your change something in your translation files. In the same way that happens with your .html, .js and .css files. Last but not least search for the build/bundles/source section for the app-bundle and update the configuration to include json files. and include the json extension in the loader plugin part build/loader/plugins/extensions Using Webpack As an easy starting point for getting aurelia-i18n to work with webpack or if you don't want your translations files split into several chunks, you might refrain from lazy loading them and instead bundle them all with your app.bundle. With all locales included into the app.bundle, it's size and upfront loading time will increase, but for a small amount of translations, that might not be much of an issue. To do this, you can use the i18next-resource-store-loader. First install the module from within the root folder of your project: Given following file structure: Configure aurelia-i18n as follows: For additional information about the resource store loader please take a look at the official repos information."},{"articleName":"I18N","articleHref":"docs/plugins/i18n","sectionName":"Internationalization API Polyfill","sectionId":"internationalization-api-polyfill","id":1804,"text":"The plugin leverages the JavaScript Internationalization API to perform certain tasks. Since not all browsers do fully support it (compatibility table) the aurelia-i18n conditionally loads the Polyfill if needed. In case of bundling your app you should thus keep in mind that it will not be automatically included into the bundle. That means you have to manually adjust the bundle config to include the polyfill as well, if you intend to have your application run on browsers without full support. related GitHub issue Bundling the Intl Polyfill with Aurelia CLI Aurelia-I18N uses a polyfill to provide Intl.API support for browsers currently not implementing the feature. Amongst those are Safari for Mac and iOS. The Polyfill will be lazy loaded in dev mode as needed but won't be included automatically as part of the bundle. The reason is the decent file size of ~50k in minified mode, as such you as the developer have to opt-in and bundle the Polyfill manually. To do so first install the Polyfill as part of your project using npm: After that open up the aurelia_project/aurelia.json file and add the following dependency: Info Instead of referencing the min file you could also reference Intl.complete to include the Unicode CLDR locale data. For more info about that consult the official Polyfill docs. Use Internationalization API Polyfill with Webpack In order to use the Polyfill with Webpack, you will have to adapt your bootstrap function. When using WebPack, one needs to add PLATFORM.modulename to enable aurelia-webpack-plugin to properly recognize the plugins. With that change, the example code looks like so: Or using TypeScript More information in the README of the Intl.js polyfill. On top of that if you need the Intl polyfill included you have to manually require and bundle it. To do so add the following import statement at the begin of your main.js/ts file: For additional information about Intl.js and Webpack please take a look at this official repos information"},{"articleName":"Webpack Setup","articleHref":"docs/build-systems/webpack/setup","sectionName":"Configuring Your Environment","sectionId":"configuring-your-environment","id":1805,"text":"Let's start by getting you set up with a great set of tools that you can use to build modern ${context.language.name} applications. All our tooling is built on Node.js. If you have that installed already, great! If not, you should go to the official web site, download and install it. Everything else we need will be installed via Node's package manager (npm). If you already have npm installed, make sure you've got the latest version to avoid any issues with the other tools. Info For command-line operations, we recommend Windows users to use Git Bash or Git Shell."},{"articleName":"Webpack Setup","articleHref":"docs/build-systems/webpack/setup","sectionName":"Setting up the Project Structure and Build","sectionId":"setting-up-the-project-structure-and-build","id":1806,"text":"We'll begin by downloading a skeleton. We've got several versions available for you based on your language and tooling preferences. Please download the latest skeletons now. Once the download has completed, unzip it and look inside. The readme file contained therein will explain the various options available to you. Please select one of the skeletons and copy it to the location on your file system that you wish your code to reside. Be sure to rename the folder to appropriately represent the app you want to build. You will now find everything you need inside the folder, including a basic build, package configuration, styles and more. With all this in place, let's run some commands. Open a console and change directory into your app's directory. Execute the following command to install the dependencies listed in the dependencies and devDependencies sections of the package manifest: Everything we've done so far is standard Node.js build and package management procedures. It doesn't have anything specific to do with Aurelia itself. We're just walking you through setting up a modern ${context.language.name} project and build configuration from scratch. Info Bootstrap and Font-Awesome are not dependencies of Aurelia. We only leverage them as part of the starter kit in order to help you quickly achieve a decent look out-of-the-box. You can easily replace them with whatever your favorite CSS framework and/or icon library is. Similarly, Bluebird is recommended, but not required. Note however that the Promise implementation in certain Microsoft Edge versions are extremely slow, thus keeping an alternative Promise implementation is recommended."},{"articleName":"Webpack Setup","articleHref":"docs/build-systems/webpack/setup","sectionName":"Running The App","sectionId":"running-the-app","id":1807,"text":"If you've followed along this far, you now have all the libraries, build configuration and tools you need to create amazing ${context.language.name} apps with Aurelia. The next thing to do is run the sample app. To see this in action, on your console, use the following command to build and launch the server: You can now browse to http://localhost:9000/ to see the app. Info The Skeleton App uses Webpack's Development Server for automated page refreshes on code/markup changes, meaning you do not need to restart the command every time you make a change."},{"articleName":"Webpack Setup","articleHref":"docs/build-systems/webpack/setup","sectionName":"Running The Unit Tests","sectionId":"running-the-unit-tests","id":1808,"text":"To run the unit tests, first ensure that you have followed the steps above in order to install all dependencies and successfully build the library. Once you have done that, you may run the tests with the following command:"},{"articleName":"Webpack Setup","articleHref":"docs/build-systems/webpack/setup","sectionName":"Running The E2E Tests","sectionId":"running-the-e2e-tests","id":1809,"text":"Integration tests are performed with Protractor. Place your E2E-Tests into the folder test/e2e/src Run the tests by invoking"},{"articleName":"Webpack Setup","articleHref":"docs/build-systems/webpack/setup","sectionName":"Running E2E Tests Manually","sectionId":"running-e2e-tests-manually","id":1810,"text":"Make sure your app runs and is accessible: Once bundle is ready, run the E2E-Tests in another console:"},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Introduction","sectionId":"introduction","id":1811,"text":"This article covers the dialog plugin for Aurelia.  This plugin is created for showing dialogs (sometimes referred to as modals) in your application.  The plugin supports the use of dynamic content for all aspects and is easily configurable / overridable."},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Installing The Plugin","sectionId":"installing-the-plugin","id":1812,"text":"or or If you use the Aurelia CLI RequireJS/SystemJS build add the following section in your aurelia.json: If you do not use any of the default resources(<ux-dialog>, attach-focus, etc.) just omit the resources entry. If you use just some, list those you are using. INFO Depending on you loader/bundler you may need aditional configuration, as withaurelia-cli, to include the default resources. INFO If you use TypeScript and install only the jspm package, you can install the plugin's typings with the following command:"},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Configuring The Plugin","sectionId":"configuring-the-plugin","id":1813,"text":"Make sure you use manual bootstrapping. In order to do so open your index.html and locate the element with the attribute aurelia-app. Change it to look like this: Create (if you haven't already) a file main.js in your src folder with following content: Warning When the <body> is marked with the aurelia-app attribute any dialog open prior to the app being attached to the DOM(before Aurelia.prototype.setRoot completes), will be removed from the DOM. Opening a dialog in the canActivate or activate hooks is OK in any scenario if you await it to close before continuing. If you just want to open a dialog, without awaiting it to close, do it the attached hook instead. Warning PLATFORM.moduleName should not be omitted if you are using Webpack."},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Using The Plugin","sectionId":"using-the-plugin","id":1814,"text":"There are a few ways you can take advantage of the Aurelia dialog. You can use the dialog service to open a prompt - This will open a prompt and return a promise that resolves when closed.  If the user clicks out, clicks cancel, or clicks the 'x' in the top right it will still resolve the promise but will have a property on the response wasCancelled to allow the developer to handle cancelled dialogs. There is also an output property that gets returned with the outcome of the user action if one was taken. You can create your own view / view-model and use the dialog service to call it from your app's view-model - This will open a dialog and control it the same way as the prompt.  The important thing to keep in mind is you need to follow the same method of utilizing a DialogController in your EditPerson view-model as well as accepting the model in your activate method - and the corresponding view -"},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Default Resources(custom elements/attributes)","sectionId":"default-resourcescustom-elementsattributes","id":1815,"text":"The available resources are: <ux-dialog>, <ux-dialog-header>, <ux-dialog-body>, <ux-dialog-footer> and attach-focus. They are registered by default. If you are not using them provide a configuration callback so they do not get registered by default: Or if you want to use just some of them: attach-focus The library exposes an attach-focus custom attribute that allows focusing in on an element in the modal when it is loaded. You can use this to focus a button, input, etc...  Example usage: You can also bind the value of the attach-focus attribute if you want to alter which element will be focused based on a view model property. INFO Logic is executed during attach - hence the attribute name. Any changes to the value after this point will not be reflected, for such scenarios use the focus custom attribute."},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Settings","sectionId":"settings","id":1816,"text":"Global Settings You can specify global settings as well for all dialogs to use when installing the plugin via the configure method. If providing a custom configuration, you must call the useDefaults() method to apply the base configuration. Dialog Settings The settings available for the dialog are set on the dialog controller on a per-dialog basis. viewModel can be url, class reference or instance. url - path relative to the application root. If you want to open a prompt from consent-form the path will be prompts/prompt. Warning Webpack users should always mark dynamically loaded dependencies with PLATFORM.moduleName. For more details do check the aurelia-webpack-plugin wiki. object - it will be used as the view model. In this case view must also be specified. class - the view model class or constructor function. view can be url or view strategy to override the default view location convention. model the data to be passed to the canActivate and activate methods of the view model if implemented. host allows providing the element which will parent the dialog - if not provided the body will be used. childContainer allows specifying the DI Container instance to be used for the dialog. If not provided a new child container will be created from the root one. lock makes the dialog modal, and removes the close button from the top-right hand corner. (defaults to true) keyboard allows configuring keyboard keys that close the dialog. To disable set to false. To cancel close a dialog when the ESC key is pressed set to true, 'Escape' or and array containing 'Escape' - ['Escape']. To close with confirmation when the ENTER key is pressed set to 'Enter' or an array containing 'Enter' - ['Enter']. To combine the ESC and ENTER keys set to ['Enter', 'Escape'] - the order is irrelevant. (takes precedence over lock) overlayDismiss if set to true cancel closes the dialog when clicked outside of it. (takes precedence over lock) centerHorizontalOnly means that the dialog will be centered horizontally, and the vertical alignment is left up to you. (defaults to false) position a callback that is called right before showing the modal with the signature: (modalContainer: Element, modalOverlay: Element) => void. This allows you to setup special classes, play with the position, etc... If specified, centerHorizontalOnly is ignored. (optional) ignoreTransitions is a Boolean you must set to true if you disable css animation of your dialog. (optional, default to false) rejectOnCancel is a Boolean you must set to true if you want to handle cancellations as rejection. The reason will be a DialogCancelError - the property wasCancelled will be set to true and if cancellation data was provided it will be set to the output property. Warning Plugin authors are advised to be explicit with settings that change behavior (rejectOnCancel)."},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Accessing The DialogController API","sectionId":"accessing-the-dialogcontroller-api","id":1817,"text":"It is possible to resolve and close (using cancel/ok/error methods) dialog in the same context where you open it."},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Styling The Dialog","sectionId":"styling-the-dialog","id":1818,"text":"Overriding The Defaults The CSS classes for the dialog are hard-coded in dialog-configuration.ts.  When you configure the dialog plugin via config.useDefaults() the following code code is executed. If you want to override the default styles, configure the plugin instead by calling useCSS('') in main.ts. Copying the CSS from dialog-configuration.ts to your application's CSS file is a good starting point. Overlay With 50% Opacity Bootstrap adds 50% opacity and a background color of black to the modal.  To achieve this in dialog you can simply add the following CSS."},{"articleName":"Dialog","articleHref":"docs/plugins/dialog","sectionName":"Lifecycle Hooks","sectionId":"lifecycle-hooks","id":1819,"text":"In adition to the lifecycle hooks defined by aurelia-templating, the aurelia-dialog defines additional ones. All dialog specific hooks can return a Promise, that resolves to the appropriate value for the hook, and will be awaited. .canActivate() With this hook you can cancel the opening of a dialog. It is invoked with one parameter - the value of the model setting passed to .open(). To cancel the opening of the dialog return false - null and undefined will be coerced to true. .activate() This hook can be used to do any necessary init work. The hook is invoked with one parameter - the value of the model setting passed to .open(). .canDeactivate(result: DialogCloseResult) With this hook you can cancel the closing of a dialog. To do so return false - null and undefined will be coerced to true. The passed in result parameter has a property wasCancelled, indicating if the dialog was closed or cancelled, and an output property with the dialog result which can be manipulated before dialog deactivation. Warning When DialogController.prototype.error() is called this hook will be skipped. .deactivate(result: DialogCloseResult | DialogCloseError) This hook can be used to do any clean up work. The hook is invoked with one result parameter that has a property wasCancelled, indicating if the dialog was closed or cancelled, and an output property with the dialog result. Order of Invocation Each dialog instance goes through the full lifecycle once. constructor call .canActivate() - aurelia-dialog specific .activate() - aurelia-dialog specific .created() - as defined by aurelia-templating .bind() - as defined by aurelia-templating .attached() - as defined by aurelia-templating .canDeactivate() - aurelia-dialog specific .deactivate() - aurelia-dialog specific .detached() - as defined by aurelia-templating .unbind() - as defined by aurelia-templating "},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Introduction","sectionId":"introduction","id":1820,"text":"Most of the current major browsers limit the number of simultaneous connections per hostname to six. This means that while six requests are being processed, additional requests for assets on a host will be queued by the browser. In the image below, the Chrome F12 developer tools network tab shows the timing for assets required by the welcome view of the unbundled, JSPM-based skeleton-navigation application. No of requests made by unbundled application As we can see, there are over 95 requests being made to load the first view. While the first few requests are being processed the others are waiting, ultimately taking almost 2.39s on a local machine. In the past, the most common browser limit has been 2 connections. This may have been sufficient in the beginning of the web when most of the content was delivered in a single page load. However, it can soon become the bottleneck when building rich client applications with frameworks like Aurelia and others. You may wonder: If this limit can have such a great impact on performance, then why don't browsers give us a higher limit? Most well-known browsers choose not to grant this wish in order to prevent the server from being overloaded by a small number of browsers. Such activity would be similar in nature to a DDOS attack."},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Bundling ","sectionId":"bundling","id":1821,"text":"This connection limit will not cause slowness in our application if we can manage resources well enough to avoid it. When the page is first loaded, this is the initial request that returns HTML content. When the browser processes the HTML content, it spawns more requests to load resources like JS, CSS and images. It also executes JavaScript and sends AJAX requests to the server. To make this process efficient, we need to compress the assets and make fewer (possibly less than 6) requests to load everything we need. Fortunately, static resources can be cached and only downloaded the first time. If they cause slowness, it happens on the first page load only and may be tolerable. Bundling along with minification are techniques that can also be used to improve load time. Bundling and minification improve load time by reducing the number of requests to the server as well as reducing the size of requested assets such as views, view-models and CSS."},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Bundling an Aurelia Webpack Application","sectionId":"bundling-an-aurelia-webpack-application","id":1822,"text":"In the following example, we will use the skeleton-navigation as our app to bundle. If you don't have that set up. Follow these steps. Now that we have our app running, let's try to build the preconfigured bundle. Webpack, as opposed to JSPM, is not a loader, which means it always creates bundles before loading a page is possible. By default there are two versions of bundles you can create: the development bundle and the production bundle. To build the development bundle execute: To build an optimized, minified production bundle execute: You can find the configuration for both of these bundles in the webpack.config.js file. We'll look into it in a bit. After the bundle is created, by default you'll find the output in the dist folder. Warning The dist folder is automatically deleted before a new bundle is built. To start a simple web server and test either the development or production build execute: After executing the command, you'll see a link which will run your bundled application."},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Entry Bundles","sectionId":"entry-bundles","id":1823,"text":"The skeleton-navigation is configured to create 3 explicit entry bundles by default: aurelia-bootstrap - contains modules needed to be loaded first, such as polyfills and Aurelia's Platform Abstraction Layer aurelia - contains all of the aurelia's modules app - contains files from within the src folder and their dependencies However, you are free to define as many entry bundles as we want, by listing the packages as entry points of webpack.config.js: In the above example we created an explicit bundle called vendor that only contains the package: moment. Defining entry bundles is only useful when you want to be able to make use of client-server file caching, because it means that you can only update the bundles which contain the changes, instead of all of them. To make it easier to see whether it's necessary to update a certain bundle, the production bundles by default contain a hash in their filename."},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Code-Splitting: Chunks / Async Bundles","sectionId":"code-splitting-chunks-async-bundles","id":1824,"text":"By default, all of our application code is contained in the app entry bundle. If our application is small enough, we can keep using just that single bundle, however the number of bundles we would like to have should mostly depend on our application structure and the usage patterns of our app. For example, if our app was built in a modular fashion, such that it is a collection of child-app/sections, then a common bundle for third-party libraries and a bundle per section makes much more sense and performs better than a huge single bundle that needs to be loaded up front. This is because such \"implicit bundles\" are loaded asynchronously, on demand. There are two ways to define code-splitting bundles: centralized, in the package.json as parameters of the <require> tag of your .html View files For most use-cases, I recommend using the centralized approach, as it makes it easier for you to analyze the output structure. Centralized Approach Let's say we want to separate out the View and ViewModel: src/users contained in the skeleton and defer its loading to when the user clicks on a link to that route, you could define an async bundle as follows: Info Note that path is relative to the src of our application, but can also be an external path, such as bootstrap/css/bootstrap.css or aurelia-plugin/some-resource.html. If no extension is specified, all of .js, .ts and .html are tried. The path property may also be an Array with a list of paths to be contained in a bundle. Such a definition will create a Webpack split-point, meaning the bundle will only be loaded when it is needed (so-called \"lazy-loading\"). Warning It is imperative to remember that the code will not end-up in the bundle, or the bundle will end-up being loaded prematurely, if you statically import anything from the files specified for implicit bundling. Webpack is intelligent enough to resolve any further dependencies that those files and modules depend on (regardless if they are JavaScript files, modules with their own package.json declarations or additional HTML or CSS resources). In our example, the users ViewModel also requires the blur-image Custom Attribute, and thus would also be contained within it the users bundle. When the bundler plugin analyzes the users file it will find aurelia-framework and aurelia-fetch-client as it's dependencies and include them in the bundle. But the bundler does not stop there. It will recursively find the dependencies of aurelia-framework and aurelia-fetch-client and will go on until there is nothing left. But since those dependencies are already in the aurelia entry bundle, it will not duplicate them in the users bundle, thanks to the @easy-webpack/config-common-chunks-simple present in the default configuration (more on that later on). In-View Approach For quickly declaring a certain <require> as lazy (deferred loading), or in testing scenarios, you can use Webpack-specific custom attributes that will be analyzed by Aurelia's Webpack plugin and forwarded as bundling information to Webpack: Both the lazy and the bundle attributes are optional. If you do not specify the bundle name, the chunk number will be used instead."},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Declaring Build Resources","sectionId":"declaring-build-resources","id":1825,"text":"By default, all the production dependencies declared in the package.json that have a main entry file are considered as build resources. In case Aurelia is supposed to load an external file or an external module that was not defined as a resource by any of its the dependencies, resources must also be specified manually. Warning Since the syntax is still relatively new, many Aurelia plugins do not declare their resources. If you are developing an Aurelia plugin, make sure you do this, so that your users do not have to. The package.json syntax is similar, with the one exception that resources are relative to the root directory of the plugin, as there is no src folder. There might reasons not to declare those resources in all cases,for example when the plugin is to be partially consumed (e.g. only one Button element from a package containing multiple Aurelia elements). If we'd like to consume such external resources, we should declare them ourselves, for example: You can also combine both features to separate out plugins or resources for lazy-loading:"},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Chunking Code When It Is Not Loaded By Aurelia","sectionId":"chunking-code-when-it-is-not-loaded-by-aurelia","id":1826,"text":"If you have code that you'd like to load asynchronously in your ${context.language.name} files, you can make use of the System loader compliant syntax to create split-points. Example use-cases for this are: conditionally loading foreign language support based on the user's selection or conditionally polyfilling certain features. Such code-splitting is used to polyfill fetch support in the users file of skeleton-navigation. Let's take a look at how it works: The System.import method is the asynchronous equivalent of the ES2015 import. It returns a Promise. The example above will only load the isomorphic-fetch polyfill in case fetch is not already available in the browser. System.import and TypeScript When using TypeScript and the System.import API means you do not get any Typing information. As a workaround you can add custom definitions in a stub file, defining all of the asynchronous imports explicitly. To allow Typings for asynchronously loaded aurelia-framework and isomorphic-fetch packages, see the following example:"},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Duplicate Modules in Multiple Bundles","sectionId":"duplicate-modules-in-multiple-bundles","id":1827,"text":"By default, the webpack.config.js uses the CommonsChunkPlugin under the hood, to eliminate code duplication across bundles by placing common code in the app bundle. If you have additional custom entry bundles, or somehow misused or misconfigured them, you may end up with duplicated modules in multiple bundles. Creating multiple bundles requires us to be extra careful because multiple bundles may contain duplicate modules. Before explaining that, we need to understand how bundling works behind the scenes a bit. Let's consider the example modules A and B below: When we want to bundle a.js, Webpack will analyze the source code of the module and find the dependencies by tracing the import statements. In this case, Webpack will yield b.js as the dependency of a.js and ultimately place b.js in the bundle. To have full control over how Webpack distributes and de-duplicates the modules in the chunks, please refer to Webpack documentation on the matter and replace the @easy-webpack/config-common-chunks-simple configuration with a custom one."},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Bundle Configuration and Easy Webpack","sectionId":"bundle-configuration-and-easy-webpack","id":1828,"text":"Webpack is a very advanced piece technology, but it can be quite intimidating to beginners and hard to re-configure even for seasoned users. For this very reason, the skeleton-navigation example uses a package called Easy Webpack that allows us to quickly stich together a number of configuration objects and supports presets. In more advanced use-cases, we can still override its configuration values, or replace the presets with custom configuration. Let's take a look at how a configuration file can be put together: As you can see, adding each easy-webpack preset package is like adding a \"feature\" to the configuration file, without needing to know much more. The names of the packages are self-explanatory. The skeleton-navigation config file is a bit more advanced, in that it generates different configs depending on the set environment, since you might want slightly different settings for production, testing and development. For example, you'd want to minify resources in production, but keep fast loading Source Maps in development. You can easily replace all the preset packages with your own configuration objects. Please refer to the Easy Webpack documentation for more information about its capabilities."},{"articleName":"Webpack Bundling","articleHref":"docs/build-systems/webpack/bundling","sectionName":"Conclusion","sectionId":"conclusion","id":1829,"text":"In this article, you've learned both the why and how of bundling with Webpack. We've covered how to configure Webpack's configuration file for use with Aurelia and demonstrated several different scenarios for asynchonous loading of parts of your code. To bundle your own app, we recommend that you begin with the skeleton-navigation configuration file and customize it. You may have a small app that makes sense as a single bundle or a larger one that can be broken down into features. Each application is different, but Webpack is extremely flexible and should help you to create the optimal deployment for your unique scenarios. "},{"articleName":"JSPM Setup","articleHref":"docs/build-systems/jspm/setup","sectionName":"Configuring Your Environment","sectionId":"configuring-your-environment","id":1830,"text":"Let's start by getting you set up with a great set of tools that you can use to build modern ${context.language.name} applications. All our tooling is built on Node.js. If you have that installed already, great! If not, you should go to the official web site, download and install it. Everything else we need will be installed via Node's package manager (npm). If you already have npm installed, make sure you've got the latest version to avoid any issues with the other tools. Info For command-line operations, we recommend Windows users to use Git Bash or Git Shell. First, let's begin by installing Gulp which we'll be using for build automation. If you don't have it already, you can use npm to set it up like this (in some environments you may need to use sudo): Next, we need to install jspm. This will serve as our client-side package manager. You can do that like this:"},{"articleName":"JSPM Setup","articleHref":"docs/build-systems/jspm/setup","sectionName":"Setting up the Project Structure and Build","sectionId":"setting-up-the-project-structure-and-build","id":1831,"text":"With the tooling installed, we can now turn our attention to setting up a basic structure for your app. We'll begin by downloading a skeleton. We've got several versions available for you based on your language and tooling preferences. Please download the latest skeletons now. Once the download has completed, unzip it and look inside. The readme file contained therein will explain the various options available to you. Please select one of the skeletons and copy it to the location on your file system that you wish your code to reside. Be sure to rename the folder to appropriately represent the app you want to build. You will now find everything you need inside the folder, including a basic build, package configuration, styles and more. With all this in place, let's run some commands. Open a console and change directory into your app's directory. Execute the following command to install the dependencies listed in the devDependencies section of the package manifest: Next, execute the following command to install the Aurelia libraries, bootstrap and font-awesome, listed in the jspm.dependencies section of the package manifest: Everything we've done so far is standard Node.js build and package management procedures. It doesn't have anything specific to do with Aurelia itself. We're just walking you through setting up a modern ${context.language.name} project and build configuration from scratch. Info Bootstrap and Font-Awesome are not dependencies of Aurelia. We only leverage them as part of the starter kit in order to help you quickly achieve a decent look out-of-the-box. You can easily replace them with whatever your favorite CSS framework and/or icon library is."},{"articleName":"JSPM Setup","articleHref":"docs/build-systems/jspm/setup","sectionName":"Running The App","sectionId":"running-the-app","id":1832,"text":"If you've followed along this far, you now have all the libraries, build configuration and tools you need to create amazing ${context.language.name} apps with Aurelia. The next thing to do is run the sample app. To see this in action, on your console, use the following command to build and launch the server: You can now browse to http://localhost:9000/ to see the app. Warning The Skeleton App uses BrowserSync for automated page refreshes on code/markup changes concurrently across multiple browsers. If you prefer to disable the mirroring feature, set the ghostMode option to false in your build config."},{"articleName":"JSPM Setup","articleHref":"docs/build-systems/jspm/setup","sectionName":"Running The Unit Tests","sectionId":"running-the-unit-tests","id":1833,"text":"To run the unit tests, first ensure that you have followed the steps above in order to install all dependencies and successfully build the library. Once you have done that, proceed with these additional steps: Ensure that the Karma CLI is installed. If you need to install it, use the following command: You can now run the tests with this command:"},{"articleName":"JSPM Setup","articleHref":"docs/build-systems/jspm/setup","sectionName":"Running The E2E Tests","sectionId":"running-the-e2e-tests","id":1834,"text":"Integration tests are performed with Protractor. Place your E2E-Tests into the folder test/e2e/src. Install the necessary webdriver: Configure the path to the webdriver by opening the file protractor.conf.js and adjusting the seleniumServerJar property. Typically it's only needed to adjust the version number. Make sure your app runs and is accessible: In another console run the E2E-Tests:"},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Introduction","sectionId":"introduction","id":1835,"text":"Most of the current major browsers limit the number of simultaneous connections per hostname to six. This means that while six requests are being processed, additional requests for assets on a host will be queued by the browser. In the image below, the Chrome F12 developer tools network tab shows the timing for assets required by the welcome view of the skeleton-navigation application. No of requests made by unbundled application As we can see, there are over 95 requests being made to load the first view. While the first few requests are being processed the others are waiting, ultimately taking almost 2.39s on a local machine. In the past, the most common browser limit has been 2 connections. This may have been sufficient in the beginning of the web when most of the content was delivered in a single page load. However, it can soon become the bottleneck when building rich client applications with frameworks like Aurelia and others. You may wonder: If this limit can have such a great impact on performance, then why don't browsers give us a higher limit? Most well-known browsers choose not to grant this wish in order to prevent the server from being overloaded by a small number of browsers. Such activity would be similar in nature to a DDOS attack."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Bundling ","sectionId":"bundling","id":1836,"text":"This connection limit will not cause slowness in our application if we can manage resources well enough to avoid it. When the page is first loaded, this is the initial request that returns HTML content. When the browser processes the HTML content, it spawns more requests to load resources like JS, CSS and images. It also executes JavaScript and sends AJAX requests to the server. To make this process efficient, we need to compress the assets and make fewer (possibly less than 6) requests to load everything we need. Fortunately, static resources can be cached and only downloaded the first time. If they cause slowness, it happens on the first page load only and may be tolerable. Bundling along with minification are techniques that can also be used to improve load time. Bundling and minification improve load time by reducing the number of requests to the server as well as reducing the size of requested assets such as views, view-models and CSS."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Bundling an Aurelia JSPM Application","sectionId":"bundling-an-aurelia-jspm-application","id":1837,"text":"We can  use Aurelia Bundler to create a gulp task for bundling our JSPM app. Let's jump right into it. We will use the skeleton-navigation as our app to bundle. If you don't have that set up. Follow these steps. Now that we have our app running, let's start by installing aurelia-bundler. To do so cd into skeleton-navigation and run the following command: Now, let's create a bundle.js file in build/tasks/bundle.js as follows: Info The bundle function returns a Promise for proper integration into async task engines like Gulp. With that file in place, let's run the command below: Here are the things that should have happened after Gulp is finished executing the bundle task: A file, dist/app-build.js is created. A file, dist/vendor-build.js is created. config.js is updated. Now, if we refresh/reload the app from the browser, we will see much less network traffic. This means that our app is properly bundled. No of requests made by bundled application Just 9 requests tells the story. We have also managed to minimize the size from 1.2MB to just 773KB here."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Multiple Bundles","sectionId":"multiple-bundles","id":1838,"text":"We can create as many bundles as we want. Here we have created two: one for our application code and another for Aurelia and third-party libraries. We can create just a single bundle, if we want, that combines both application code and third-party libraries. The number of bundles we would like to have mostly depends on our application structure and the usage patterns of our app. For example, if our app was built in a modular fashion, such that it is a collection of child-app/sections, then a common bundle for third-party libraries and a bundle per section makes much more sense and performs better than a huge single bundle that needs to be loaded up front."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Bundling a JSPM v0.17 App","sectionId":"bundling-a-jspm-v017-app","id":1839,"text":"In a JSPM v0.17 style app, we have two separate config files: jspm.browser.js and jspm.config.js. In such case the configPath in the bundle config should look like: configPath: ['./jspm.browser.js', './jspm.config.js']. We also have to add another injectionConfigPath to indicate which config file should host the bundle and depCache injection. Here is a typical bundle configuration for a JSPM v0.17 app."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Duplicate Modules in Multiple Bundles","sectionId":"duplicate-modules-in-multiple-bundles","id":1840,"text":"Creating multiple bundles requires us to be extra careful because multiple bundles may contain duplicate modules. Before explaining that, we need to understand how bundling works behind the scenes a bit. Let's consider the example modules A and B below: When we want to bundle a.js, the bundler will analyze the source code of the module and find the dependencies by tracing the import statements. In this case, the bundler will yield b.js as the dependency of a.js and ultimately place b.js in the bundle. Let us now take a closer look at the config object. We will skip force and packagePath for the moment. bundles is where we will focus now, specifically the includes. Please pay attention to the pattern [*.js]. The bundler supports some glob patterns like *.js, */**/*.js etc. *.js here means, we are interested in bundling all the js assets in the dist folder (considering the path in config.js). So what does [*.js] mean here? Well, as we know, the bundler will trace the module dependencies from the import statements. Lot's of our code refers to the modules of Aurelia via import statements. For example: When the bundler analyzes this file it will find aurelia-framework and aurelia-fetch-client as it's dependencies and include them in the bundle. But the bundler does not stop there. It will recursively find the dependencies of aurelia-framework and aurelia-fetch-client and will go on until there is nothing left. Having *.js in the above config will create a bundle containing lots of Aurelia libraries including aurelia-framework and aurelia-fetch-client. If we consider the second bundle config dist/vendor-build, we have 'aurelia-bootstrapper' and 'aurelia-fetch-client'. aurelia-bootstrapper will yield aurelia-framework. Ultimately, we will end up with duplicate modules in both the bundles. Our goal is to create a bundle of our application code only. We have to somehow instruct the bundler not to recursively trace the dependencies. Guess what? [*.js] is how we do it. [*.js] will exclude the dependencies of each module that the glob pattern *.js yields. In the above case it will exclude aurelia-framework, aurelia-fetch-client and so on."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Bundle Configuration","sectionId":"bundle-configuration","id":1841,"text":"Here is a typical bundle configuration in all its glory: dist/app-build : This is the name of the bundle and also where the bundle file will be placed. The name of the bundle file will be app-build.js. As the baseURL for skeleton-navigation pointed to dist folder, we named it dist/app-build. includes : We will specify all the modules/files that we want to include here. Since all our JavaScript is in the dist folder and we have the path rule configured in config.js that points to the dist folder. If we simply specify * all our js modules will be included. We can specify */**/* here if we want to include all the subfolders. *.html!text: This includes all the templates/views in the bundle. The !text tells the Bundler and Loader that these files will be bundled and loaded using the text plugin. *.css!text: Like html templates, we are including all the css here. If you have previously used plugin-css, note that we are not using !css here. The Aurelia Loader uses text plugin for loading css to analyze and do other interesting things like scoping etc. excludes: This is where we specify what we want to exclude from the bundle. For example, * includes all the JS files in the dist folder. For example, if for some reason we want app.js to be excluded from the bundle, we would write: Warning Exclusion of files that are being used in the project but are not part of it (e.g. CDN URLs, URLs relative to the host, etc.) is done automatically. For bundling to work, do not add them to the excludes section. It will cause an error. inject: If set to true, this will inject the bundle in config.js, so whenever the application needs a file within that bundle, the loader will load the entire bundle the first time. This is how we can achieve lazy bundle loading. For a large app with multiple sub sections, this will help us avoid loading everything upfront. minify: As the name suggests, if this is set to true, the the source files will be minified as well. rev: If this is set to true, an unique revision number will be appended to the bundle file name. force : If this is set to true the task will overwrite any existing file/bundle with the same name. Set it to false if you are not sure about it. packagePath : By default it is '.', You can change this if your package.json file is somewhere else other than the base of your app. aurelia-bundler uses this file to find config.js, baseURL, the jspm_packages folder and other important project configuration."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Bundling HTML Imports","sectionId":"bundling-html-imports","id":1842,"text":"At this point, if you are thinking: \"Well, this is all good but we have already developed an application that uses Polymer and  HTML Imports extensively. We want to bundle them as well.\" As you may already know, we have created a separate plugin aurelia-html-import-template-loader exclusively for this use case. We have bundling support for that too. This is how we can do it. It's actually a two part process. First let's install the aurelia-html-import-template-loader plugin with the command below: Now, let's open src/main.js and add this line: After the change main.js should look like this: With this little change Aurelia Loader will now use HTML Imports to load all the views. Now, back in our bundle task, we will add a config like this: We will also change the first bundle a little bit to exclude all the html and css files. Finally our bundle.js file should look like this: We have changed the source code (src/main.js), so we need to rebuild our app. The command below should do that: Info The serve task is already configured in such a way that it runs the build task first. Now, let's run gulp bundle from another console/tab. If we now refresh/reload our app from the browser, keeping the developer tools open, we should see the difference. Warning The order in which the tasks are run is important. The build removes all the files in dist folder. As a result, any bundle file in that folder will be deleted too. This is why we always have to run the gulp bundle after the build task is finished. If you are using watch you will have to be extra careful here. Every change you make in the source file will trigger a build task that clears the dist folder and any bundles as well. Let's examine the configuration one property at a time: dist/view-bundle : The name of the bundle file is view-bundle.html and will be placed in dist folder. htmlimport : This is what makes it different from other bundles. If this is set to true the bundler will treat it as a html import based bundle and Aurelia loader will give it a different treatment as well. includes: This is where we will specify what goes in the bundle. All the glob patterns are supported here including arrays of patterns and ! based exclusion. For example: The above pattern will bundle all the views in dist and its child folders except everything in the dist/movie folder. options : if inject is set to true then a <link rel=\"import\" href=\"path/of/bundle.html\"> will be injected in the body of index.html. If you would like to keep your index.html clean and create a separate index file then you have to set indexFile and destFile."},{"articleName":"JSPM Bundling","articleHref":"docs/build-systems/jspm/bundling","sectionName":"Conclusion","sectionId":"conclusion","id":1843,"text":"In this article, you've learned both the why and how of bundling. We've covered the bundler library, how to configure it for use with Gulp and demonstrated several different scenarios. To bundle your own app, we recommend that you begin with one of the configurations above and customize it. You may have a small app that makes sense as a single bundle or a larger one that can be broken down into features. Each application is different, but the bundler will help you to create the optimal deployment for your unique scenarios."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Introduction","sectionId":"introduction","id":1844,"text":"With the Component Tester you can easily stage a custom element or custom attribute in isolation inside a mini Aurelia application, assert how it responds to data-binding and assert its behavior throughout the component's lifecycle (bind, attached etc)."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Getting Started","sectionId":"getting-started","id":1845,"text":"If you are using JSPM: If you are using NPM: Once you've got the library installed, you can use it in a unit test. In the following examples we will be using Jasmine, but any testing framework would work."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Testing a Custom Element","sectionId":"testing-a-custom-element","id":1846,"text":"Let's start with a simple custom element that we want to test: In order to test that the component renders expected HTML, based on what the view is bound to, we can write following test: Running the test should result in the following html should be rendered <div class=\"firstName\">Bob</div> and the test should pass. But let's take a step back and see what is going on here. First, we import StageComponent from aurelia-testing: StageComponent is just a convenience factory that creates a new instance of the ComponentTester class. ComponentTester is the actual class doing all the work. Next we use the StageComponent factory to stage our component: StageComponent comes with one property, withResources, that lets you start off the staging with a fluent API. withResources lets you specify which resource or resources for Aurelia to register.  It takes either a string for registering one single resource or an Array of strings for registering multiple resources. inView lets you provide the html markup to be run. This is just a standard Aurelia view where you can do all the data binding you are used to in a full-blown Aurelia application. boundTo lets you provide a test viewModel with the data that the view will get bound to. In this example, the staging of the component is done in Jasmine's beforeEach method in order to reuse the same setup for multiple tests. Info If you are using karma and your configuration already has a path for '*': 'src/*' set you may not need to use src/, and just my-component. Next, we come to the actual test where we call create on the ComponentTester. Create will kick everything off and bootstrap the mini Aurelia application, configure it with standardConfiguration (we will take a look later at how you can run with your own configuration), register provided resources as global resources, start the application and finally render your component so you can assert the expected behavior. In this case, we want to make sure our firstName property gets rendered correctly in the HTML by selecting the div tag via it's class name. We use document.querySelector('.firstName'); to grab that and then check that its innerHTML is Bob. Next we call Jasmine's done function to tell Jasmine that the test is complete. Calling done is needed since the create method is asynchronous and returns a Promise. Finally, we call dispose on our ComponentTester instance. This will clean up the DOM so our next test will start out with a clean document. That's pretty much all there is to it. Easy right? Imagine doing the same assert with stand alone unit tests that run outside of Aurelia. It would be pretty difficult, especially for a more complex component."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Manually handling lifecycle","sectionId":"manually-handling-lifecycle","id":1847,"text":"When testing a component sometimes you want to have tests run at certain points of the lifecycle.  To do this we can tell the component we created that we will manually handle the lifecycle methods - As you see, the test helper lets you easily push components through their lifecycle, testing various aspects of it at each point along the way."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Testing a Custom Attribute","sectionId":"testing-a-custom-attribute","id":1848,"text":"Testing a Custom Attribute is not much different than testing a Custom Element. Let's look at how it's done by starting with a simple example custom attribute that lets you change the background color of the element it is placed on: Now, let's assert that the element actually gets the background color it is bound to: As you can see, everything follows the same pattern we had for our custom element test. One exception is that we take advantage of the element property which gets provided by the ComponentTester instance. The element property is the actual HTML element that gets rendered. This can also be used when testing custom elements."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Testing custom component with a real view-model","sectionId":"testing-custom-component-with-a-real-view-model","id":1849,"text":"If you want to test a custom component with a real view-model, mocking out all dependencies, you can do this as well.  A common scenario is to test the view/view-model, mocking out service calls to the backend. If the view model has a dependency on a class called Service for all backend communication:"},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Using a Real Parent View-model","sectionId":"using-a-real-parent-view-model","id":1850,"text":"If you want to test using a custom element inside of a real parent view-model this can be done just as easily.  This can be really helpful when needing to test the state of a parent that is affected by the child custom element or attribute - Using this you can also use the ref custom attribute to get access to things and check their state in the view-model. Or if your view-model has dependencies to load through DI - Now the service dependency for MyComponent will be resolved through DI automatically."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Improving Readability with Multi-line Strings","sectionId":"improving-readability-with-multi-line-strings","id":1851,"text":"You can improve the readability of your complex views by using template literals in your tests -"},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Helpful Properties and Functions","sectionId":"helpful-properties-and-functions","id":1852,"text":"The ComponentTester exposes a set of properties that can be handy when doing asserts or to stage a component in a specific way. Here's a list of what is available: element - The HTML element that gets rendered. viewModel - The view-model for the component. configure - The ComponentTester's configure method can be overwritten in order to set it up with custom configuration or get a reference to the container instance. dispose - Cleans up the DOM after a test has run. bind - Manually handles bind. unbind - Manually handles unbind. attached - Manually handles attached. detached - Manually handles detached. waitForElement and waitForElements - Waits until one or several elements are present / absent. See below."},{"articleName":"Testing Components","articleHref":"docs/testing/components","sectionName":"Testing complex components","sectionId":"testing-complex-components","id":1853,"text":"In some cases, the tested element is not rendered yet when the component.create() promise is resolved, and therefore when the actual test starts. For these situations, aurelia-testing and ComponentTester expose helper methods and functions to wait for tested elements to be present in the page. Waiting for element(s) If you want to wait for elements that can be looked up in the DOM using a query passed to querySelector or querySelectorAll, you can use one of the following: ComponentTester.waitForElement or ComponentTester.waitForElements: to wait for one or several HTML element(s) within the tested component. The query is carried out using querySelector and querySelectorAll, respectively. waitForDocumentElement or waitForDocumentElements (imported from aurelia-testing): to wait for one or several HTML element(s) within the document, not restricted to the descendants of the tested component. This is especially useful if you want to wait for elements created by third-party libraries such as context menus, date pickers, etc. All these methods and functions take 2 arguments: selector (mandatory): is a selector string to look up the wanted element(s). It must be compatible with querySelector and querySelectorAll options is an object that can have the following properties: present: true to test for presence, false for absence (defaults to true) interval: the polling interval (defaults to 50ms) timeout: the timeout (defaults to 5s) They all return a Promise that resolves to an Element (waitForElement) or a NodeList (waitForElements). The Promise is rejected in the event of a timeout. The returned Promise can be used to execute some testing code only once a given element has been detected to be present or absent, either because the component was slow to be fully rendered or because the test relies on asynchronous actions such as events or animations. Waiting for matches to complex queries ... or anything else If your query is complex (with non-trivial jQuery lookups for example), or you want to wait for the result of a callback to be something else than null, you can use the higher-level waitFor function imported from aurelia-testing. waitFor(getter, options) works exactly the same way as the previously described methods and functions, but takes a callback (getter) as the first argument instead of a selector string. waitFor internally calls getter with no arguments at regular intervals times until the returned value is anything else than null, an empty NodeList or jQuery set. The returned Promise will resolve to the result of getter(). Examples"},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"What is E2E testing?","sectionId":"what-is-e2e-testing","id":1854,"text":"End-To-End (E2E) testing is all about testing your application against specific scenarios. From a requirements-engineering-perspective you'd call those User Stories. Essentially, these stories describe a series of actions a user performs to achieve a certain goal. So by assembling a bunch of these - referred to as a test suite - you are able to verify that your web app acts as expected. The key to success, of course, lies in the amount and quality of tests written. With E2E testing you are not interacting with the app's code per se, but with the app's interface. This is different than unit tests, which take care of isolated parts of the application - called units - by verifying them through the removal or mocking of other parts. It's important to note that one method of testing does not replace the other, so don't take this article as an excuse to skip unit testing."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"How are E2E tests different?","sectionId":"how-are-e2e-tests-different","id":1855,"text":"One of the key differences when working with E2E tests is that all of your work is located in the browser, which naturally leads to writing a lot of asynchronous code. It doesn't matter whether you request a DOM Element, send some fake keystrokes or trigger a click, each of these actions needs to be automatically translated to understandable instructions and sent to the browser under test. So working with Promises becomes a major enabler when keeping track of deferred executions and responses. Another important aspect already noted is the necessity to translate programmatic actions into browser understandable ones. Needless to say, variations exist between the different browsers... When performing E2E tests you also need to take into consideration that you are actually testing a real web page. So, compared to unit tests, you will additionally need your web page up and accessible by the browser during test execution. Keep in mind that E2E tests, sometimes also referred to as integration tests, test your app's system as a whole. Thus, modifications which get persisted to databases or local storage will stay that way and may produce side effects for your next test run. Last but not least, there is a much higher test code maintenance cost, compared to unit tests. The reason is that now, not only one component is tested exclusively, but rather the whole system at once. Imagine trying to fill out an input element with the id txtFirstname, just to realize the next day your tests fail because your fellow front-end designer decided to change the name to txtFirstName. This makes it clear that you must treat your test code like general application logic and give it all the love it deserves."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Protractor","sectionId":"protractor","id":1856,"text":"Although the previous section may sound depressing, there is hope for developers in Protractor, an End-To-End testing framework. Under the hood it's actually a Node.js application, which supports a wide variety of assertion/test libraries like Jasmine, Mocha or Cucumber. Info: Jasmine The remainer of the article will use the BDD Testing Framework Jasmine. A nice tutorial on how to use Jasmine can be found here. Protractor acts as a wrapper on top of the WebDriverJS-API, which is used to communicate with a Selenium Server, either local (standalone) or remote. The picture below depicts the whole process. Protractor communicates via the WebDriverJS-API (the way to talk to Selenium's WebDriver API) which is used to translate user interactions into browser understandable instructions. Protractor Diagram Now the interesting thing is that instead of manually testing your application in each of the major browsers, automated Protractor tests can run on multiple browsers at the same time, saving you valuable time and money. Support is wide-spread and even includes headless browsers like PhantomJS. Besides that, being a wrapper, it offers additional convenience features, not present in the vanilla WebDriverJS-API. One feature, perhaps the most important, is that it allows you to write asynchronous tests in a synchronous style. This means that Protractor will automatically execute the next task, the moment the previous pending tasks finish."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"A Basic Example","sectionId":"a-basic-example","id":1857,"text":"To get a basic idea of how this works, take a look at the following example. As you can see, the test utilizes Jasmine for BDD style testing which is placed in a separate JavaScript file and defines a scenario/suite by using a describe block. Each test then gets handled by a separate it function. In this one we'd like to verify that after loading the Aurelia Homepage, the title equals our expected page title. The first line will issue a general browser method get which loads the given URL. This function now returns a promise, to which you'd normally append a then function, which gets called after the promise successfully resolves. In this test case though, we don't need to care about that, because Protractor will execute the expectation only after the previous line has successfully resolved. Protractor also adapts the Jasmine expectations to work in an async way, so by the time matchers like toEqual are called, the previous expectation is already resolved. But sometimes you need to wait for a certain action to happen in the future. Again we can leverage the general browser object and utilize it's sleep method."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Accessing DOM Elements","sectionId":"accessing-dom-elements","id":1858,"text":"Great! So we know how to load a page. But how do we find DOM Elements and see whether they are rendered properly? Protractor provides the global object element, an ElementFinder, which offers a locator factory by used to define a way to search for elements. Let's take a look at the following example. The first test is looking for an <h2> tag by utilizing the tagName locator. The second test looks for an element with the ID about and expects it to be rendered on the page. Here we use the isPresent method, provided by the ElementFinder. You may have noticed the method beforeEach at the top of the describe block. This is a setup method, which will get called before each test in the current describe block. To perform tear down operations, you'd simply define a function afterEach, which gets called after each test. Info: Protractor Locators You can find a full list of locators here. Just keep in mind that everything specific to AngularJS, like binding or model won't work with Aurelia Apps. We have our own helpers for that."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Interacting with Forms","sectionId":"interacting-with-forms","id":1859,"text":"Now we know how to work with general elements, but what about inputs? Wouldn't it be nice to fake data entries in order to verify the logic of a form? To do so, let's look at the next example. Our test will navigate to the Google homepage, search for a specific keyword, trigger the search and expect to see an element containing the given value. First we navigate to the page using browser.get and look for an input with the name q. The sendKeys method now simulates the keystrokes for the keyword Aurelia. Afterwards we perform a search by clicking the button named btnG. Now we need to wait for Google to perform the search and render the result. We therefore leverage the browser.sleep method to give it some time. Finally we look for a link containing the word Aurelia."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Protractor and Aurelia","sectionId":"protractor-and-aurelia","id":1860,"text":"In order to work with Protractor, there is a little configuration that is necessary. This is done in a configuration file, e.g. protractor.conf.js, which sets up the basic information for Protractor so it can find our test files, start the standalone Selenium server and wire up the JasmineOptions for the console output. The Aurelia Skeleton Navigation App thankfully already shares a pre-configured setup. Let's take a look at it. The first setting tells Protractor to directly connect to the Browser leveraging its WebDriver, in this case, Chrome, defined by the capabilities property. By doing so, Protractor won't need a Selenium Server and will talk directly to the mentioned Browser. The method plugins points to the Aurelia specific implementation of custom matchers and helpers and sets those up before Protractor starts. One of them is the valueBind custom locator, which searches for Aurelia value bindings.The option seleniumAddress now may be omitted since we are using directConnect. It typically would point to a remotely running Selenium instance, helpful in remote testing scenerios. The property specs takes the path to our spec files. Since Aurelia is built from ground up with full support for ES6, we encourage developers to write their tests using ES6 features. Since we'd like to start tests only when Aurelia is fully loaded, we leverage another plugin method called loadAndWaitForAureliaPage. This helper uses a Protractor feature to listen for a DOM event fired by Aurelia after initial view composition. By placing this in a beforeEach section, we ensure that none of the tests will be started before the async script successfully finishes."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Testing the Aurelia Skeleton Navigation App","sectionId":"testing-the-aurelia-skeleton-navigation-app","id":1861,"text":"Besides having the configuration file set up, the Skeleton Navigation App also defines a set of demo tests to help you get started with testing your own page. First you'd need to download the App directly from our Github-Repo and follow the installation instructions. Afterwards, in order to start E2E testing, simply open up a console and run the following command to start up the built-in web server: After that, open another console and hit the following command to start up the E2E test run: You will find the demo spec in the folder test/e2e/src/."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Page Objects","sectionId":"page-objects","id":1862,"text":"To conclude this article we're going to quickly look at how to structure tests. We organize our test methods using a pattern called Page Objects (POs). What this means is that you try to group information about how you access parts of the application into a separate class. This makes it simple to access specific elements multiple times. Now instead of repeating the element.by.xxx code over and over across multiple tests, we unify the access, making it easier to maintain and modify. Since Aurelia promotes the use of ES6, our page objects are simple ES6 classes, exposing functionality through methods. These methods contain the logic for how to interact with Protractor. The following example shows our main Skeleton PO, which takes care of general application information like the page title and page navigation. One notable thing is the usage of the Aurelia specific function waitForRouterComplete. It will wait for a custom DOM event dispatched by Aurelia's router to determine, when the page has been fully loaded and displayed. The second PO is all about the Welcome page."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Test Specification","sectionId":"test-specification","id":1863,"text":"The previously defined page objects can now be imported into our test specification by leveraging the ES6 import syntax. Using beforeEach we can instantiate the POs, navigate to the Web app and wait for the previously mentioned aurelia-composed event to start testing. Our page object methods, in combination with Jasmine's BDD style assertions, make each test become an easy to read English sentence."},{"articleName":"End-to-End Testing","articleHref":"docs/testing/end-to-end","sectionName":"Summary","sectionId":"summary","id":1864,"text":"We hope you enjoyed this introduction to E2E Testing with Protractor and the Aurelia Framework. Time to start writing some tests!"},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"What is Server Side Rendering?","sectionId":"what-is-server-side-rendering","id":1865,"text":"Server Side Rendering is a concept where the server gets more responsibilities, namely rendering the application on the server and sending the fully rendered page back to the client. By doing this the user will see a rendered page more quickly, before the bundles are loaded and the application has started client-side. Since the page that's returned by the server is fully rendered (the page content is already in the HTML), your site will receive a higher ranking by search engines. Server Side Rendering is only feasible because of something called isomorphism. An isomorphic framework allows you to run one application both on the client and the server. Aurelia is such a framework."},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"Caveats","sectionId":"caveats","id":1866,"text":"Even though Server Side Rendering can solve some problems of client side applications, there are some caveats that you should be aware of. The most important one is the fact that your application would run in two different environments: the browser and Node.js. This is possible mostly because of Aurelia's Platform Abstraction Layer which abstracts logic that is platform specific. It is important that you use these abstractions. Node.js is in some ways quite different from a browser environment. There is no (real) DOM, window or document global. Anything that depends on such globals (jQuery for example) will not work. To emulate the DOM, a library called jsdom is used. The Platform Abstraction Layer that's used in the server environment uses jsdom so that basic DOM operations can be done. As long as you use the Platform Abstraction Layer to do any modification to the DOM, you should be fine. Developing your application in a way so that it can be rendered both on the client and the server takes time and effort. Our recommendation is to only use Server Side Rendering if you can spend the time required to make your code work for both the client and server. Since the server will be doing more than just serving static files in a Server Side Rendering setup, more resources are used. So it is necessary to have enough memory and CPU resources available."},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"How It Works","sectionId":"how-it-works","id":1867,"text":"There are a three libraries that are used for Server Side Rendering: aurelia-middleware-koa aurelia-ssr-bootstrapper-webpack aurelia-ssr-engine The aurelia-middleware-koa library is a middleware for Koa which instructs the aurelia-ssr-engine to render the requested page and returns the fully rendered HTML. The aurelia-ssr-bootstrapper-webpack library exposes three functions: initialize, start and stop. These functions are called by the aurelia-ssr-engine for starting and stopping the application and must be the default export of the server bundle. When a request hits the web server and the middleware kicks off the aurelia-ssr-engine, the engine launches a new Aurelia instance. Before it starts the application, the request url is used to set the current URL on the server so that Aurelia renders the page that the user has requested. As soon as the page is rendered, the HTML is sent back to the client. After that, the application is stopped and released from memory. When the client receives the HTML from the server, it can already render the entire page, so it is much quicker to render the initial content. After that initial render, the browser will fetch the client side bundles and start the Aurelia application on the client. There is a significant amount of time between the point where the browser has rendered the HTML it received from the server and the point where the browser has finished loading the bundles and starting the application. In this period of time the user can already click on buttons, write in text inputs and so forth, but there is no JavaScript to handle these events since the Aurelia application is not running yet. This is where a library called preboot comes into play. Preboot captures all events that occur between the rendering of the server view and the rendering of the client view. As soon as the application is running on the client, preboot replays all events it has captured. This allows your application to handle the events like it would in a setup without Server Side Rendering. For example, when the user clicks on a button in the server view, the click event is registered and stored. After the application has started client-side the click event is replayed and the JavaScript is able to process the click event. Another interesting aspect is that there are two bundles, one for the client side application and one for the server side application. This allows you to have different entry points for client and server."},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"Isomorphic Code","sectionId":"isomorphic-code","id":1868,"text":"In order to use server side rendering it is necessary to write your code in a way so that it can run both on the client (a browser environment) and on the server (a Node.js environment). In a setup where there is no Server Side Rendering you could do the following without any issues: However, since there is no document global on the server, you need to use the PAL: Please refer to the API documentation of the Platform Abstraction Layer to find out what functions are available."},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"Memory Management","sectionId":"memory-management","id":1869,"text":"Since the application will be executed on the server a lot of times, you'll want to do some memory management. There are a few things to keep in mind. Using timers like setTimeout or setInterval should be avoided. If you do need to use them, take care to dispose of them properly and as soon as possible. Otherwise Node.js won't able to unload the application because timers are callbacks to application code, and as long as the timer is active the application can't be garbage collected. Another thing to avoid are overrides of global prototypes. For example, overriding any function of Array (e.g. push, unshift etc) is bad practice since Node.js would not be able to unload the application because a global would have a pointer to a function in the application code."},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"Different Main Entry Points","sectionId":"different-main-entry-points","id":1870,"text":"In a non-SSR application you can have a main module (main.js or main.ts) to configure the application during startup. While that configuration works when the application runs client-side, you might want a different configuration when the application starts up on the server side. To accomplish this you can create a server-main.js or server-main.ts as follows: Then, in webpack.server.config.js you can configure the server bundle to use the server-main as the main entry point of your application:"},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"404 pages","sectionId":"404-pages","id":1871,"text":"When using Server Side Rendering you will likely want to take care of requests for non-existing routes. This can be done by mapping unknown routes to a 404 module: When a non-existing route is requested by a user, the server will render the 404 page just like any other page."},{"articleName":"Introduction to SSR","articleHref":"docs/ssr/introduction","sectionName":"Skeleton with SSR Pre-Configured","sectionId":"skeleton-with-ssr-pre-configured","id":1872,"text":"In order to make it easy for you to get started with Server Side Rendering we have put together a skeleton application that already has Server Side Rendering configured. The pre-configured SSR skeleton can be found here. Follow the instructions in the README to get started."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Introduction","sectionId":"introduction","id":1873,"text":"The Aurelia CLI is the official command line tool for Aurelia. It can be used to create new projects, scaffold components and to bundle your application for release. It is the best way to get started on a new Aurelia project."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Machine Setup","sectionId":"machine-setup","id":1874,"text":"The CLI itself has a couple of prerequisites that you must install first: Install Node.js version 4.x or above. For Webpack projects, install Node.js 8.9.0 or higher. You can download it here. Install a Git Client Here's a nice GUI client. Here's a standard client. Once you have the prerequisites installed, you can install the Aurelia CLI itself. From the command line, use npm to install the CLI globally: Info Always run commands from a Bash prompt. Depending on your environment, you may need to use sudo when executing npm global installs. Warning While creating a new project doesn't require NPM 3, front-end development, in general, requires a flat-package structure, which is not available with NPM versions prior to 3. It is recommended that you update to NPM 3, which will be able to manage this structural requirement. You can check your NPM version with npm -v. If you need to update, run npm install npm -g."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Creating A New Aurelia Project","sectionId":"creating-a-new-aurelia-project","id":1875,"text":"To create a new project, you can run au new. You will be presented with a number of options. If you aren't sure what you want, you can select one of the defaults. Otherwise, you can create a custom project. Simply follow the prompts. Once you've made your choice, the CLI will show you your selections and ask if you'd like to create the file structure. After that, you'll be asked if you would like to install your new project's dependencies. Once the dependencies are installed, your project is ready to go."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Running Your Aurelia App","sectionId":"running-your-aurelia-app","id":1876,"text":"From inside your project folder, simply execute au run. This will build your app, creating all bundles in the process. It will start a minimal web server and serve your application. If you would like to develop, with auto-refresh of the browser, simply specify the --watch flag like this: au run --watch. If you have chosen to use ASP.NET Core and Webpack, you will want to use the dotnet run command instead of au run."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Environments","sectionId":"environments","id":1877,"text":"The CLI build system understands that you might run your code in different environments. By default, you are set up with three: dev, stage and prod. You can use the --env flag to specify what environment you want to run under. For example: au run --env prod --watch. When you do a build the src/environment.js or src/environment.ts file will be overwritten by either the dev.js, stage.js or prod.js file from the aurelia_project/environments directory."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Building Your App","sectionId":"building-your-app","id":1878,"text":"Aurelia CLI apps always run in bundled mode, even during development. To build your app, simply run au build. You can also specify an environment to build for. For example: au build --env stage."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Generators","sectionId":"generators","id":1879,"text":"Executing au generate <resource> runs a generator to scaffold out typical Aurelia constructs. Options for resource are: element, attribute, value-converter, binding-behavior, task and generator. That's right...there's a generator generator so you can write your own. Ex. au generate element"},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Aurelia.json","sectionId":"aureliajson","id":1880,"text":"In the aurelia_project directory there is a file called aurelia.json. This file is a centralized file containing all settings you might need for your gulp tasks and configuration files. Since it's in a JSON format, it's easy to import from Node.js. The aurelia.json file is meant to be used by your tooling, not your application."},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"Webpack vs SystemJS vs RequireJS","sectionId":"webpack-vs-systemjs-vs-requirejs","id":1881,"text":"When creating a new project using the Aurelia CLI you are presented with a wizard to select a module loader, bundler, CSS preprocessor and more. But what's the difference between Webpack, the Aurelia CLI bundler (RequireJS and SystemJS)? Webpack is a bundler whereas SystemJS and RequireJS are module loaders. Since a bundle of files loads more quickly in the browser than individual files, the CLI will use its own internal bundler when you decide to use the SystemJS or RequireJS module loader. If you choose to use Webpack then you typically don't need a module loader. Webpack is a very powerful module bundler. Setting up Webpack from scratch could be a very daunting task though. Luckily the Aurelia CLI takes care of setting up a Webpack configuration for you, you just have to answer some questions when running the au new command. Since there is no module loader when you choose for Webpack, all modules that your application needs have to be bundled by Webpack. Sometimes you will need to help the bundler out by using PLATFORM.moduleName() calls for module references in your code. Webpack is growing in popularity and there is a wealth of loaders, plugins, and documentation available for it. SystemJS is a \"Dynamic ES module loader\". When you choose for SystemJS during au new you're also getting the Aurelia CLI Bundler. This is a powerful combination that bundles your application, but also allows you to load modules at runtime that are not in the bundle. SystemJS is actively being developed as it tries to stay in sync with the WhatWG Loader specification. RequireJS has been around for a long time. As opposed to SystemJS it is done and no large changes are made, which makes it a little bit more stable than SystemJS. With either module loader (RequireJS, SystemJS) you will be using the Aurelia CLI Bundler. Both SystemJS and RequireJS support loader plugins, such as text, json and svg. The bundle configuration is in the same format for both module loaders. If you're unsure what to choose then Webpack is a good choice. If you like type-safe programming languages, you'll want to go for Typescript. If not, go for Babel (ESNext). Please refer to the following websites for more information on Webpack, RequireJS and SystemJS. http://requirejs.org/ https://github.com/systemjs/systemjs/ https://webpack.github.io/"},{"articleName":"Basics","articleHref":"docs/cli/basics","sectionName":"What if I forget this stuff?","sectionId":"what-if-i-forget-this-stuff","id":1882,"text":"If you need your memory refreshed as to what the available options are, at any time you can execute au help. If you aren't sure what version of the CLI you are running, you can run au -v; "},{"articleName":"Tasks","articleHref":"docs/cli/tasks","sectionName":"Introduction","sectionId":"introduction","id":1883,"text":"The Aurelia CLI allows you to execute Gulp tasks, and a few gulp tasks are provided out of the box that get you started. For any new project you need a task to build, run and test the application, so the CLI provides these tasks for you. These tasks can be found in the aurelia_project/tasks directory. Gulp tasks in a CLI application are plain Gulp v4 tasks. Gulp v4 brings gulp.series and gulp.parallel which makes Gulp tasks easier and cleaner. Typescript is entirely supported to be used in Gulp tasks. As is ES2017. The language you use in Gulp tasks is equivalent to the language in your source code and is determined from the transpiler object in aurelia.json."},{"articleName":"Tasks","articleHref":"docs/cli/tasks","sectionName":"Task execution","sectionId":"task-execution","id":1884,"text":"A task can be executed with the au command. au build would execute the Gulp task that's exported from aurelia_project/tasks/build.js, and au test executes the task that's in aurelia_project/tasks/test.js. What's good to know is that the Aurelia CLI executes the task that's exported as default, which means that you can export multiple tasks: When you execute the above task using the au command, task1 will be executed."},{"articleName":"Tasks","articleHref":"docs/cli/tasks","sectionName":"Creating a new task","sectionId":"creating-a-new-task","id":1885,"text":"Cool thing about the task runner of the CLI is that you can create your own tasks as well, and run them using the au command. Just create a new .js or .ts file in the aurelia_project/tasks directory and export a function from that file."},{"articleName":"Tasks","articleHref":"docs/cli/tasks","sectionName":"Task metadata","sectionId":"task-metadata","id":1886,"text":"The au help command not only shows standard Aurelia CLI commands, it also lists tasks, but only those that have defined what we call \"task metadata\". This metadata can be found in a .json file that has the same name as a task. For example, the build.js task could have a build.json file with the following structure: Any task that has such json file, will show up in au help. It would display the description, any flag that is supported by the task and any parameters. If the type of a flag is not set to \"boolean\" then au help will display that the flag supports a value."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Introduction","sectionId":"introduction","id":1887,"text":"This part of the documentation is only relevant if you are using the Aurelia CLI Bundler. If you're using Webpack then the Webpack chapter is what you need."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"ASP.NET Core","sectionId":"aspnet-core","id":1888,"text":"If you would like to use ASP.NET Core, first begin by using Visual Studio to create your ASP.NET Core project. Select whatever options make the most sense based on your .NET project plans. After you have created the project, open a command line and change directory into your web project's project folder. This is the folder that contains the .xproj file. From within this folder, you can execute the following command au new --here which will setup Aurelia \"here\" inside this project folder. You will be prompted to choose the platform you want. Simply select \"ASP.NET Core\". Follow the prompts for the rest of the process, just like above. Info Since Aurelia-CLI should be in charge of building your client side code, make sure before running the new command from Aurelia-CLI you add <typescriptcompileblocked>true to your .xproj file inside the first <propertygroup> you find to stop Visual Studio from compiling the .ts files in your project. If you build your solution before doing this, Visual Studio will compile your .ts files breaking some of the Aurelia-CLI commands. When developing an ASP.NET Core application you will want to set the ASPNETCORE_ENVIRONMENT environment variable. Detailed instructions can be found on the Microsoft Docs."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Deploying Your App","sectionId":"deploying-your-app","id":1889,"text":"Run the following build command: Then copy the file index.html and the folder /scripts  to the main deployment folder on your server."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Unit Testing","sectionId":"unit-testing","id":1890,"text":"If you selected a project setup that includes unit tests, you can run your tests with au test. If you would like to adopt a tdd-based workflow, writing code and tests with continual test evaluation, you can use the --watch flag. For example: au test --watch."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Build Revisions","sectionId":"build-revisions","id":1891,"text":"To create builds with revision numbers, you must set rev to be true under the build options. This will cause a unique revision number to be added to the bundled files. For example: You are also able to set specific flags so that build revisions only take place while staging or in production. For example: Now, if you were to run au build --env prod, the output would contain build revisions, while au build --env dev would not. Setting the build revisions to only compile while in production can help the development process, since it keeps your workspace clean of various build revisions. Modifying The Index File In order for your index.html file to be updated to load up the correct revisioned bundle, you must ensure that the \"index\" property located in build/targets section is correctly pointing to the index.html (or starting page) for your project. For example:"},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Bundling Your Project","sectionId":"bundling-your-project","id":1892,"text":"By default, the Aurelia CLI creates two bundles, an app-bundle.js, and a vendor-bundle.js. An example of the default app-bundle.js looks like this: In this setup, we've named the bundle app-bundle.js, and have defined what's included by setting the source property to be an array of patterns that match to file paths (the patterns are using glob patterns, minimatch to be specific, to find files that match).Optionally, you can define an exclude list by setting the source property to be an object containing both an include and exclude array of patterns. This is helpful when you're trying to define multiple bundles from your source code."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Adding Client Libraries to Your Project","sectionId":"adding-client-libraries-to-your-project","id":1893,"text":"The CLI provides two commands to help you add 3rd party client libraries, au install <library> and au import <library>. The install command will download, install and add the library to the configuration file aurelia_project/aurelia.json. The import command will add a library that you've previously installed with npm to the configuration file. Finally, both commands will give you instructions on how to access the library from your code. Manual configuration Unfortunately, not all 3rd party libraries can be successfully configured automatically by the install and import commands. In order the remedy this by manual configuration, open the aurelia_project/aurelia.json file and scroll down to the build.bundles section. You'll need to add the library into one of your bundle's dependencies sections. Below is some guidance for how to manually configure several different common 3rd party library scenarios: A Single-File Module If the library you have installed is a single CommonJS or AMD file, you can add an entry similar to the following to the dependencies of your bundle: name - This is the name of the library as you will import it in your JavaScript or TypeScript code. path - This is a path to the single module file itself. This path is relative to your application's src folder. Also, you should not include the file extension. .js will be appended automatically. If the main field of the library's package.json points to the single file that you need to bundle, then you can opt for a simplified configuration by just adding the package name to your dependencies directly: A CommonJS Package Many modules installed through NPM are packages made up of multiple source files. Configuring a library like this is a bit different than the single-file scenario above. Here's an example configuration for a multi-file package: name - This is the name of the library as you will import it in your JavaScript or TypeScript code. path - This is a path to the folder where the package's source is located. This path is relative to your application's src folder. main - This is the main module (entry point) of the package, relative to the path. You should not include the file extension. .js will be appended automatically. Set main to false when the package does not have a main file. Info: Environment-Specific Dependencies We've also shown how to use the env setting on a dependency. This can be used on any dependency in the bundle to indicate what environment builds the dependency should be included in. By default, dependencies are included in all builds. The example above shows how to include the library only in builds targeting the \"dev\" environment. You can also specify multiple environments like dev & stage. A Legacy Library Libraries that predate module systems can be a pain because they often rely on global scripts which must be loaded before the library. These libraries also add their own global variables. An example of one such library is bootstrap. Let's take a look at how to handle a legacy library like that. name - This is the name of the library as you will import it in your JavaScript or TypeScript code. path - This is a path to the folder where the package's source is located. This path is relative to your application's src folder. main - This is the main module (entry point) of the package, relative to the path. You should not include the file extension. .js will be appended automatically.  Set main to false when the package does not have a main file. deps - This is an array of dependencies which must be loaded and available before the legacy library can be evaluated. exports - This is the name of the global variable that should be used as the exported value of the module. Notice first that we've included \"jquery\" as one of our dependencies, and specifically at the beginning of the dependency list.We are using the exports property to export the jQuery object since jQuery plugin, like Bootstrap, attach their APIs to the jQuery object itself.  (This could be any global variable, though.)  Finally, below that we configure bootstrap. The first three properties are the same as in our package example above. However, now we have a deps list. We've included jquery since Bootstrap needs it to be present before it can load. A Library with Additional Resources The Bootstrap example above results in the bundling of the JavaScript portions of the library. But, as you probably know, Bootstrap is mostly about CSS. The CSS files distributed with Bootstrap aren't traceable through the module system so this still doesn't result in the Bootstrap CSS being bundled. Here's how we solve that problem: Notice that we've added a resources array. Here we can provide a list of additional files to be included with the bundle. These files are relative to the path designated above and must include the file extension. You can also use glob patterns in place of exact file names. The final step to make Bootstrap work is to copy the necessary font files to the bootstrap/fonts folder, which by default is where Bootstrap will look for the font files. To do this, we should declare these files in the copyFiles property, after the bundles property. Now, the font files will be copied to the bootstrap/fonts folder when building the application. Info: Setup for copying files The copyFiles works as a 'from':'to' setup, where 'from' is the location of the file you want to copy, and 'to' is the destination folder. Both paths are relative to project folder. The sintax is: If you run the application providing the --watch flag, the files will be recopied when changed. Info Remember that CSS bundled in this way is bundled as a text resource designed to be required in your view. To load the Bootstrap css file in a view, use <require from=\"bootstrap/css/bootstrap.css\"></require>. Notice that the module name derives from combining the name property with the resource. A Very Stubborn Legacy Library Sometimes you can't get a library to work with the module loading system. That's ok. You can still include it in the bundle, using traditional concatenation techniques. In fact, this is how the CLI bundles up the loader and promise polyfills. These items don't go into the dependencies section but instead go into the prepend section. This is because they aren't module dependencies. They also aren't relative to the src, but relative to the project folder. Using the prepend section causes the scripts to be prepended to the beginning of the bundle, using normal script concatenation techniques. Here's a full vendor bundle example, showing this and the rest of the techniques listed above. You may want to prepend or append scripts based on the active environment. That's entirely possible through the following syntax: The above configuration would prepend the scripts/require.js file only for the stage and prod environments. A Very Stubborn Legacy Library With Plugins Some legacy libraries may support plugins which you also want included in your bundle. In some cases these plugins depend on a global object defined by the main library, so it is important that the plugins exist later in the bundle than the main library scripts. These plugins can go in the append section, which works exactly the same as the prepend section but the scripts are appended to the end of the bundle, after all other items.  Like the prepend section all items are relative to the project folder, not the src. A note on NPM The CLI treats scoped packages in the same way as unscoped ones, you just need to remember that the scope is always part of its name. So, for example, if you need to consume a scoped package in a CLI project, you need the following in your aurelia.json: Your imports must be scoped too: And this is an example of loading a @scope/packagename plugin during app startup: Reference packages outside of the node It is possible to use packages outside of the node_modules folder. The only difference is that you need to define what the packageRoot is. In aurelia.json, you can define a package that lives outside of the node_modules folder as follows: The packageRoot is the root folder of the package. This is often the folder which contains the package.json file of the package."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Configuring the Loader","sectionId":"configuring-the-loader","id":1894,"text":"You can configure the loader by adding a config key to build.loader with the options you want to add. For instance, if you want to increase the timeout for requirejs, you would do this: Setting the baseUrl Sometimes you may want to keep the scripts folder somewhere other than the default location, or move the index.html file a few folders up from the project root. In that case it is possible to set the baseUrl property so that the build system uses the correct paths and that bundles get loaded correctly in the browser. The baseUrl property should be set in both the platform object as well as the build.targets object: The script tag for the bundle in index.html file needs to point to the modified location of the scripts folder as well: <script src=\"some/dir/scripts/vendor-bundle.js\" data-main=\"aurelia-bootstrapper\"></script>"},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Styling your Application","sectionId":"styling-your-application","id":1895,"text":"There are many ways to style components in Aurelia. The CLI sets up your project to only process styles inside your application's src folder. Those styles can then be imported into a view using Aurelia's require element. If you aren't using any CSS preprocessor, you write css and then simply require it in the view like this: For projects that use a CSS preprocessor (chosen from the cli setup questions): Write your styles in the format you chose (styl, sass, less ...). Require the style by [filename].css instead of [filename].[extension]. This is because your style file is transpiled into a module that encodes the resulting css file extension. Bear in mind that you can always configure things any way you want by modifying the tasks in the aurelia_project/tasks folder. For styling purposes, you can modify the process-css.js file."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Updating A Single Library","sectionId":"updating-a-single-library","id":1896,"text":"To update a single library use the command npm install library-name where library-name is the library that you wish to update."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Updating Multiple Libraries","sectionId":"updating-multiple-libraries","id":1897,"text":"Add the following section to the project's package.json file List the libraries on a single line separated by a space. Include all of the libraries from the dependencies section of aurelia.json that you want to update. Use the command npm run au-update to update all of the libraries in the au-update list above."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Javascript Minification","sectionId":"javascript-minification","id":1898,"text":"The CLI will minify Javascript out of the box for the staging and production environments: These options can be found in the \"build\".\"options\" section of aurelia.json. If you wish to specify the options that are used in the minification process, then replace \"minify\": \"stage & prod\" with: The Aurelia-CLI uses UglifyJS2 for minification, so any option that UglifyJS2 supports is also supported by the Aurelia-CLI. With the above configuration, minification will occur for the stage and prod environments, but not for the dev environment. For the stage and prod environments, both the indent_level as well as the max-line-len option are passed to the minifier. The default key is optional, but allows you to reduce code duplication when multiple environments have similar options."},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Loader plugins","sectionId":"loader-plugins","id":1899,"text":"Since RequireJS and SystemJS support the notion of loader plugins, the Aurelia CLI allows you to use these in your application. The configuration of these plugins can be found in aurelia.json in the build.loader object: The plugins array is the collection of all loader plugins that your application needs. By default this is only the text plugin, but you can easily add others. The extensions array tells the Aurelia CLI Bundler for which files to use the plugin. That allows the bundler to bundle .html and .css files. The stub property is an interesting one. If it's set to true then the loader plugin won't be included into the bundle, and will result in the bundle being smaller. However, you're not able to use this loader plugin at runtime. So if you were to fetch HTML files using the html plugin, and those files aren't in the bundle, then that would not work as the loader would try to use the html plugin. When the stub property is set to true that plugin wouldn't be available and the loader would throw an error. A solution would be to set stub to false, but it's  better to include the files that you're trying to fetch in the bundle. Adding new plugins is usually a three step process. First you have to specify the plugin in the loader.plugins array.  Then you have to specify the loader plugin as a dependency in one of your bundle configurations. Sometimes the name of the loader plugin is not how you would like to use it. Then you could add an entry to the paths object in aurelia.json to specify a new name:"},{"articleName":"Aurelia-CLI Bundler","articleHref":"docs/cli/bundler","sectionName":"Path mappings","sectionId":"path-mappings","id":1900,"text":"Do you have import statements that look like import {Customer} from '../../../../models/customer'; ? Consider creating a path mapping for the models folder, so that you can do: import {Customer} from 'models/customer';. Here's how to do it. Open up aurelia.json and in the paths object do the following: That should make it work at runtime, but if you use Typescript it's going to tell you that it can't find models/customer. To fix that, open up tsconfig.json and in the compilerOptions add a paths and baseUrl property: You might have to restart your editor to see the effect of these changes. "},{"articleName":"Webpack","articleHref":"docs/cli/webpack","sectionName":"Introduction","sectionId":"introduction","id":1901,"text":"The Aurelia CLI fully supports Webpack. When you create a new project by running au new you can either choose for the Aurelia CLI bundler or you can choose for Webpack. The information in this document is specifically for people using the Webpack bundler. The Aurelia CLI will generate a webpack.config.js based on the technology that you select during au new. Like SASS more than LESS? Jest more than Karma? The Aurelia CLI can configure webpack.config.js just how you like it. The generated project makes use of the aurelia-webpack-plugin. As opposed to the Aurelia CLI Bundler, the bundle configuration is in the webpack.config.js, and not in aurelia.json. If you would like to learn more about Webpack, take a look at the following resources: https://www.pluralsight.com/courses/webpack-fundamentals https://blog.madewithenvy.com/getting-started-with-webpack-2-ed2b86c68783 https://webpack.js.org/configuration/ Info Webpack projects that are generated using the Aurelia-CLI require a relatively high version of Node.js (atleast v8.9.0). Some Webpack 4 plugins (such as mini-css-extract-plugin) need this in order to work correctly."},{"articleName":"Webpack","articleHref":"docs/cli/webpack","sectionName":"Running the application","sectionId":"running-the-application","id":1902,"text":"Info This section does not apply for JavascriptServices Running an Aurelia-CLI Webpack application is simple: au run --watch and you're on your way. But it's good to be aware of other flags that can be supplied to the au run command. au --help shows you all supported flags, but there are a couple that we would like to highlight. If you're interested in Hot Module Reload, you can use the --hmr flag (e.g. au run --watch --hmr) to launch in Hot Module Reload mode. Another cool one is au run --analyze which opens up the Webpack Bundler Analyzer, giving you a nice visualization of the bundle contents. Let's now take a look at the platform section in aurelia.json: Here you can find default settings for au run and au build. If you always run in Hot Module Reload mode, you can set hmr to true and you don't need to supply the --hmr flag any longer. Enabling the open option will cause the browser to navigate to the site after Webpack has finished bundling. The output option is used in the webpack.config.js file to determine where to output all the assets. If you're looking to change the default port that au run uses, you can change the port option in this section."},{"articleName":"Webpack","articleHref":"docs/cli/webpack","sectionName":"Deploying Your App","sectionId":"deploying-your-app","id":1903,"text":"When your application is done, the next step is to deploy it. First you will want to create a production build with au build --env prod. Depending on whether you use ASP.NET Core or not, the build output will end up in the dist folder or the wwwroot/dist folder. If you're not using ASP.NET core then everything you need to deploy can be found in the dist folder. Just copy this to the webserver and you'll be good to go. For ASP.NET Core however you'll want to do a production build (au build --env prod) and then deploy the ASP.NET Core application. Details can be found in the Microsoft Docs."},{"articleName":"Webpack","articleHref":"docs/cli/webpack","sectionName":"Build options","sectionId":"build-options","id":1904,"text":"When you look in the webpack.config.js you'll see that it exports a function: The configuration that's returned from the function is based on the parameters that get passed in. That means that you can have a different Webpack config for production and development, but you can also configure whether to extract any CSS. The build and run tasks passes in these parameters. Most of these settings are defined in the build.options object in aurelia.json: One is missing though: production. The environment (whether it's a production build or not) is determined from the --env flag. au build creates a development build, while au build --env prod creates production build."},{"articleName":"Webpack","articleHref":"docs/cli/webpack","sectionName":"Installing 3rd party dependencies","sectionId":"installing-3rd-party-dependencies","id":1905,"text":"Webpack is a powerful and smart bundler, which means that you often don't need to configure a 3rd party dependency.  And if you do then there's a good chance that someone has done it before, so Google is your friend here. Check out the Webpack documentation for more info on the webpack.config.js."},{"articleName":"Webpack","articleHref":"docs/cli/webpack","sectionName":"Unit Testing","sectionId":"unit-testing","id":1906,"text":"Depending on what you've selected during au new you will have the possibility to run one of the following test runners: Jest Karma Protractor Jest can be launched using au jest or au jest --watch if you would like to do continuously run tests. Similarly, Karma can be started using au karma or au karma --watch. However, Protractor is a bit different. It has to be started through nps, so make sure that you've installed that globally (npm install nps -g). Afterwards, run nps e2e to start Protractor."},{"articleName":"Webpack","articleHref":"docs/cli/webpack","sectionName":"ASP.NET Core","sectionId":"aspnet-core","id":1907,"text":"When developing an ASP.NET Core application you will want to set the ASPNETCORE_ENVIRONMENT environment variable. Detailed instructions can be found on the Microsoft Docs."},{"articleName":"Migrating","articleHref":"docs/cli/migrating","sectionName":"Aurelia-CLI Bundler to Webpack","sectionId":"aurelia-cli-bundler-to-webpack","id":1908,"text":"There are differences between the Aurelia CLI bundler and the Webpack bundler. When you are migrating an existing application from the integrated bundler to Webpack there are a few things to keep in mind. The recommended way to migrate is to create a new Webpack application using the CLI, choosing similar technology as the project that you want to migrate. Then you would copy over the source code (in the src folder by default) and the unit tests (in the test/unit folder). After that you will have to make some changes to the codebase, which are explained below. Webpack requires the use of PLATFORM.moduleName() for any module reference in the code, except for the import statements. PLATFORM can be imported using import {PLATFORM} from 'aurelia-pal';. A few examples: in main.js or main.ts do aurelia.setRoot(PLATFORM.moduleName('app')). for routes do { ...., name: 'users', moduleId: PLATFORM.moduleName('./users'), ... } @useView(PLATFORM.moduleName('my-view.html')) .resources(PLATFORM.moduleName('resources/index')) when Webpack cannot find a module even though it exists, you likely are missing a PLATFORM.moduleName for that module The Aurelia CLI bundler gets its bundle configuration from the aurelia_project/aurelia.json file. This is different for Webpack, where the bundle configuration is inside webpack.config.js. Webpack projects created by the CLI use Aurelia's Webpack Plugin, which you'll find in webpack.config.js. If you use SASS or LESS, then you are going to have to import the stylesheets differently. When you include stylesheets and use the Aurelia CLI bundler, then your <require> statements will have the .css extension: <require from=\"styles/my-stylesheet.css\"></require>. When you use Webpack you have to change this into the .sass or .less extension: <require from=\"styles/my-stylesheet.sass\"></require>."},{"articleName":"Updating","articleHref":"docs/cli/updating","sectionName":"Updating the Aurelia CLI","sectionId":"updating-the-aurelia-cli","id":1909,"text":"There are a few steps involved to update the Aurelia CLI to a newer version. In this chapter these steps will be explained. Good thing to know is that Aurelia CLI is actually installed twice, once globally and once locally. The globally installed Aurelia CLI (npm install aurelia-cli -g) can be found in your user profile and the local one lives inside the node_modules folder of your project. The global Aurelia CLI is used when you're not inside a project directory, for example when you create a new Aurelia CLI project using au new. Inside a project directory however, the local version of Aurelia CLI is used. That allows you to use different versions of the Aurelia CLI per project. Since the CLI is installed both globally and locally, you need to update both. First run npm install aurelia-cli@latest -g to update the CLI globally, and run npm install aurelia-cli@latest --save-dev from the project directory to update the local Aurelia CLI. We're continuously improving the project setup to make development better and easier. This sometimes involves updating Gulp tasks. So when you want to update an existing project, you'll want to update the Gulp tasks as well. The recommended way to do this is to update the CLI globally and create a new project using au new. Then you can copy over the tasks in the aurelia_project/tasks directory to your own project. Always check out the release notes on the Aurelia blog as they may contain additional instructions for updating the CLI."},{"articleName":"Recipes & Known Issues","articleHref":"docs/cli/recipes","sectionName":"Introduction","sectionId":"introduction","id":1910,"text":"In this section you can find examples of particular setups, known issues and possible workarounds"},{"articleName":"Recipes & Known Issues","articleHref":"docs/cli/recipes","sectionName":"Aurelia-CLI bundler + Docker","sectionId":"aurelia-cli-bundler-docker","id":1911,"text":"When using the Aurelia-CLI bundler together with Docker you might notice that the file watcher doesn't pick up changes that are made from the host. In order to resolve this you can open up the aurelia_project/tasks/watch.js (or watch.ts when using typescript) and modify the watchPath function to use polling: More information on this problem be found in this issue."},{"articleName":"Recipes & Known Issues","articleHref":"docs/cli/recipes","sectionName":"NPM uninstalling packages","sectionId":"npm-uninstalling-packages","id":1912,"text":"If you're on NPM 5.6.0 (npm -v) then you might experience strange behavior when you're trying to install a package (using npm install). This should be resolved with version 5.7.0 of NPM."},{"articleName":"Learn","articleHref":"learn","sectionName":"Training","sectionId":"training","id":1913,"text":"We've got an international web of certified trainers, core team members and official partners. If you need custom training, we can connect you with someone who can help put together on-site or virtual training to meet your needs. For more information, please email training@bluespire.com and we will do our best to accommodate you."},{"articleName":"Learn","articleHref":"learn","sectionName":"Books","sectionId":"books","id":1914,"text":"There are a number of books available to help you get started learning Modern JavaScript and Aurelia: Aurelia For Real World Web Applications by Dwayne Charrington Aurelia in Action by Sean Hunter Learning Aurelia by Manuel Guilbault Practical App Development with Aurelia by Matthew Duffield Aurelia Succinctly by Matthew Duffield Practical Aurelia by Behzad Abbasi"},{"articleName":"Learn","articleHref":"learn","sectionName":"Videos","sectionId":"videos","id":1915,"text":"If you are looking for online video courses to help you get started learning Modern JavaScript and Aurelia, there are several great options to choose from: Introduction to Aurelia Framework by Jon Bonso via Udemy Modern JavaScript Development by Rob Eisenberg via Vimeo on Demand Beginning Aurelia Development by Rob Eisenberg via Vimeo on Demand Intermediate Aurelia Development by Rob Eisenberg via Vimeo on Demand Aurelia Web Development - Part 1 by Raja Mani via Packt Aurelia Fundamentals by Bryan Noyes via Pluralsight Building Applications with Aurelia by K. Scott Allen via Pluralsight"},{"articleName":"Learn","articleHref":"learn","sectionName":"Aurelia University (coming soon)","sectionId":"aurelia-university-coming-soon","id":1916,"text":"Aurelia University is in-development official course from the Aurelia team designed to launch your career as an Aurelia engineer. Interested? Sign up for updates. "},{"articleName":"Support","articleHref":"support","sectionName":"Live Support","sectionId":"live-support","id":1917,"text":"Schedule your first call on us."},{"articleName":"Support","articleHref":"support","sectionName":"Guidance Tickets","sectionId":"guidance-tickets","id":1918,"text":"We want to know what you want to know."},{"articleName":"Support","articleHref":"support","sectionName":"Code Reviews","sectionId":"code-reviews","id":1919,"text":"Take your code to the next level."},{"articleName":"Support","articleHref":"support","sectionName":"Pricing","sectionId":"pricing","id":1920,"text":""},{"articleName":"Support","articleHref":"support","sectionName":"Consulting","sectionId":"consulting","id":1921,"text":"Our core team and partners are able to offer expert consulting on both large and small Aurelia applications. Whether you want to hire members of our team on a per-hour basis without any commitments or need to assemble a team to build out a full application, be confident in your success with the knowledge that your projects are being built by the experts. Have questions? Email consulting@aurelia.io with what you need. We would love to help you connect with talent who can make your project a success!"}]},"api":{"data":[{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"AccessKeyed","id":1},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"key","ownerKind":"Class","ownerName":"AccessKeyed","id":2},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"object","ownerKind":"Class","ownerName":"AccessKeyed","id":3},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"AccessKeyed","id":4},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"AccessKeyed","id":5},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"AccessKeyed","id":6},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"AccessKeyed","id":7},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"AccessMember","id":8},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"name","ownerKind":"Class","ownerName":"AccessMember","id":9},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"object","ownerKind":"Class","ownerName":"AccessMember","id":10},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"AccessMember","id":11},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"AccessMember","id":12},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"AccessMember","id":13},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"AccessMember","id":14},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"AccessScope","id":15},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"ancestor","ownerKind":"Class","ownerName":"AccessScope","id":16},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"name","ownerKind":"Class","ownerName":"AccessScope","id":17},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"AccessScope","id":18},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"AccessScope","id":19},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"AccessScope","id":20},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"AccessScope","id":21},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"Binary","id":22},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"left","ownerKind":"Class","ownerName":"Binary","id":23},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"operation","ownerKind":"Class","ownerName":"Binary","id":24},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"right","ownerKind":"Class","ownerName":"Binary","id":25},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"Binary","id":26},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"Binary","id":27},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"Binary","id":28},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"Binary","id":29},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"BindingBehavior","id":30},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"args","ownerKind":"Class","ownerName":"BindingBehavior","id":31},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"expression","ownerKind":"Class","ownerName":"BindingBehavior","id":32},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"name","ownerKind":"Class","ownerName":"BindingBehavior","id":33},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"BindingBehavior","id":34},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"BindingBehavior","id":35},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"BindingBehavior","id":36},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"BindingBehavior","id":37},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"BindingBehaviorResource","id":38},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"initialize","ownerKind":"Class","ownerName":"BindingBehaviorResource","id":39},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"BindingBehaviorResource","id":40},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"convention","ownerKind":"Class","ownerName":"BindingBehaviorResource","id":41},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"BindingEngine","id":42},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"collectionObserver","ownerKind":"Class","ownerName":"BindingEngine","id":43},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"createBindingExpression","ownerKind":"Class","ownerName":"BindingEngine","id":44},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"expressionObserver","ownerKind":"Class","ownerName":"BindingEngine","id":45},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"parseExpression","ownerKind":"Class","ownerName":"BindingEngine","id":46},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"propertyObserver","ownerKind":"Class","ownerName":"BindingEngine","id":47},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"registerAdapter","ownerKind":"Class","ownerName":"BindingEngine","id":48},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"CallMember","id":49},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"args","ownerKind":"Class","ownerName":"CallMember","id":50},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"name","ownerKind":"Class","ownerName":"CallMember","id":51},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"object","ownerKind":"Class","ownerName":"CallMember","id":52},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"CallMember","id":53},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"CallMember","id":54},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"CallMember","id":55},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"CallMember","id":56},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"CheckedObserver","id":57},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getValue","ownerKind":"Class","ownerName":"CheckedObserver","id":58},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"handleEvent","ownerKind":"Class","ownerName":"CheckedObserver","id":59},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"setValue","ownerKind":"Class","ownerName":"CheckedObserver","id":60},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"CheckedObserver","id":61},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Class","ownerName":"CheckedObserver","id":62},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"Conditional","id":63},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"condition","ownerKind":"Class","ownerName":"Conditional","id":64},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"no","ownerKind":"Class","ownerName":"Conditional","id":65},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"yes","ownerKind":"Class","ownerName":"Conditional","id":66},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"Conditional","id":67},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"Conditional","id":68},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"Conditional","id":69},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"Conditional","id":70},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"DataAttributeObserver","id":71},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getValue","ownerKind":"Class","ownerName":"DataAttributeObserver","id":72},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"setValue","ownerKind":"Class","ownerName":"DataAttributeObserver","id":73},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"DataAttributeObserver","id":74},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Class","ownerName":"DataAttributeObserver","id":75},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"DirtyCheckProperty","id":76},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getValue","ownerKind":"Class","ownerName":"DirtyCheckProperty","id":77},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"setValue","ownerKind":"Class","ownerName":"DirtyCheckProperty","id":78},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"DirtyCheckProperty","id":79},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Class","ownerName":"DirtyCheckProperty","id":80},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"EventManager","id":81},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"addEventListener","ownerKind":"Class","ownerName":"EventManager","id":82},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"registerElementConfig","ownerKind":"Class","ownerName":"EventManager","id":83},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"EventSubscriber","id":84},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"dispose","ownerKind":"Class","ownerName":"EventSubscriber","id":85},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"EventSubscriber","id":86},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"Expression","id":87},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"Expression","id":88},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"Expression","id":89},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"Expression","id":90},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"Expression","id":91},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"ExpressionCloner","id":92},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"LiteralPrimitive","id":93},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"value","ownerKind":"Class","ownerName":"LiteralPrimitive","id":94},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"LiteralPrimitive","id":95},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"LiteralPrimitive","id":96},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"LiteralPrimitive","id":97},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"LiteralPrimitive","id":98},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"LiteralString","id":99},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"value","ownerKind":"Class","ownerName":"LiteralString","id":100},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"LiteralString","id":101},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"LiteralString","id":102},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"LiteralString","id":103},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"LiteralString","id":104},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"LiteralTemplate","id":105},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"cooked","ownerKind":"Class","ownerName":"LiteralTemplate","id":106},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"expressions","ownerKind":"Class","ownerName":"LiteralTemplate","id":107},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"func","ownerKind":"Class","ownerName":"LiteralTemplate","id":108},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"LiteralTemplate","id":109},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"LiteralTemplate","id":110},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"LiteralTemplate","id":111},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"LiteralTemplate","id":112},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"ObserverLocator","id":113},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"addAdapter","ownerKind":"Class","ownerName":"ObserverLocator","id":114},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getArrayObserver","ownerKind":"Class","ownerName":"ObserverLocator","id":115},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getMapObserver","ownerKind":"Class","ownerName":"ObserverLocator","id":116},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getObserver","ownerKind":"Class","ownerName":"ObserverLocator","id":117},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"Parser","id":118},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"parse","ownerKind":"Class","ownerName":"Parser","id":119},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"SelectValueObserver","id":120},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getValue","ownerKind":"Class","ownerName":"SelectValueObserver","id":121},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"handleEvent","ownerKind":"Class","ownerName":"SelectValueObserver","id":122},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"setValue","ownerKind":"Class","ownerName":"SelectValueObserver","id":123},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"SelectValueObserver","id":124},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Class","ownerName":"SelectValueObserver","id":125},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"Unparser","id":126},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"ValueAttributeObserver","id":127},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getValue","ownerKind":"Class","ownerName":"ValueAttributeObserver","id":128},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"handleEvent","ownerKind":"Class","ownerName":"ValueAttributeObserver","id":129},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"setValue","ownerKind":"Class","ownerName":"ValueAttributeObserver","id":130},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"ValueAttributeObserver","id":131},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Class","ownerName":"ValueAttributeObserver","id":132},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"ValueConverter","id":133},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"allArgs","ownerKind":"Class","ownerName":"ValueConverter","id":134},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"args","ownerKind":"Class","ownerName":"ValueConverter","id":135},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"expression","ownerKind":"Class","ownerName":"ValueConverter","id":136},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"name","ownerKind":"Class","ownerName":"ValueConverter","id":137},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"accept","ownerKind":"Class","ownerName":"ValueConverter","id":138},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"assign","ownerKind":"Class","ownerName":"ValueConverter","id":139},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"ValueConverter","id":140},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"evaluate","ownerKind":"Class","ownerName":"ValueConverter","id":141},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Class","apiName":"ValueConverterResource","id":142},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"initialize","ownerKind":"Class","ownerName":"ValueConverterResource","id":143},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"ValueConverterResource","id":144},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"convention","ownerKind":"Class","ownerName":"ValueConverterResource","id":145},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"Binding","id":146},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"isBound","ownerKind":"Interface","ownerName":"Binding","id":147},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"mode","ownerKind":"Interface","ownerName":"Binding","id":148},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"source","ownerKind":"Interface","ownerName":"Binding","id":149},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"sourceExpression","ownerKind":"Interface","ownerName":"Binding","id":150},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"bind","ownerKind":"Interface","ownerName":"Binding","id":151},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"callSource","ownerKind":"Interface","ownerName":"Binding","id":152},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unbind","ownerKind":"Interface","ownerName":"Binding","id":153},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"updateSource","ownerKind":"Interface","ownerName":"Binding","id":154},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"updateTarget","ownerKind":"Interface","ownerName":"Binding","id":155},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"BindingExpression","id":156},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"createBinding","ownerKind":"Interface","ownerName":"BindingExpression","id":157},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"CallExpression","id":158},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"createBinding","ownerKind":"Interface","ownerName":"CallExpression","id":159},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"Callable","id":160},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"call","ownerKind":"Interface","ownerName":"Callable","id":161},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"CollectionObserver","id":162},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Interface","ownerName":"CollectionObserver","id":163},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"Disposable","id":164},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"dispose","ownerKind":"Interface","ownerName":"Disposable","id":165},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"ExpressionVisitor","id":166},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"ICollectionObserverSplice","id":167},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"addedCount","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":168},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"index","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":169},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"key","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":170},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"object","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":171},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"oldValue","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":172},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"removed","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":173},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"type","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":174},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"value","ownerKind":"Interface","ownerName":"ICollectionObserverSplice","id":175},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"InternalCollectionObserver","id":176},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Interface","ownerName":"InternalCollectionObserver","id":177},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Interface","ownerName":"InternalCollectionObserver","id":178},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"InternalPropertyObserver","id":179},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getValue","ownerKind":"Interface","ownerName":"InternalPropertyObserver","id":180},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"setValue","ownerKind":"Interface","ownerName":"InternalPropertyObserver","id":181},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Interface","ownerName":"InternalPropertyObserver","id":182},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Interface","ownerName":"InternalPropertyObserver","id":183},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"ListenerExpression","id":184},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"createBinding","ownerKind":"Interface","ownerName":"ListenerExpression","id":185},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"LookupFunctions","id":186},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"bindingBehaviors","ownerKind":"Interface","ownerName":"LookupFunctions","id":187},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"valueConverters","ownerKind":"Interface","ownerName":"LookupFunctions","id":188},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"NameExpression","id":189},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"createBinding","ownerKind":"Interface","ownerName":"NameExpression","id":190},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"ObjectObservationAdapter","id":191},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"getObserver","ownerKind":"Interface","ownerName":"ObjectObservationAdapter","id":192},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"OverrideContext","id":193},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"bindingContext","ownerKind":"Interface","ownerName":"OverrideContext","id":194},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"parentOverrideContext","ownerKind":"Interface","ownerName":"OverrideContext","id":195},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"PropertyObserver","id":196},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"subscribe","ownerKind":"Interface","ownerName":"PropertyObserver","id":197},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"SVGAnalyzer","id":198},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Method","apiName":"isStandardSvgAttribute","ownerKind":"Interface","ownerName":"SVGAnalyzer","id":199},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Interface","apiName":"Scope","id":200},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"bindingContext","ownerKind":"Interface","ownerName":"Scope","id":201},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Property","apiName":"overrideContext","ownerKind":"Interface","ownerName":"Scope","id":202},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Constant","apiName":"sourceContext","id":203},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Constant","apiName":"targetContext","id":204},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"bindingBehavior","id":205},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"camelCase","id":206},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"computedFrom","id":207},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"connectBindingToSignal","id":208},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"connectable","id":209},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"createOverrideContext","id":210},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"createScopeForTest","id":211},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"declarePropertyDependencies","id":212},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"enqueueBindingConnect","id":213},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"getChangeRecords","id":214},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"getContextFor","id":215},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"hasDeclaredDependencies","id":216},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"mergeSplice","id":217},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"observable","id":218},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"signalBindings","id":219},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"subscriberCollection","id":220},{"libraryName":"Binding","libraryHref":"docs/api/binding","apiKind":"Function","apiName":"valueConverter","id":221},{"libraryName":"Bootstrapper","libraryHref":"docs/api/bootstrapper","apiKind":"Constant","apiName":"starting","id":222},{"libraryName":"Bootstrapper","libraryHref":"docs/api/bootstrapper","apiKind":"Function","apiName":"bootstrap","id":223},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"All","id":224},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"All","id":225},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"of","ownerKind":"Class","ownerName":"All","id":226},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"Container","id":227},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"parent","ownerKind":"Class","ownerName":"Container","id":228},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"root","ownerKind":"Class","ownerName":"Container","id":229},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"instance","ownerKind":"Class","ownerName":"Container","id":230},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"_createInvocationHandler","ownerKind":"Class","ownerName":"Container","id":231},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"_get","ownerKind":"Class","ownerName":"Container","id":232},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"autoRegister","ownerKind":"Class","ownerName":"Container","id":233},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"autoRegisterAll","ownerKind":"Class","ownerName":"Container","id":234},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"createChild","ownerKind":"Class","ownerName":"Container","id":235},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"Container","id":236},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"getAll","ownerKind":"Class","ownerName":"Container","id":237},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"getResolver","ownerKind":"Class","ownerName":"Container","id":238},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"hasResolver","ownerKind":"Class","ownerName":"Container","id":239},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"invoke","ownerKind":"Class","ownerName":"Container","id":240},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"makeGlobal","ownerKind":"Class","ownerName":"Container","id":241},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerAlias","ownerKind":"Class","ownerName":"Container","id":242},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerHandler","ownerKind":"Class","ownerName":"Container","id":243},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerInstance","ownerKind":"Class","ownerName":"Container","id":244},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerResolver","ownerKind":"Class","ownerName":"Container","id":245},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerSingleton","ownerKind":"Class","ownerName":"Container","id":246},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerTransient","ownerKind":"Class","ownerName":"Container","id":247},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"setHandlerCreatedCallback","ownerKind":"Class","ownerName":"Container","id":248},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"unregister","ownerKind":"Class","ownerName":"Container","id":249},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"Factory","id":250},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"Factory","id":251},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"of","ownerKind":"Class","ownerName":"Factory","id":252},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"FactoryInvoker","id":253},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"instance","ownerKind":"Class","ownerName":"FactoryInvoker","id":254},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"invoke","ownerKind":"Class","ownerName":"FactoryInvoker","id":255},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"invokeWithDynamicDependencies","ownerKind":"Class","ownerName":"FactoryInvoker","id":256},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"InvocationHandler","id":257},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"dependencies","ownerKind":"Class","ownerName":"InvocationHandler","id":258},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"fn","ownerKind":"Class","ownerName":"InvocationHandler","id":259},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"invoker","ownerKind":"Class","ownerName":"InvocationHandler","id":260},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"invoke","ownerKind":"Class","ownerName":"InvocationHandler","id":261},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"Lazy","id":262},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"Lazy","id":263},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"of","ownerKind":"Class","ownerName":"Lazy","id":264},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"NewInstance","id":265},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"as","ownerKind":"Class","ownerName":"NewInstance","id":266},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"NewInstance","id":267},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"of","ownerKind":"Class","ownerName":"NewInstance","id":268},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"Optional","id":269},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"Optional","id":270},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"of","ownerKind":"Class","ownerName":"Optional","id":271},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"Parent","id":272},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"Parent","id":273},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"of","ownerKind":"Class","ownerName":"Parent","id":274},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"SingletonRegistration","id":275},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerResolver","ownerKind":"Class","ownerName":"SingletonRegistration","id":276},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"StrategyResolver","id":277},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"state","ownerKind":"Class","ownerName":"StrategyResolver","id":278},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"strategy","ownerKind":"Class","ownerName":"StrategyResolver","id":279},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"StrategyResolver","id":280},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Class","apiName":"TransientRegistration","id":281},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerResolver","ownerKind":"Class","ownerName":"TransientRegistration","id":282},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Interface","apiName":"ContainerConfiguration","id":283},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"handlers","ownerKind":"Interface","ownerName":"ContainerConfiguration","id":284},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Property","apiName":"onHandlerCreated","ownerKind":"Interface","ownerName":"ContainerConfiguration","id":285},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Interface","apiName":"Invoker","id":286},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"invoke","ownerKind":"Interface","ownerName":"Invoker","id":287},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"invokeWithDynamicDependencies","ownerKind":"Interface","ownerName":"Invoker","id":288},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Interface","apiName":"Registration","id":289},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"registerResolver","ownerKind":"Interface","ownerName":"Registration","id":290},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Interface","apiName":"Resolver","id":291},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Method","apiName":"get","ownerKind":"Interface","ownerName":"Resolver","id":292},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Constant","apiName":"_emptyParameters","id":293},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Constant","apiName":"resolver","id":294},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"all","id":295},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"autoinject","id":296},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"factory","id":297},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"getDecoratorDependencies","id":298},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"inject","id":299},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"invokeAsFactory","id":300},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"invoker","id":301},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"lazy","id":302},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"newInstance","id":303},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"optional","id":304},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"parent","id":305},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"registration","id":306},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"singleton","id":307},{"libraryName":"Dependency Injection","libraryHref":"docs/api/dependency-injection","apiKind":"Function","apiName":"transient","id":308},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Class","apiName":"EventAggregator","id":309},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Method","apiName":"publish","ownerKind":"Class","ownerName":"EventAggregator","id":310},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"EventAggregator","id":311},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Method","apiName":"subscribeOnce","ownerKind":"Class","ownerName":"EventAggregator","id":312},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Interface","apiName":"Subscription","id":313},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Method","apiName":"dispose","ownerKind":"Interface","ownerName":"Subscription","id":314},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Function","apiName":"configure","id":315},{"libraryName":"Event Aggregator","libraryHref":"docs/api/event-aggregator","apiKind":"Function","apiName":"includeEventsIn","id":316},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Class","apiName":"HttpClient","id":317},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"activeRequestCount","ownerKind":"Class","ownerName":"HttpClient","id":318},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"baseUrl","ownerKind":"Class","ownerName":"HttpClient","id":319},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"defaults","ownerKind":"Class","ownerName":"HttpClient","id":320},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"interceptors","ownerKind":"Class","ownerName":"HttpClient","id":321},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"isConfigured","ownerKind":"Class","ownerName":"HttpClient","id":322},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"isRequesting","ownerKind":"Class","ownerName":"HttpClient","id":323},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"buildRequest","ownerKind":"Class","ownerName":"HttpClient","id":324},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"configure","ownerKind":"Class","ownerName":"HttpClient","id":325},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"delete","ownerKind":"Class","ownerName":"HttpClient","id":326},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"fetch","ownerKind":"Class","ownerName":"HttpClient","id":327},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"HttpClient","id":328},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"patch","ownerKind":"Class","ownerName":"HttpClient","id":329},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"post","ownerKind":"Class","ownerName":"HttpClient","id":330},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"put","ownerKind":"Class","ownerName":"HttpClient","id":331},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Class","apiName":"HttpClientConfiguration","id":332},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"baseUrl","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":333},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"defaults","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":334},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"interceptors","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":335},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"rejectErrorResponses","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":336},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"useStandardConfiguration","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":337},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"withBaseUrl","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":338},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"withDefaults","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":339},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"withInterceptor","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":340},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"withRetry","ownerKind":"Class","ownerName":"HttpClientConfiguration","id":341},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Class","apiName":"RetryInterceptor","id":342},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"retryConfig","ownerKind":"Class","ownerName":"RetryInterceptor","id":343},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"request","ownerKind":"Class","ownerName":"RetryInterceptor","id":344},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"response","ownerKind":"Class","ownerName":"RetryInterceptor","id":345},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Method","apiName":"responseError","ownerKind":"Class","ownerName":"RetryInterceptor","id":346},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Interface","apiName":"Interceptor","id":347},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"request","ownerKind":"Interface","ownerName":"Interceptor","id":348},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"requestError","ownerKind":"Interface","ownerName":"Interceptor","id":349},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"response","ownerKind":"Interface","ownerName":"Interceptor","id":350},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"responseError","ownerKind":"Interface","ownerName":"Interceptor","id":351},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Interface","apiName":"RequestInit","id":352},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"body","ownerKind":"Interface","ownerName":"RequestInit","id":353},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"cache","ownerKind":"Interface","ownerName":"RequestInit","id":354},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"credentials","ownerKind":"Interface","ownerName":"RequestInit","id":355},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"headers","ownerKind":"Interface","ownerName":"RequestInit","id":356},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"integrity","ownerKind":"Interface","ownerName":"RequestInit","id":357},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"method","ownerKind":"Interface","ownerName":"RequestInit","id":358},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"mode","ownerKind":"Interface","ownerName":"RequestInit","id":359},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"redirect","ownerKind":"Interface","ownerName":"RequestInit","id":360},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"referrer","ownerKind":"Interface","ownerName":"RequestInit","id":361},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"signal","ownerKind":"Interface","ownerName":"RequestInit","id":362},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Interface","apiName":"RetryConfiguration","id":363},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"beforeRetry","ownerKind":"Interface","ownerName":"RetryConfiguration","id":364},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"doRetry","ownerKind":"Interface","ownerName":"RetryConfiguration","id":365},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"interval","ownerKind":"Interface","ownerName":"RetryConfiguration","id":366},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"maxRandomInterval","ownerKind":"Interface","ownerName":"RetryConfiguration","id":367},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"maxRetries","ownerKind":"Interface","ownerName":"RetryConfiguration","id":368},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"minRandomInterval","ownerKind":"Interface","ownerName":"RetryConfiguration","id":369},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Property","apiName":"strategy","ownerKind":"Interface","ownerName":"RetryConfiguration","id":370},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Constant","apiName":"retryStrategy","id":371},{"libraryName":"Fetch","libraryHref":"docs/api/fetch-client","apiKind":"Function","apiName":"json","id":372},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Class","apiName":"Aurelia","id":373},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"container","ownerKind":"Class","ownerName":"Aurelia","id":374},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"host","ownerKind":"Class","ownerName":"Aurelia","id":375},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"loader","ownerKind":"Class","ownerName":"Aurelia","id":376},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"resources","ownerKind":"Class","ownerName":"Aurelia","id":377},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"use","ownerKind":"Class","ownerName":"Aurelia","id":378},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"enhance","ownerKind":"Class","ownerName":"Aurelia","id":379},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"setRoot","ownerKind":"Class","ownerName":"Aurelia","id":380},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"start","ownerKind":"Class","ownerName":"Aurelia","id":381},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Class","apiName":"FrameworkConfiguration","id":382},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"aurelia","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":383},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"container","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":384},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"apply","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":385},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"basicConfiguration","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":386},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"defaultBindingLanguage","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":387},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"defaultResources","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":388},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"developmentLogging","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":389},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"eventAggregator","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":390},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"feature","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":391},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"globalName","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":392},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"globalResources","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":393},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"history","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":394},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"instance","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":395},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"plugin","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":396},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"postTask","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":397},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"preTask","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":398},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"router","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":399},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"singleton","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":400},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"standardConfiguration","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":401},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Method","apiName":"transient","ownerKind":"Class","ownerName":"FrameworkConfiguration","id":402},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Interface","apiName":"FrameworkPluginInfo","id":403},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"config","ownerKind":"Interface","ownerName":"FrameworkPluginInfo","id":404},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"configure","ownerKind":"Interface","ownerName":"FrameworkPluginInfo","id":405},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"moduleId","ownerKind":"Interface","ownerName":"FrameworkPluginInfo","id":406},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Property","apiName":"resourcesRelativeTo","ownerKind":"Interface","ownerName":"FrameworkPluginInfo","id":407},{"libraryName":"Framework","libraryHref":"docs/api/framework","apiKind":"Constant","apiName":"LogManager","id":408},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Class","apiName":"History","id":409},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"activate","ownerKind":"Class","ownerName":"History","id":410},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"deactivate","ownerKind":"Class","ownerName":"History","id":411},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"getAbsoluteRoot","ownerKind":"Class","ownerName":"History","id":412},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"getState","ownerKind":"Class","ownerName":"History","id":413},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"navigate","ownerKind":"Class","ownerName":"History","id":414},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"navigateBack","ownerKind":"Class","ownerName":"History","id":415},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"setState","ownerKind":"Class","ownerName":"History","id":416},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Method","apiName":"setTitle","ownerKind":"Class","ownerName":"History","id":417},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Interface","apiName":"NavigationOptions","id":418},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Property","apiName":"replace","ownerKind":"Interface","ownerName":"NavigationOptions","id":419},{"libraryName":"History","libraryHref":"docs/api/history","apiKind":"Property","apiName":"trigger","ownerKind":"Interface","ownerName":"NavigationOptions","id":420},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Class","apiName":"BrowserHistory","id":421},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Property","apiName":"inject","ownerKind":"Class","ownerName":"BrowserHistory","id":422},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"activate","ownerKind":"Class","ownerName":"BrowserHistory","id":423},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"deactivate","ownerKind":"Class","ownerName":"BrowserHistory","id":424},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"getAbsoluteRoot","ownerKind":"Class","ownerName":"BrowserHistory","id":425},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"getState","ownerKind":"Class","ownerName":"BrowserHistory","id":426},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"navigate","ownerKind":"Class","ownerName":"BrowserHistory","id":427},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"navigateBack","ownerKind":"Class","ownerName":"BrowserHistory","id":428},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"setState","ownerKind":"Class","ownerName":"BrowserHistory","id":429},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"setTitle","ownerKind":"Class","ownerName":"BrowserHistory","id":430},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Class","apiName":"DefaultLinkHandler","id":431},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"activate","ownerKind":"Class","ownerName":"DefaultLinkHandler","id":432},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"deactivate","ownerKind":"Class","ownerName":"DefaultLinkHandler","id":433},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"findClosestAnchor","ownerKind":"Class","ownerName":"DefaultLinkHandler","id":434},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"getEventInfo","ownerKind":"Class","ownerName":"DefaultLinkHandler","id":435},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"targetIsThisWindow","ownerKind":"Class","ownerName":"DefaultLinkHandler","id":436},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Class","apiName":"LinkHandler","id":437},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"activate","ownerKind":"Class","ownerName":"LinkHandler","id":438},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Method","apiName":"deactivate","ownerKind":"Class","ownerName":"LinkHandler","id":439},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Interface","apiName":"AnchorEventInfo","id":440},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Property","apiName":"anchor","ownerKind":"Interface","ownerName":"AnchorEventInfo","id":441},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Property","apiName":"href","ownerKind":"Interface","ownerName":"AnchorEventInfo","id":442},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Property","apiName":"shouldHandleEvent","ownerKind":"Interface","ownerName":"AnchorEventInfo","id":443},{"libraryName":"History-Browser","libraryHref":"docs/api/history-browser","apiKind":"Function","apiName":"configure","id":444},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"Backend","id":445},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"loader","ownerKind":"Class","ownerName":"Backend","id":446},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"create","ownerKind":"Class","ownerName":"Backend","id":447},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"init","ownerKind":"Class","ownerName":"Backend","id":448},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"loadUrl","ownerKind":"Class","ownerName":"Backend","id":449},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"read","ownerKind":"Class","ownerName":"Backend","id":450},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"readMulti","ownerKind":"Class","ownerName":"Backend","id":451},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"with","ownerKind":"Class","ownerName":"Backend","id":452},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"BaseI18N","id":453},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"attached","ownerKind":"Class","ownerName":"BaseI18N","id":454},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"detached","ownerKind":"Class","ownerName":"BaseI18N","id":455},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"BaseI18N","id":456},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"DfBindingBehavior","id":457},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"DfBindingBehavior","id":458},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"DfBindingBehavior","id":459},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"DfBindingBehavior","id":460},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"DfValueConverter","id":461},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"toView","ownerKind":"Class","ownerName":"DfValueConverter","id":462},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"DfValueConverter","id":463},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"I18N","id":464},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"ea","ownerKind":"Class","ownerName":"I18N","id":465},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"globalVars","ownerKind":"Class","ownerName":"I18N","id":466},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"i18next","ownerKind":"Class","ownerName":"I18N","id":467},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"i18nextDefered","ownerKind":"Class","ownerName":"I18N","id":468},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"params","ownerKind":"Class","ownerName":"I18N","id":469},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"inject","ownerKind":"Class","ownerName":"I18N","id":470},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"df","ownerKind":"Class","ownerName":"I18N","id":471},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"getLocale","ownerKind":"Class","ownerName":"I18N","id":472},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"i18nextReady","ownerKind":"Class","ownerName":"I18N","id":473},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"nf","ownerKind":"Class","ownerName":"I18N","id":474},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"registerGlobalVariable","ownerKind":"Class","ownerName":"I18N","id":475},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"setLocale","ownerKind":"Class","ownerName":"I18N","id":476},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"setup","ownerKind":"Class","ownerName":"I18N","id":477},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"tr","ownerKind":"Class","ownerName":"I18N","id":478},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"uf","ownerKind":"Class","ownerName":"I18N","id":479},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"unregisterGlobalVariable","ownerKind":"Class","ownerName":"I18N","id":480},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"updateTranslations","ownerKind":"Class","ownerName":"I18N","id":481},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"updateValue","ownerKind":"Class","ownerName":"I18N","id":482},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"LazyOptional","id":483},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"LazyOptional","id":484},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"of","ownerKind":"Class","ownerName":"LazyOptional","id":485},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"NfBindingBehavior","id":486},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"NfBindingBehavior","id":487},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"NfBindingBehavior","id":488},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"NfBindingBehavior","id":489},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"NfValueConverter","id":490},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"toView","ownerKind":"Class","ownerName":"NfValueConverter","id":491},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"NfValueConverter","id":492},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"RelativeTime","id":493},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"addTranslationResource","ownerKind":"Class","ownerName":"RelativeTime","id":494},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"getRelativeTime","ownerKind":"Class","ownerName":"RelativeTime","id":495},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"getTimeDiffDescription","ownerKind":"Class","ownerName":"RelativeTime","id":496},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"setup","ownerKind":"Class","ownerName":"RelativeTime","id":497},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"RelativeTime","id":498},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"RtBindingBehavior","id":499},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"RtBindingBehavior","id":500},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"RtBindingBehavior","id":501},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"RtBindingBehavior","id":502},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"RtValueConverter","id":503},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"toView","ownerKind":"Class","ownerName":"RtValueConverter","id":504},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"RtValueConverter","id":505},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"TBindingBehavior","id":506},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"inject","ownerKind":"Class","ownerName":"TBindingBehavior","id":507},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"TBindingBehavior","id":508},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"TBindingBehavior","id":509},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"TCustomAttribute","id":510},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"TCustomAttribute","id":511},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"paramsChanged","ownerKind":"Class","ownerName":"TCustomAttribute","id":512},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"TCustomAttribute","id":513},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"valueChanged","ownerKind":"Class","ownerName":"TCustomAttribute","id":514},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"configureAliases","ownerKind":"Class","ownerName":"TCustomAttribute","id":515},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"TCustomAttribute","id":516},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"TParamsCustomAttribute","id":517},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Property","apiName":"service","ownerKind":"Class","ownerName":"TParamsCustomAttribute","id":518},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"valueChanged","ownerKind":"Class","ownerName":"TParamsCustomAttribute","id":519},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"configureAliases","ownerKind":"Class","ownerName":"TParamsCustomAttribute","id":520},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"TParamsCustomAttribute","id":521},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Class","apiName":"TValueConverter","id":522},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"toView","ownerKind":"Class","ownerName":"TValueConverter","id":523},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"TValueConverter","id":524},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Constant","apiName":"assignObjectToKeys","id":525},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Constant","apiName":"extend","id":526},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Constant","apiName":"isInteger","id":527},{"libraryName":"I18N","libraryHref":"docs/api/i18n","apiKind":"Constant","apiName":"translations","id":528},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Class","apiName":"Loader","id":529},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"addPlugin","ownerKind":"Class","ownerName":"Loader","id":530},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"applyPluginToUrl","ownerKind":"Class","ownerName":"Loader","id":531},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"getOrCreateTemplateRegistryEntry","ownerKind":"Class","ownerName":"Loader","id":532},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"loadAllModules","ownerKind":"Class","ownerName":"Loader","id":533},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"loadModule","ownerKind":"Class","ownerName":"Loader","id":534},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"loadTemplate","ownerKind":"Class","ownerName":"Loader","id":535},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"loadText","ownerKind":"Class","ownerName":"Loader","id":536},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"map","ownerKind":"Class","ownerName":"Loader","id":537},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"normalize","ownerKind":"Class","ownerName":"Loader","id":538},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"normalizeSync","ownerKind":"Class","ownerName":"Loader","id":539},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Class","apiName":"TemplateDependency","id":540},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"name","ownerKind":"Class","ownerName":"TemplateDependency","id":541},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"src","ownerKind":"Class","ownerName":"TemplateDependency","id":542},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Class","apiName":"TemplateRegistryEntry","id":543},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"address","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":544},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"dependencies","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":545},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"factory","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":546},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"factoryIsReady","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":547},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"resources","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":548},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"template","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":549},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Property","apiName":"templateIsLoaded","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":550},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"addDependency","ownerKind":"Class","ownerName":"TemplateRegistryEntry","id":551},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Interface","apiName":"LoaderPlugin","id":552},{"libraryName":"Loader","libraryHref":"docs/api/loader","apiKind":"Method","apiName":"fetch","ownerKind":"Interface","ownerName":"LoaderPlugin","id":553},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Class","apiName":"DefaultLoader","id":554},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Property","apiName":"textPluginName","ownerKind":"Class","ownerName":"DefaultLoader","id":555},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"addPlugin","ownerKind":"Class","ownerName":"DefaultLoader","id":556},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"applyPluginToUrl","ownerKind":"Class","ownerName":"DefaultLoader","id":557},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"getOrCreateTemplateRegistryEntry","ownerKind":"Class","ownerName":"DefaultLoader","id":558},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"loadAllModules","ownerKind":"Class","ownerName":"DefaultLoader","id":559},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"loadModule","ownerKind":"Class","ownerName":"DefaultLoader","id":560},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"loadTemplate","ownerKind":"Class","ownerName":"DefaultLoader","id":561},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"loadText","ownerKind":"Class","ownerName":"DefaultLoader","id":562},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"map","ownerKind":"Class","ownerName":"DefaultLoader","id":563},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"normalize","ownerKind":"Class","ownerName":"DefaultLoader","id":564},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"normalizeSync","ownerKind":"Class","ownerName":"DefaultLoader","id":565},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"useTemplateLoader","ownerKind":"Class","ownerName":"DefaultLoader","id":566},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Class","apiName":"TextTemplateLoader","id":567},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"loadTemplate","ownerKind":"Class","ownerName":"TextTemplateLoader","id":568},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Interface","apiName":"TemplateLoader","id":569},{"libraryName":"Loader-Default","libraryHref":"docs/api/loader-default","apiKind":"Method","apiName":"loadTemplate","ownerKind":"Interface","ownerName":"TemplateLoader","id":570},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Class","apiName":"Logger","id":571},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Property","apiName":"id","ownerKind":"Class","ownerName":"Logger","id":572},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Property","apiName":"level","ownerKind":"Class","ownerName":"Logger","id":573},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"debug","ownerKind":"Class","ownerName":"Logger","id":574},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"error","ownerKind":"Class","ownerName":"Logger","id":575},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"info","ownerKind":"Class","ownerName":"Logger","id":576},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"isDebugEnabled","ownerKind":"Class","ownerName":"Logger","id":577},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"setLevel","ownerKind":"Class","ownerName":"Logger","id":578},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"warn","ownerKind":"Class","ownerName":"Logger","id":579},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Interface","apiName":"Appender","id":580},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"debug","ownerKind":"Interface","ownerName":"Appender","id":581},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"error","ownerKind":"Interface","ownerName":"Appender","id":582},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"info","ownerKind":"Interface","ownerName":"Appender","id":583},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Method","apiName":"warn","ownerKind":"Interface","ownerName":"Appender","id":584},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Interface","apiName":"LogLevel","id":585},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Property","apiName":"debug","ownerKind":"Interface","ownerName":"LogLevel","id":586},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Property","apiName":"error","ownerKind":"Interface","ownerName":"LogLevel","id":587},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Property","apiName":"info","ownerKind":"Interface","ownerName":"LogLevel","id":588},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Property","apiName":"none","ownerKind":"Interface","ownerName":"LogLevel","id":589},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Property","apiName":"warn","ownerKind":"Interface","ownerName":"LogLevel","id":590},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Constant","apiName":"logLevel","id":591},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"addAppender","id":592},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"addCustomLevel","id":593},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"clearAppenders","id":594},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"getAppenders","id":595},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"getLevel","id":596},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"getLogger","id":597},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"removeAppender","id":598},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"removeCustomLevel","id":599},{"libraryName":"Logging","libraryHref":"docs/api/logging","apiKind":"Function","apiName":"setLevel","id":600},{"libraryName":"Logging-Console","libraryHref":"docs/api/logging-console","apiKind":"Class","apiName":"ConsoleAppender","id":601},{"libraryName":"Logging-Console","libraryHref":"docs/api/logging-console","apiKind":"Method","apiName":"debug","ownerKind":"Class","ownerName":"ConsoleAppender","id":602},{"libraryName":"Logging-Console","libraryHref":"docs/api/logging-console","apiKind":"Method","apiName":"error","ownerKind":"Class","ownerName":"ConsoleAppender","id":603},{"libraryName":"Logging-Console","libraryHref":"docs/api/logging-console","apiKind":"Method","apiName":"info","ownerKind":"Class","ownerName":"ConsoleAppender","id":604},{"libraryName":"Logging-Console","libraryHref":"docs/api/logging-console","apiKind":"Method","apiName":"warn","ownerKind":"Class","ownerName":"ConsoleAppender","id":605},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Class","apiName":"Origin","id":606},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"moduleId","ownerKind":"Class","ownerName":"Origin","id":607},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"moduleMember","ownerKind":"Class","ownerName":"Origin","id":608},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"Origin","id":609},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Method","apiName":"set","ownerKind":"Class","ownerName":"Origin","id":610},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Interface","apiName":"DecoratorApplicator","id":611},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Method","apiName":"on","ownerKind":"Interface","ownerName":"DecoratorApplicator","id":612},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Interface","apiName":"DeprecatedOptions","id":613},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"error","ownerKind":"Interface","ownerName":"DeprecatedOptions","id":614},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"message","ownerKind":"Interface","ownerName":"DeprecatedOptions","id":615},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Interface","apiName":"MetadataType","id":616},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"paramTypes","ownerKind":"Interface","ownerName":"MetadataType","id":617},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"properties","ownerKind":"Interface","ownerName":"MetadataType","id":618},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"propertyType","ownerKind":"Interface","ownerName":"MetadataType","id":619},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"resource","ownerKind":"Interface","ownerName":"MetadataType","id":620},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Method","apiName":"define","ownerKind":"Interface","ownerName":"MetadataType","id":621},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Method","apiName":"get","ownerKind":"Interface","ownerName":"MetadataType","id":622},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Method","apiName":"getOrCreateOwn","ownerKind":"Interface","ownerName":"MetadataType","id":623},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Method","apiName":"getOwn","ownerKind":"Interface","ownerName":"MetadataType","id":624},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Interface","apiName":"ProtocolOptions","id":625},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"compose","ownerKind":"Interface","ownerName":"ProtocolOptions","id":626},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Property","apiName":"validate","ownerKind":"Interface","ownerName":"ProtocolOptions","id":627},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Constant","apiName":"metadata","id":628},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Function","apiName":"decorators","id":629},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Function","apiName":"deprecated","id":630},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Function","apiName":"mixin","id":631},{"libraryName":"Metadata","libraryHref":"docs/api/metadata","apiKind":"Function","apiName":"protocol","id":632},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Interface","apiName":"Dom","id":633},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"Element","ownerKind":"Interface","ownerName":"Dom","id":634},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"NodeList","ownerKind":"Interface","ownerName":"Dom","id":635},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"SVGElement","ownerKind":"Interface","ownerName":"Dom","id":636},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"activeElement","ownerKind":"Interface","ownerName":"Dom","id":637},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"boundary","ownerKind":"Interface","ownerName":"Dom","id":638},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"title","ownerKind":"Interface","ownerName":"Dom","id":639},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"addEventListener","ownerKind":"Interface","ownerName":"Dom","id":640},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"adoptNode","ownerKind":"Interface","ownerName":"Dom","id":641},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"appendNode","ownerKind":"Interface","ownerName":"Dom","id":642},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createAttribute","ownerKind":"Interface","ownerName":"Dom","id":643},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createComment","ownerKind":"Interface","ownerName":"Dom","id":644},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createCustomEvent","ownerKind":"Interface","ownerName":"Dom","id":645},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createDocumentFragment","ownerKind":"Interface","ownerName":"Dom","id":646},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createElement","ownerKind":"Interface","ownerName":"Dom","id":647},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createMutationObserver","ownerKind":"Interface","ownerName":"Dom","id":648},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createTemplateElement","ownerKind":"Interface","ownerName":"Dom","id":649},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createTemplateFromMarkup","ownerKind":"Interface","ownerName":"Dom","id":650},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"createTextNode","ownerKind":"Interface","ownerName":"Dom","id":651},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"dispatchEvent","ownerKind":"Interface","ownerName":"Dom","id":652},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"getComputedStyle","ownerKind":"Interface","ownerName":"Dom","id":653},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"getElementById","ownerKind":"Interface","ownerName":"Dom","id":654},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"injectStyles","ownerKind":"Interface","ownerName":"Dom","id":655},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"nextElementSibling","ownerKind":"Interface","ownerName":"Dom","id":656},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"querySelector","ownerKind":"Interface","ownerName":"Dom","id":657},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"querySelectorAll","ownerKind":"Interface","ownerName":"Dom","id":658},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"removeEventListener","ownerKind":"Interface","ownerName":"Dom","id":659},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"removeNode","ownerKind":"Interface","ownerName":"Dom","id":660},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"replaceNode","ownerKind":"Interface","ownerName":"Dom","id":661},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Interface","apiName":"Feature","id":662},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"htmlTemplateElement","ownerKind":"Interface","ownerName":"Feature","id":663},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"mutationObserver","ownerKind":"Interface","ownerName":"Feature","id":664},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"scopedCSS","ownerKind":"Interface","ownerName":"Feature","id":665},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"shadowDOM","ownerKind":"Interface","ownerName":"Feature","id":666},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Interface","apiName":"ModuleNameOptions","id":667},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"chunk","ownerKind":"Interface","ownerName":"ModuleNameOptions","id":668},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"exports","ownerKind":"Interface","ownerName":"ModuleNameOptions","id":669},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Interface","apiName":"Performance","id":670},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"clearMarks","ownerKind":"Interface","ownerName":"Performance","id":671},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"clearMeasures","ownerKind":"Interface","ownerName":"Performance","id":672},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"getEntriesByName","ownerKind":"Interface","ownerName":"Performance","id":673},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"getEntriesByType","ownerKind":"Interface","ownerName":"Performance","id":674},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"mark","ownerKind":"Interface","ownerName":"Performance","id":675},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"measure","ownerKind":"Interface","ownerName":"Performance","id":676},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"now","ownerKind":"Interface","ownerName":"Performance","id":677},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Interface","apiName":"Platform","id":678},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"Loader","ownerKind":"Interface","ownerName":"Platform","id":679},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"XMLHttpRequest","ownerKind":"Interface","ownerName":"Platform","id":680},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"global","ownerKind":"Interface","ownerName":"Platform","id":681},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"history","ownerKind":"Interface","ownerName":"Platform","id":682},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"location","ownerKind":"Interface","ownerName":"Platform","id":683},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"noop","ownerKind":"Interface","ownerName":"Platform","id":684},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Property","apiName":"performance","ownerKind":"Interface","ownerName":"Platform","id":685},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"addEventListener","ownerKind":"Interface","ownerName":"Platform","id":686},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"eachModule","ownerKind":"Interface","ownerName":"Platform","id":687},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"moduleName","ownerKind":"Interface","ownerName":"Platform","id":688},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"removeEventListener","ownerKind":"Interface","ownerName":"Platform","id":689},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Method","apiName":"requestAnimationFrame","ownerKind":"Interface","ownerName":"Platform","id":690},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Constant","apiName":"DOM","id":691},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Constant","apiName":"FEATURE","id":692},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Constant","apiName":"PLATFORM","id":693},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Constant","apiName":"isInitialized","id":694},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Function","apiName":"AggregateError","id":695},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Function","apiName":"initializePAL","id":696},{"libraryName":"Platform Abstraction Layer (PAL)","libraryHref":"docs/api/pal","apiKind":"Function","apiName":"reset","id":697},{"libraryName":"PAL-Browser","libraryHref":"docs/api/pal-browser","apiKind":"Function","apiName":"initialize","id":698},{"libraryName":"Path","libraryHref":"docs/api/path","apiKind":"Function","apiName":"buildQueryString","id":699},{"libraryName":"Path","libraryHref":"docs/api/path","apiKind":"Function","apiName":"join","id":700},{"libraryName":"Path","libraryHref":"docs/api/path","apiKind":"Function","apiName":"parseQueryString","id":701},{"libraryName":"Path","libraryHref":"docs/api/path","apiKind":"Function","apiName":"relativeToFile","id":702},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Class","apiName":"DynamicSegment","id":703},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"eachChar","ownerKind":"Class","ownerName":"DynamicSegment","id":704},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"generate","ownerKind":"Class","ownerName":"DynamicSegment","id":705},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"regex","ownerKind":"Class","ownerName":"DynamicSegment","id":706},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Class","apiName":"EpsilonSegment","id":707},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"eachChar","ownerKind":"Class","ownerName":"EpsilonSegment","id":708},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"generate","ownerKind":"Class","ownerName":"EpsilonSegment","id":709},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"regex","ownerKind":"Class","ownerName":"EpsilonSegment","id":710},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Class","apiName":"RouteRecognizer","id":711},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"add","ownerKind":"Class","ownerName":"RouteRecognizer","id":712},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"generate","ownerKind":"Class","ownerName":"RouteRecognizer","id":713},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"handlersFor","ownerKind":"Class","ownerName":"RouteRecognizer","id":714},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"hasRoute","ownerKind":"Class","ownerName":"RouteRecognizer","id":715},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"recognize","ownerKind":"Class","ownerName":"RouteRecognizer","id":716},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Class","apiName":"StarSegment","id":717},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"eachChar","ownerKind":"Class","ownerName":"StarSegment","id":718},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"generate","ownerKind":"Class","ownerName":"StarSegment","id":719},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"regex","ownerKind":"Class","ownerName":"StarSegment","id":720},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Class","apiName":"State","id":721},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"get","ownerKind":"Class","ownerName":"State","id":722},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"match","ownerKind":"Class","ownerName":"State","id":723},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"put","ownerKind":"Class","ownerName":"State","id":724},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Class","apiName":"StaticSegment","id":725},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"eachChar","ownerKind":"Class","ownerName":"StaticSegment","id":726},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"generate","ownerKind":"Class","ownerName":"StaticSegment","id":727},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Method","apiName":"regex","ownerKind":"Class","ownerName":"StaticSegment","id":728},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Interface","apiName":"CharSpec","id":729},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"invalidChars","ownerKind":"Interface","ownerName":"CharSpec","id":730},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"repeat","ownerKind":"Interface","ownerName":"CharSpec","id":731},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"validChars","ownerKind":"Interface","ownerName":"CharSpec","id":732},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Interface","apiName":"ConfigurableRoute","id":733},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"caseSensitive","ownerKind":"Interface","ownerName":"ConfigurableRoute","id":734},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"handler","ownerKind":"Interface","ownerName":"ConfigurableRoute","id":735},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"path","ownerKind":"Interface","ownerName":"ConfigurableRoute","id":736},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Interface","apiName":"HandlerEntry","id":737},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"handler","ownerKind":"Interface","ownerName":"HandlerEntry","id":738},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"names","ownerKind":"Interface","ownerName":"HandlerEntry","id":739},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Interface","apiName":"RecognizedRoute","id":740},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"handler","ownerKind":"Interface","ownerName":"RecognizedRoute","id":741},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"isDynamic","ownerKind":"Interface","ownerName":"RecognizedRoute","id":742},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"params","ownerKind":"Interface","ownerName":"RecognizedRoute","id":743},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Interface","apiName":"RouteHandler","id":744},{"libraryName":"Route Recognizer","libraryHref":"docs/api/route-recognizer","apiKind":"Property","apiName":"name","ownerKind":"Interface","ownerName":"RouteHandler","id":745},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"ActivateNextStep","id":746},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"ActivateNextStep","id":747},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"AppRouter","id":748},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"baseUrl","ownerKind":"Class","ownerName":"AppRouter","id":749},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"container","ownerKind":"Class","ownerName":"AppRouter","id":750},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"currentInstruction","ownerKind":"Class","ownerName":"AppRouter","id":751},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"currentNavigationTracker","ownerKind":"Class","ownerName":"AppRouter","id":752},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"history","ownerKind":"Class","ownerName":"AppRouter","id":753},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isConfigured","ownerKind":"Class","ownerName":"AppRouter","id":754},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isExplicitNavigation","ownerKind":"Class","ownerName":"AppRouter","id":755},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isExplicitNavigationBack","ownerKind":"Class","ownerName":"AppRouter","id":756},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigating","ownerKind":"Class","ownerName":"AppRouter","id":757},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingBack","ownerKind":"Class","ownerName":"AppRouter","id":758},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingFirst","ownerKind":"Class","ownerName":"AppRouter","id":759},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingForward","ownerKind":"Class","ownerName":"AppRouter","id":760},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingNew","ownerKind":"Class","ownerName":"AppRouter","id":761},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingRefresh","ownerKind":"Class","ownerName":"AppRouter","id":762},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isRoot","ownerKind":"Class","ownerName":"AppRouter","id":763},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"navigation","ownerKind":"Class","ownerName":"AppRouter","id":764},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"options","ownerKind":"Class","ownerName":"AppRouter","id":765},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"parent","ownerKind":"Class","ownerName":"AppRouter","id":766},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"routes","ownerKind":"Class","ownerName":"AppRouter","id":767},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"transformTitle","ownerKind":"Class","ownerName":"AppRouter","id":768},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"viewPortDefaults","ownerKind":"Class","ownerName":"AppRouter","id":769},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"viewPorts","ownerKind":"Class","ownerName":"AppRouter","id":770},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"activate","ownerKind":"Class","ownerName":"AppRouter","id":771},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addRoute","ownerKind":"Class","ownerName":"AppRouter","id":772},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"configure","ownerKind":"Class","ownerName":"AppRouter","id":773},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"createChild","ownerKind":"Class","ownerName":"AppRouter","id":774},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"createNavModel","ownerKind":"Class","ownerName":"AppRouter","id":775},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"deactivate","ownerKind":"Class","ownerName":"AppRouter","id":776},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"ensureConfigured","ownerKind":"Class","ownerName":"AppRouter","id":777},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"generate","ownerKind":"Class","ownerName":"AppRouter","id":778},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"handleUnknownRoutes","ownerKind":"Class","ownerName":"AppRouter","id":779},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"hasOwnRoute","ownerKind":"Class","ownerName":"AppRouter","id":780},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"hasRoute","ownerKind":"Class","ownerName":"AppRouter","id":781},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"loadUrl","ownerKind":"Class","ownerName":"AppRouter","id":782},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigate","ownerKind":"Class","ownerName":"AppRouter","id":783},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigateBack","ownerKind":"Class","ownerName":"AppRouter","id":784},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigateToRoute","ownerKind":"Class","ownerName":"AppRouter","id":785},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"refreshNavigation","ownerKind":"Class","ownerName":"AppRouter","id":786},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"registerViewPort","ownerKind":"Class","ownerName":"AppRouter","id":787},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"reset","ownerKind":"Class","ownerName":"AppRouter","id":788},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"updateTitle","ownerKind":"Class","ownerName":"AppRouter","id":789},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"useViewPortDefaults","ownerKind":"Class","ownerName":"AppRouter","id":790},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"AppRouter","id":791},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"BuildNavigationPlanStep","id":792},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"BuildNavigationPlanStep","id":793},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"CanActivateNextStep","id":794},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"CanActivateNextStep","id":795},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"CanDeactivatePreviousStep","id":796},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"CanDeactivatePreviousStep","id":797},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"CommitChangesStep","id":798},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"CommitChangesStep","id":799},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"DeactivatePreviousStep","id":800},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"DeactivatePreviousStep","id":801},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"LoadRouteStep","id":802},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"LoadRouteStep","id":803},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"LoadRouteStep","id":804},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"NavModel","id":805},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"config","ownerKind":"Class","ownerName":"NavModel","id":806},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"href","ownerKind":"Class","ownerName":"NavModel","id":807},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isActive","ownerKind":"Class","ownerName":"NavModel","id":808},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"relativeHref","ownerKind":"Class","ownerName":"NavModel","id":809},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"router","ownerKind":"Class","ownerName":"NavModel","id":810},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"settings","ownerKind":"Class","ownerName":"NavModel","id":811},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"title","ownerKind":"Class","ownerName":"NavModel","id":812},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"setTitle","ownerKind":"Class","ownerName":"NavModel","id":813},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"NavigationInstruction","id":814},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"config","ownerKind":"Class","ownerName":"NavigationInstruction","id":815},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"fragment","ownerKind":"Class","ownerName":"NavigationInstruction","id":816},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"options","ownerKind":"Class","ownerName":"NavigationInstruction","id":817},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"params","ownerKind":"Class","ownerName":"NavigationInstruction","id":818},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"parentInstruction","ownerKind":"Class","ownerName":"NavigationInstruction","id":819},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"plan","ownerKind":"Class","ownerName":"NavigationInstruction","id":820},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"previousInstruction","ownerKind":"Class","ownerName":"NavigationInstruction","id":821},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"queryParams","ownerKind":"Class","ownerName":"NavigationInstruction","id":822},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"queryString","ownerKind":"Class","ownerName":"NavigationInstruction","id":823},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"router","ownerKind":"Class","ownerName":"NavigationInstruction","id":824},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"viewPortInstructions","ownerKind":"Class","ownerName":"NavigationInstruction","id":825},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addViewPortInstruction","ownerKind":"Class","ownerName":"NavigationInstruction","id":826},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"getAllInstructions","ownerKind":"Class","ownerName":"NavigationInstruction","id":827},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"getAllPreviousInstructions","ownerKind":"Class","ownerName":"NavigationInstruction","id":828},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"getBaseUrl","ownerKind":"Class","ownerName":"NavigationInstruction","id":829},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"getWildCardName","ownerKind":"Class","ownerName":"NavigationInstruction","id":830},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"getWildcardPath","ownerKind":"Class","ownerName":"NavigationInstruction","id":831},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"Pipeline","id":832},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"steps","ownerKind":"Class","ownerName":"Pipeline","id":833},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addStep","ownerKind":"Class","ownerName":"Pipeline","id":834},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Class","ownerName":"Pipeline","id":835},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"PipelineProvider","id":836},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addStep","ownerKind":"Class","ownerName":"PipelineProvider","id":837},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"createPipeline","ownerKind":"Class","ownerName":"PipelineProvider","id":838},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"removeStep","ownerKind":"Class","ownerName":"PipelineProvider","id":839},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"reset","ownerKind":"Class","ownerName":"PipelineProvider","id":840},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"PipelineProvider","id":841},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"Redirect","id":842},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigate","ownerKind":"Class","ownerName":"Redirect","id":843},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"setRouter","ownerKind":"Class","ownerName":"Redirect","id":844},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"RedirectToRoute","id":845},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigate","ownerKind":"Class","ownerName":"RedirectToRoute","id":846},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"setRouter","ownerKind":"Class","ownerName":"RedirectToRoute","id":847},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"RouteLoader","id":848},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"loadRoute","ownerKind":"Class","ownerName":"RouteLoader","id":849},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"Router","id":850},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"baseUrl","ownerKind":"Class","ownerName":"Router","id":851},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"container","ownerKind":"Class","ownerName":"Router","id":852},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"currentInstruction","ownerKind":"Class","ownerName":"Router","id":853},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"currentNavigationTracker","ownerKind":"Class","ownerName":"Router","id":854},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"history","ownerKind":"Class","ownerName":"Router","id":855},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isConfigured","ownerKind":"Class","ownerName":"Router","id":856},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isExplicitNavigation","ownerKind":"Class","ownerName":"Router","id":857},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isExplicitNavigationBack","ownerKind":"Class","ownerName":"Router","id":858},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigating","ownerKind":"Class","ownerName":"Router","id":859},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingBack","ownerKind":"Class","ownerName":"Router","id":860},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingFirst","ownerKind":"Class","ownerName":"Router","id":861},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingForward","ownerKind":"Class","ownerName":"Router","id":862},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingNew","ownerKind":"Class","ownerName":"Router","id":863},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isNavigatingRefresh","ownerKind":"Class","ownerName":"Router","id":864},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"isRoot","ownerKind":"Class","ownerName":"Router","id":865},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"navigation","ownerKind":"Class","ownerName":"Router","id":866},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"options","ownerKind":"Class","ownerName":"Router","id":867},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"parent","ownerKind":"Class","ownerName":"Router","id":868},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"routes","ownerKind":"Class","ownerName":"Router","id":869},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"transformTitle","ownerKind":"Class","ownerName":"Router","id":870},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"viewPortDefaults","ownerKind":"Class","ownerName":"Router","id":871},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"viewPorts","ownerKind":"Class","ownerName":"Router","id":872},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addRoute","ownerKind":"Class","ownerName":"Router","id":873},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"configure","ownerKind":"Class","ownerName":"Router","id":874},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"createChild","ownerKind":"Class","ownerName":"Router","id":875},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"createNavModel","ownerKind":"Class","ownerName":"Router","id":876},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"ensureConfigured","ownerKind":"Class","ownerName":"Router","id":877},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"generate","ownerKind":"Class","ownerName":"Router","id":878},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"handleUnknownRoutes","ownerKind":"Class","ownerName":"Router","id":879},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"hasOwnRoute","ownerKind":"Class","ownerName":"Router","id":880},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"hasRoute","ownerKind":"Class","ownerName":"Router","id":881},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigate","ownerKind":"Class","ownerName":"Router","id":882},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigateBack","ownerKind":"Class","ownerName":"Router","id":883},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigateToRoute","ownerKind":"Class","ownerName":"Router","id":884},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"refreshNavigation","ownerKind":"Class","ownerName":"Router","id":885},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"registerViewPort","ownerKind":"Class","ownerName":"Router","id":886},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"reset","ownerKind":"Class","ownerName":"Router","id":887},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"updateTitle","ownerKind":"Class","ownerName":"Router","id":888},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"useViewPortDefaults","ownerKind":"Class","ownerName":"Router","id":889},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Class","apiName":"RouterConfiguration","id":890},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"instructions","ownerKind":"Class","ownerName":"RouterConfiguration","id":891},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"options","ownerKind":"Class","ownerName":"RouterConfiguration","id":892},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"pipelineSteps","ownerKind":"Class","ownerName":"RouterConfiguration","id":893},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"title","ownerKind":"Class","ownerName":"RouterConfiguration","id":894},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"unknownRouteConfig","ownerKind":"Class","ownerName":"RouterConfiguration","id":895},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"viewPortDefaults","ownerKind":"Class","ownerName":"RouterConfiguration","id":896},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addAuthorizeStep","ownerKind":"Class","ownerName":"RouterConfiguration","id":897},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addPipelineStep","ownerKind":"Class","ownerName":"RouterConfiguration","id":898},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addPostRenderStep","ownerKind":"Class","ownerName":"RouterConfiguration","id":899},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addPreActivateStep","ownerKind":"Class","ownerName":"RouterConfiguration","id":900},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"addPreRenderStep","ownerKind":"Class","ownerName":"RouterConfiguration","id":901},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"exportToRouter","ownerKind":"Class","ownerName":"RouterConfiguration","id":902},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"fallbackRoute","ownerKind":"Class","ownerName":"RouterConfiguration","id":903},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"map","ownerKind":"Class","ownerName":"RouterConfiguration","id":904},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"mapRoute","ownerKind":"Class","ownerName":"RouterConfiguration","id":905},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"mapUnknownRoutes","ownerKind":"Class","ownerName":"RouterConfiguration","id":906},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"useViewPortDefaults","ownerKind":"Class","ownerName":"RouterConfiguration","id":907},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"ActivationStrategy","id":908},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"invokeLifecycle","ownerKind":"Interface","ownerName":"ActivationStrategy","id":909},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"noChange","ownerKind":"Interface","ownerName":"ActivationStrategy","id":910},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"replace","ownerKind":"Interface","ownerName":"ActivationStrategy","id":911},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"ConfiguresRouter","id":912},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"configureRouter","ownerKind":"Interface","ownerName":"ConfiguresRouter","id":913},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"IObservable","id":914},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"subscribe","ownerKind":"Interface","ownerName":"IObservable","id":915},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"ISubscription","id":916},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Interface","ownerName":"ISubscription","id":917},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"NavigationCommand","id":918},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"navigate","ownerKind":"Interface","ownerName":"NavigationCommand","id":919},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"NavigationInstructionInit","id":920},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"config","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":921},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"fragment","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":922},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"options","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":923},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"params","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":924},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"parentInstruction","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":925},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"previousInstruction","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":926},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"queryParams","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":927},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"queryString","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":928},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"router","ownerKind":"Interface","ownerName":"NavigationInstructionInit","id":929},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"Next","id":930},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"cancel","ownerKind":"Interface","ownerName":"Next","id":931},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"complete","ownerKind":"Interface","ownerName":"Next","id":932},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"reject","ownerKind":"Interface","ownerName":"Next","id":933},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"PipelineResult","id":934},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"completed","ownerKind":"Interface","ownerName":"PipelineResult","id":935},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"instruction","ownerKind":"Interface","ownerName":"PipelineResult","id":936},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"output","ownerKind":"Interface","ownerName":"PipelineResult","id":937},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"status","ownerKind":"Interface","ownerName":"PipelineResult","id":938},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"PipelineStep","id":939},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"run","ownerKind":"Interface","ownerName":"PipelineStep","id":940},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"RoutableComponentActivate","id":941},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"activate","ownerKind":"Interface","ownerName":"RoutableComponentActivate","id":942},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"RoutableComponentCanActivate","id":943},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"canActivate","ownerKind":"Interface","ownerName":"RoutableComponentCanActivate","id":944},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"RoutableComponentCanDeactivate","id":945},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"canDeactivate","ownerKind":"Interface","ownerName":"RoutableComponentCanDeactivate","id":946},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"RoutableComponentDeactivate","id":947},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"deactivate","ownerKind":"Interface","ownerName":"RoutableComponentDeactivate","id":948},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"RoutableComponentDetermineActivationStrategy","id":949},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Method","apiName":"determineActivationStrategy","ownerKind":"Interface","ownerName":"RoutableComponentDetermineActivationStrategy","id":950},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Interface","apiName":"RouteConfig","id":951},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"activationStrategy","ownerKind":"Interface","ownerName":"RouteConfig","id":952},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"caseSensitive","ownerKind":"Interface","ownerName":"RouteConfig","id":953},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"generationUsesHref","ownerKind":"Interface","ownerName":"RouteConfig","id":954},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"href","ownerKind":"Interface","ownerName":"RouteConfig","id":955},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"layoutModel","ownerKind":"Interface","ownerName":"RouteConfig","id":956},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"layoutView","ownerKind":"Interface","ownerName":"RouteConfig","id":957},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"layoutViewModel","ownerKind":"Interface","ownerName":"RouteConfig","id":958},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"moduleId","ownerKind":"Interface","ownerName":"RouteConfig","id":959},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"name","ownerKind":"Interface","ownerName":"RouteConfig","id":960},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"nav","ownerKind":"Interface","ownerName":"RouteConfig","id":961},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"navModel","ownerKind":"Interface","ownerName":"RouteConfig","id":962},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"navigationStrategy","ownerKind":"Interface","ownerName":"RouteConfig","id":963},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"redirect","ownerKind":"Interface","ownerName":"RouteConfig","id":964},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"route","ownerKind":"Interface","ownerName":"RouteConfig","id":965},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"settings","ownerKind":"Interface","ownerName":"RouteConfig","id":966},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"title","ownerKind":"Interface","ownerName":"RouteConfig","id":967},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Property","apiName":"viewPorts","ownerKind":"Interface","ownerName":"RouteConfig","id":968},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Constant","apiName":"activationStrategy","id":969},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Constant","apiName":"pipelineStatus","id":970},{"libraryName":"Router","libraryHref":"docs/api/router","apiKind":"Function","apiName":"isNavigationCommand","id":971},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Class","apiName":"TaskQueue","id":972},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Property","apiName":"flushing","ownerKind":"Class","ownerName":"TaskQueue","id":973},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Property","apiName":"longStacks","ownerKind":"Class","ownerName":"TaskQueue","id":974},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Method","apiName":"flushMicroTaskQueue","ownerKind":"Class","ownerName":"TaskQueue","id":975},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Method","apiName":"flushTaskQueue","ownerKind":"Class","ownerName":"TaskQueue","id":976},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Method","apiName":"prepareQueueStack","ownerKind":"Class","ownerName":"TaskQueue","id":977},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Method","apiName":"queueMicroTask","ownerKind":"Class","ownerName":"TaskQueue","id":978},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Method","apiName":"queueTask","ownerKind":"Class","ownerName":"TaskQueue","id":979},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Interface","apiName":"Task","id":980},{"libraryName":"Task Queue","libraryHref":"docs/api/task-queue","apiKind":"Method","apiName":"call","ownerKind":"Interface","ownerName":"Task","id":981},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"Animator","id":982},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"addClass","ownerKind":"Class","ownerName":"Animator","id":983},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"animate","ownerKind":"Class","ownerName":"Animator","id":984},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"enter","ownerKind":"Class","ownerName":"Animator","id":985},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"leave","ownerKind":"Class","ownerName":"Animator","id":986},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerEffect","ownerKind":"Class","ownerName":"Animator","id":987},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeClass","ownerKind":"Class","ownerName":"Animator","id":988},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"runSequence","ownerKind":"Class","ownerName":"Animator","id":989},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unregisterEffect","ownerKind":"Class","ownerName":"Animator","id":990},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"BehaviorInstruction","id":991},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"anchorIsContainer","ownerKind":"Class","ownerName":"BehaviorInstruction","id":992},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"attrName","ownerKind":"Class","ownerName":"BehaviorInstruction","id":993},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"attributes","ownerKind":"Class","ownerName":"BehaviorInstruction","id":994},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"contentFactory","ownerKind":"Class","ownerName":"BehaviorInstruction","id":995},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"enhance","ownerKind":"Class","ownerName":"BehaviorInstruction","id":996},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"host","ownerKind":"Class","ownerName":"BehaviorInstruction","id":997},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"inheritBindingContext","ownerKind":"Class","ownerName":"BehaviorInstruction","id":998},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"initiatedByBehavior","ownerKind":"Class","ownerName":"BehaviorInstruction","id":999},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"originalAttrName","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1000},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"partReplacements","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1001},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"skipContentProcessing","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1002},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"type","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1003},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewFactory","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1004},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewModel","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1005},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"normal","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1006},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attribute","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1007},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"dynamic","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1008},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"element","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1009},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"enhance","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1010},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unitTest","ownerKind":"Class","ownerName":"BehaviorInstruction","id":1011},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"BehaviorPropertyObserver","id":1012},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"call","ownerKind":"Class","ownerName":"BehaviorPropertyObserver","id":1013},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getValue","ownerKind":"Class","ownerName":"BehaviorPropertyObserver","id":1014},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"setValue","ownerKind":"Class","ownerName":"BehaviorPropertyObserver","id":1015},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"BehaviorPropertyObserver","id":1016},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unsubscribe","ownerKind":"Class","ownerName":"BehaviorPropertyObserver","id":1017},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"BindableProperty","id":1018},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"createObserver","ownerKind":"Class","ownerName":"BindableProperty","id":1019},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"defineOn","ownerKind":"Class","ownerName":"BindableProperty","id":1020},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerWith","ownerKind":"Class","ownerName":"BindableProperty","id":1021},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"BindingLanguage","id":1022},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"createAttributeInstruction","ownerKind":"Class","ownerName":"BindingLanguage","id":1023},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"inspectAttribute","ownerKind":"Class","ownerName":"BindingLanguage","id":1024},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"inspectTextContent","ownerKind":"Class","ownerName":"BindingLanguage","id":1025},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"BoundViewFactory","id":1026},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"isCaching","ownerKind":"Class","ownerName":"BoundViewFactory","id":1027},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"create","ownerKind":"Class","ownerName":"BoundViewFactory","id":1028},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getCachedView","ownerKind":"Class","ownerName":"BoundViewFactory","id":1029},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"returnViewToCache","ownerKind":"Class","ownerName":"BoundViewFactory","id":1030},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"setCacheSize","ownerKind":"Class","ownerName":"BoundViewFactory","id":1031},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"CompositionEngine","id":1032},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"compose","ownerKind":"Class","ownerName":"CompositionEngine","id":1033},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"createController","ownerKind":"Class","ownerName":"CompositionEngine","id":1034},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"ensureViewModel","ownerKind":"Class","ownerName":"CompositionEngine","id":1035},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"CompositionTransaction","id":1036},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"enlist","ownerKind":"Class","ownerName":"CompositionTransaction","id":1037},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"tryCapture","ownerKind":"Class","ownerName":"CompositionTransaction","id":1038},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"CompositionTransactionNotifier","id":1039},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"done","ownerKind":"Class","ownerName":"CompositionTransactionNotifier","id":1040},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"CompositionTransactionOwnershipToken","id":1041},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"resolve","ownerKind":"Class","ownerName":"CompositionTransactionOwnershipToken","id":1042},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"waitForCompositionComplete","ownerKind":"Class","ownerName":"CompositionTransactionOwnershipToken","id":1043},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"Controller","id":1044},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"behavior","ownerKind":"Class","ownerName":"Controller","id":1045},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"view","ownerKind":"Class","ownerName":"Controller","id":1046},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewModel","ownerKind":"Class","ownerName":"Controller","id":1047},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attached","ownerKind":"Class","ownerName":"Controller","id":1048},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"automate","ownerKind":"Class","ownerName":"Controller","id":1049},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"Controller","id":1050},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"Controller","id":1051},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"detached","ownerKind":"Class","ownerName":"Controller","id":1052},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"Controller","id":1053},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ConventionalViewStrategy","id":1054},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Class","ownerName":"ConventionalViewStrategy","id":1055},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ElementConfigResource","id":1056},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"initialize","ownerKind":"Class","ownerName":"ElementConfigResource","id":1057},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"load","ownerKind":"Class","ownerName":"ElementConfigResource","id":1058},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"ElementConfigResource","id":1059},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ElementEvents","id":1060},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"dispose","ownerKind":"Class","ownerName":"ElementEvents","id":1061},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"disposeAll","ownerKind":"Class","ownerName":"ElementEvents","id":1062},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"publish","ownerKind":"Class","ownerName":"ElementEvents","id":1063},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"subscribe","ownerKind":"Class","ownerName":"ElementEvents","id":1064},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"subscribeOnce","ownerKind":"Class","ownerName":"ElementEvents","id":1065},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"HtmlBehaviorResource","id":1066},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"addChildBinding","ownerKind":"Class","ownerName":"HtmlBehaviorResource","id":1067},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"compile","ownerKind":"Class","ownerName":"HtmlBehaviorResource","id":1068},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"create","ownerKind":"Class","ownerName":"HtmlBehaviorResource","id":1069},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"initialize","ownerKind":"Class","ownerName":"HtmlBehaviorResource","id":1070},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"load","ownerKind":"Class","ownerName":"HtmlBehaviorResource","id":1071},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"HtmlBehaviorResource","id":1072},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"convention","ownerKind":"Class","ownerName":"HtmlBehaviorResource","id":1073},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"InlineViewStrategy","id":1074},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Class","ownerName":"InlineViewStrategy","id":1075},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ModuleAnalyzer","id":1076},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"analyze","ownerKind":"Class","ownerName":"ModuleAnalyzer","id":1077},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getAnalysis","ownerKind":"Class","ownerName":"ModuleAnalyzer","id":1078},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"NoViewStrategy","id":1079},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Class","ownerName":"NoViewStrategy","id":1080},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"PassThroughSlot","id":1081},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"needsFallbackRendering","ownerKind":"Class","ownerName":"PassThroughSlot","id":1082},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"addNode","ownerKind":"Class","ownerName":"PassThroughSlot","id":1083},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attached","ownerKind":"Class","ownerName":"PassThroughSlot","id":1084},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"PassThroughSlot","id":1085},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"PassThroughSlot","id":1086},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"detached","ownerKind":"Class","ownerName":"PassThroughSlot","id":1087},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"passThroughTo","ownerKind":"Class","ownerName":"PassThroughSlot","id":1088},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"projectFrom","ownerKind":"Class","ownerName":"PassThroughSlot","id":1089},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeAll","ownerKind":"Class","ownerName":"PassThroughSlot","id":1090},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeView","ownerKind":"Class","ownerName":"PassThroughSlot","id":1091},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"renderFallbackContent","ownerKind":"Class","ownerName":"PassThroughSlot","id":1092},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"PassThroughSlot","id":1093},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"RelativeViewStrategy","id":1094},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Class","ownerName":"RelativeViewStrategy","id":1095},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"makeRelativeTo","ownerKind":"Class","ownerName":"RelativeViewStrategy","id":1096},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ResourceDescription","id":1097},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"initialize","ownerKind":"Class","ownerName":"ResourceDescription","id":1098},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"load","ownerKind":"Class","ownerName":"ResourceDescription","id":1099},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"ResourceDescription","id":1100},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ResourceLoadContext","id":1101},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"dependencies","ownerKind":"Class","ownerName":"ResourceLoadContext","id":1102},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"addDependency","ownerKind":"Class","ownerName":"ResourceLoadContext","id":1103},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"hasDependency","ownerKind":"Class","ownerName":"ResourceLoadContext","id":1104},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ResourceModule","id":1105},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"initialize","ownerKind":"Class","ownerName":"ResourceModule","id":1106},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"load","ownerKind":"Class","ownerName":"ResourceModule","id":1107},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"ResourceModule","id":1108},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ShadowDOM","id":1109},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"defaultSlotKey","ownerKind":"Class","ownerName":"ShadowDOM","id":1110},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"distributeNodes","ownerKind":"Class","ownerName":"ShadowDOM","id":1111},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"distributeView","ownerKind":"Class","ownerName":"ShadowDOM","id":1112},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getSlotName","ownerKind":"Class","ownerName":"ShadowDOM","id":1113},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"undistributeAll","ownerKind":"Class","ownerName":"ShadowDOM","id":1114},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"undistributeView","ownerKind":"Class","ownerName":"ShadowDOM","id":1115},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ShadowSlot","id":1116},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"needsFallbackRendering","ownerKind":"Class","ownerName":"ShadowSlot","id":1117},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"addNode","ownerKind":"Class","ownerName":"ShadowSlot","id":1118},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attached","ownerKind":"Class","ownerName":"ShadowSlot","id":1119},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"ShadowSlot","id":1120},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"ShadowSlot","id":1121},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"detached","ownerKind":"Class","ownerName":"ShadowSlot","id":1122},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"projectFrom","ownerKind":"Class","ownerName":"ShadowSlot","id":1123},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"projectTo","ownerKind":"Class","ownerName":"ShadowSlot","id":1124},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeAll","ownerKind":"Class","ownerName":"ShadowSlot","id":1125},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeView","ownerKind":"Class","ownerName":"ShadowSlot","id":1126},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"renderFallbackContent","ownerKind":"Class","ownerName":"ShadowSlot","id":1127},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"ShadowSlot","id":1128},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"SlotCustomAttribute","id":1129},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"valueChanged","ownerKind":"Class","ownerName":"SlotCustomAttribute","id":1130},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"SlotCustomAttribute","id":1131},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"StaticViewStrategy","id":1132},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"dependencies","ownerKind":"Class","ownerName":"StaticViewStrategy","id":1133},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"factory","ownerKind":"Class","ownerName":"StaticViewStrategy","id":1134},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"factoryIsReady","ownerKind":"Class","ownerName":"StaticViewStrategy","id":1135},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"template","ownerKind":"Class","ownerName":"StaticViewStrategy","id":1136},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Class","ownerName":"StaticViewStrategy","id":1137},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"TargetInstruction","id":1138},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"anchorIsContainer","ownerKind":"Class","ownerName":"TargetInstruction","id":1139},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"behaviorInstructions","ownerKind":"Class","ownerName":"TargetInstruction","id":1140},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"contentExpression","ownerKind":"Class","ownerName":"TargetInstruction","id":1141},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"elementInstruction","ownerKind":"Class","ownerName":"TargetInstruction","id":1142},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"expressions","ownerKind":"Class","ownerName":"TargetInstruction","id":1143},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"injectorId","ownerKind":"Class","ownerName":"TargetInstruction","id":1144},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"lifting","ownerKind":"Class","ownerName":"TargetInstruction","id":1145},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"parentInjectorId","ownerKind":"Class","ownerName":"TargetInstruction","id":1146},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"providers","ownerKind":"Class","ownerName":"TargetInstruction","id":1147},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"shadowSlot","ownerKind":"Class","ownerName":"TargetInstruction","id":1148},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"slotFallbackFactory","ownerKind":"Class","ownerName":"TargetInstruction","id":1149},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"slotName","ownerKind":"Class","ownerName":"TargetInstruction","id":1150},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"values","ownerKind":"Class","ownerName":"TargetInstruction","id":1151},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewFactory","ownerKind":"Class","ownerName":"TargetInstruction","id":1152},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"noExpressions","ownerKind":"Class","ownerName":"TargetInstruction","id":1153},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"contentExpression","ownerKind":"Class","ownerName":"TargetInstruction","id":1154},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"lifting","ownerKind":"Class","ownerName":"TargetInstruction","id":1155},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"normal","ownerKind":"Class","ownerName":"TargetInstruction","id":1156},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"shadowSlot","ownerKind":"Class","ownerName":"TargetInstruction","id":1157},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"surrogate","ownerKind":"Class","ownerName":"TargetInstruction","id":1158},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"TemplateRegistryViewStrategy","id":1159},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Class","ownerName":"TemplateRegistryViewStrategy","id":1160},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"TemplatingEngine","id":1161},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"compose","ownerKind":"Class","ownerName":"TemplatingEngine","id":1162},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"configureAnimator","ownerKind":"Class","ownerName":"TemplatingEngine","id":1163},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"enhance","ownerKind":"Class","ownerName":"TemplatingEngine","id":1164},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"View","id":1165},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"bindingContext","ownerKind":"Class","ownerName":"View","id":1166},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"container","ownerKind":"Class","ownerName":"View","id":1167},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"controller","ownerKind":"Class","ownerName":"View","id":1168},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"fragment","ownerKind":"Class","ownerName":"View","id":1169},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"overrideContext","ownerKind":"Class","ownerName":"View","id":1170},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewFactory","ownerKind":"Class","ownerName":"View","id":1171},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"addBinding","ownerKind":"Class","ownerName":"View","id":1172},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"appendNodesTo","ownerKind":"Class","ownerName":"View","id":1173},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attached","ownerKind":"Class","ownerName":"View","id":1174},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"View","id":1175},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"View","id":1176},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"detached","ownerKind":"Class","ownerName":"View","id":1177},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"insertNodesBefore","ownerKind":"Class","ownerName":"View","id":1178},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeNodes","ownerKind":"Class","ownerName":"View","id":1179},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"returnToCache","ownerKind":"Class","ownerName":"View","id":1180},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"View","id":1181},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewCompileInstruction","id":1182},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"associatedModuleId","ownerKind":"Class","ownerName":"ViewCompileInstruction","id":1183},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"compileSurrogate","ownerKind":"Class","ownerName":"ViewCompileInstruction","id":1184},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"targetShadowDOM","ownerKind":"Class","ownerName":"ViewCompileInstruction","id":1185},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"normal","ownerKind":"Class","ownerName":"ViewCompileInstruction","id":1186},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewCompiler","id":1187},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"compile","ownerKind":"Class","ownerName":"ViewCompiler","id":1188},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewEngine","id":1189},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewModelRequireMetadataKey","ownerKind":"Class","ownerName":"ViewEngine","id":1190},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"addResourcePlugin","ownerKind":"Class","ownerName":"ViewEngine","id":1191},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"importViewModelResource","ownerKind":"Class","ownerName":"ViewEngine","id":1192},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"importViewResources","ownerKind":"Class","ownerName":"ViewEngine","id":1193},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadTemplateResources","ownerKind":"Class","ownerName":"ViewEngine","id":1194},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Class","ownerName":"ViewEngine","id":1195},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewEngineHooksResource","id":1196},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"initialize","ownerKind":"Class","ownerName":"ViewEngineHooksResource","id":1197},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"load","ownerKind":"Class","ownerName":"ViewEngineHooksResource","id":1198},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"ViewEngineHooksResource","id":1199},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"convention","ownerKind":"Class","ownerName":"ViewEngineHooksResource","id":1200},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewFactory","id":1201},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"isCaching","ownerKind":"Class","ownerName":"ViewFactory","id":1202},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"create","ownerKind":"Class","ownerName":"ViewFactory","id":1203},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getCachedView","ownerKind":"Class","ownerName":"ViewFactory","id":1204},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"returnViewToCache","ownerKind":"Class","ownerName":"ViewFactory","id":1205},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"setCacheSize","ownerKind":"Class","ownerName":"ViewFactory","id":1206},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewLocator","id":1207},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewStrategyMetadataKey","ownerKind":"Class","ownerName":"ViewLocator","id":1208},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"convertOriginToViewUrl","ownerKind":"Class","ownerName":"ViewLocator","id":1209},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"createFallbackViewStrategy","ownerKind":"Class","ownerName":"ViewLocator","id":1210},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getViewStrategy","ownerKind":"Class","ownerName":"ViewLocator","id":1211},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewResources","id":1212},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"bindingLanguage","ownerKind":"Class","ownerName":"ViewResources","id":1213},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"autoRegister","ownerKind":"Class","ownerName":"ViewResources","id":1214},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getAttribute","ownerKind":"Class","ownerName":"ViewResources","id":1215},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getBindingBehavior","ownerKind":"Class","ownerName":"ViewResources","id":1216},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getBindingLanguage","ownerKind":"Class","ownerName":"ViewResources","id":1217},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getElement","ownerKind":"Class","ownerName":"ViewResources","id":1218},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getValue","ownerKind":"Class","ownerName":"ViewResources","id":1219},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getValueConverter","ownerKind":"Class","ownerName":"ViewResources","id":1220},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"mapAttribute","ownerKind":"Class","ownerName":"ViewResources","id":1221},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"patchInParent","ownerKind":"Class","ownerName":"ViewResources","id":1222},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerAttribute","ownerKind":"Class","ownerName":"ViewResources","id":1223},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerBindingBehavior","ownerKind":"Class","ownerName":"ViewResources","id":1224},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerElement","ownerKind":"Class","ownerName":"ViewResources","id":1225},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerValue","ownerKind":"Class","ownerName":"ViewResources","id":1226},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerValueConverter","ownerKind":"Class","ownerName":"ViewResources","id":1227},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"registerViewEngineHooks","ownerKind":"Class","ownerName":"ViewResources","id":1228},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"relativeToView","ownerKind":"Class","ownerName":"ViewResources","id":1229},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"convention","ownerKind":"Class","ownerName":"ViewResources","id":1230},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Class","apiName":"ViewSlot","id":1231},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"add","ownerKind":"Class","ownerName":"ViewSlot","id":1232},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"animateView","ownerKind":"Class","ownerName":"ViewSlot","id":1233},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attached","ownerKind":"Class","ownerName":"ViewSlot","id":1234},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"ViewSlot","id":1235},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"detached","ownerKind":"Class","ownerName":"ViewSlot","id":1236},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"insert","ownerKind":"Class","ownerName":"ViewSlot","id":1237},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"move","ownerKind":"Class","ownerName":"ViewSlot","id":1238},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"projectTo","ownerKind":"Class","ownerName":"ViewSlot","id":1239},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"remove","ownerKind":"Class","ownerName":"ViewSlot","id":1240},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeAll","ownerKind":"Class","ownerName":"ViewSlot","id":1241},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeAt","ownerKind":"Class","ownerName":"ViewSlot","id":1242},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"removeMany","ownerKind":"Class","ownerName":"ViewSlot","id":1243},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"transformChildNodesIntoView","ownerKind":"Class","ownerName":"ViewSlot","id":1244},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"ViewSlot","id":1245},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ComponentAttached","id":1246},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attached","ownerKind":"Interface","ownerName":"ComponentAttached","id":1247},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ComponentBind","id":1248},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"bind","ownerKind":"Interface","ownerName":"ComponentBind","id":1249},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ComponentCreated","id":1250},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"created","ownerKind":"Interface","ownerName":"ComponentCreated","id":1251},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ComponentDetached","id":1252},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"detached","ownerKind":"Interface","ownerName":"ComponentDetached","id":1253},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ComponentUnbind","id":1254},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unbind","ownerKind":"Interface","ownerName":"ComponentUnbind","id":1255},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"CompositionContext","id":1256},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"bindingContext","ownerKind":"Interface","ownerName":"CompositionContext","id":1257},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"childContainer","ownerKind":"Interface","ownerName":"CompositionContext","id":1258},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"container","ownerKind":"Interface","ownerName":"CompositionContext","id":1259},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"host","ownerKind":"Interface","ownerName":"CompositionContext","id":1260},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"model","ownerKind":"Interface","ownerName":"CompositionContext","id":1261},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"overrideContext","ownerKind":"Interface","ownerName":"CompositionContext","id":1262},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"owningView","ownerKind":"Interface","ownerName":"CompositionContext","id":1263},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"skipActivation","ownerKind":"Interface","ownerName":"CompositionContext","id":1264},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"view","ownerKind":"Interface","ownerName":"CompositionContext","id":1265},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewModel","ownerKind":"Interface","ownerName":"CompositionContext","id":1266},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewModelResource","ownerKind":"Interface","ownerName":"CompositionContext","id":1267},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewResources","ownerKind":"Interface","ownerName":"CompositionContext","id":1268},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"viewSlot","ownerKind":"Interface","ownerName":"CompositionContext","id":1269},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"DynamicComponentGetViewStrategy","id":1270},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"getViewStrategy","ownerKind":"Interface","ownerName":"DynamicComponentGetViewStrategy","id":1271},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"EnhanceInstruction","id":1272},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"bindingContext","ownerKind":"Interface","ownerName":"EnhanceInstruction","id":1273},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"container","ownerKind":"Interface","ownerName":"EnhanceInstruction","id":1274},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"element","ownerKind":"Interface","ownerName":"EnhanceInstruction","id":1275},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"overrideContext","ownerKind":"Interface","ownerName":"EnhanceInstruction","id":1276},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"resources","ownerKind":"Interface","ownerName":"EnhanceInstruction","id":1277},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"EventHandler","id":1278},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"bubbles","ownerKind":"Interface","ownerName":"EventHandler","id":1279},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"capture","ownerKind":"Interface","ownerName":"EventHandler","id":1280},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"dispose","ownerKind":"Interface","ownerName":"EventHandler","id":1281},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"eventName","ownerKind":"Interface","ownerName":"EventHandler","id":1282},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"handler","ownerKind":"Interface","ownerName":"EventHandler","id":1283},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"IBindablePropertyConfig","id":1284},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"attribute","ownerKind":"Interface","ownerName":"IBindablePropertyConfig","id":1285},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"changeHandler","ownerKind":"Interface","ownerName":"IBindablePropertyConfig","id":1286},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"defaultBindingMode","ownerKind":"Interface","ownerName":"IBindablePropertyConfig","id":1287},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"defaultValue","ownerKind":"Interface","ownerName":"IBindablePropertyConfig","id":1288},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"name","ownerKind":"Interface","ownerName":"IBindablePropertyConfig","id":1289},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"primaryProperty","ownerKind":"Interface","ownerName":"IBindablePropertyConfig","id":1290},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"IStaticResourceConfig","id":1291},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"bindables","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1292},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"containerless","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1293},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"defaultBindingMode","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1294},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"hasDynamicOptions","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1295},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"name","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1296},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"processAttributes","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1297},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"processContent","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1298},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"shadowDOMOptions","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1299},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"templateController","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1300},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"type","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1301},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"usesShadowDOM","ownerKind":"Interface","ownerName":"IStaticResourceConfig","id":1302},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"IStaticViewConfig","id":1303},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"dependencies","ownerKind":"Interface","ownerName":"IStaticViewConfig","id":1304},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"template","ownerKind":"Interface","ownerName":"IStaticViewConfig","id":1305},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"IStaticViewStrategyConfig","id":1306},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"dependencies","ownerKind":"Interface","ownerName":"IStaticViewStrategyConfig","id":1307},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"template","ownerKind":"Interface","ownerName":"IStaticViewStrategyConfig","id":1308},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ViewCreateInstruction","id":1309},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"enhance","ownerKind":"Interface","ownerName":"ViewCreateInstruction","id":1310},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"partReplacements","ownerKind":"Interface","ownerName":"ViewCreateInstruction","id":1311},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ViewEngineHooks","id":1312},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"afterCompile","ownerKind":"Interface","ownerName":"ViewEngineHooks","id":1313},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"afterCreate","ownerKind":"Interface","ownerName":"ViewEngineHooks","id":1314},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"beforeBind","ownerKind":"Interface","ownerName":"ViewEngineHooks","id":1315},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"beforeCompile","ownerKind":"Interface","ownerName":"ViewEngineHooks","id":1316},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"beforeCreate","ownerKind":"Interface","ownerName":"ViewEngineHooks","id":1317},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Property","apiName":"beforeUnbind","ownerKind":"Interface","ownerName":"ViewEngineHooks","id":1318},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ViewNode","id":1319},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"attached","ownerKind":"Interface","ownerName":"ViewNode","id":1320},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"bind","ownerKind":"Interface","ownerName":"ViewNode","id":1321},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"detached","ownerKind":"Interface","ownerName":"ViewNode","id":1322},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"unbind","ownerKind":"Interface","ownerName":"ViewNode","id":1323},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Interface","apiName":"ViewStrategy","id":1324},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Method","apiName":"loadViewFactory","ownerKind":"Interface","ownerName":"ViewStrategy","id":1325},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Constant","apiName":"SwapStrategies","id":1326},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Constant","apiName":"animationEvent","id":1327},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Constant","apiName":"viewStrategy","id":1328},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"behavior","id":1329},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"bindable","id":1330},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"child","id":1331},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"children","id":1332},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"containerless","id":1333},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"customAttribute","id":1334},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"customElement","id":1335},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"dynamicOptions","id":1336},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"elementConfig","id":1337},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"inlineView","id":1338},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"noView","id":1339},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"processAttributes","id":1340},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"processContent","id":1341},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"resource","id":1342},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"templateController","id":1343},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"useShadowDOM","id":1344},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"useView","id":1345},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"useViewStrategy","id":1346},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"validateBehaviorName","id":1347},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"view","id":1348},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"viewEngineHooks","id":1349},{"libraryName":"Templating","libraryHref":"docs/api/templating","apiKind":"Function","apiName":"viewResources","id":1350},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Class","apiName":"AttributeMap","id":1351},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Property","apiName":"allElements","ownerKind":"Class","ownerName":"AttributeMap","id":1352},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Property","apiName":"elements","ownerKind":"Class","ownerName":"AttributeMap","id":1353},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Property","apiName":"inject","ownerKind":"Class","ownerName":"AttributeMap","id":1354},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"map","ownerKind":"Class","ownerName":"AttributeMap","id":1355},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"register","ownerKind":"Class","ownerName":"AttributeMap","id":1356},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"registerUniversal","ownerKind":"Class","ownerName":"AttributeMap","id":1357},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Class","apiName":"ChildInterpolationBinding","id":1358},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"ChildInterpolationBinding","id":1359},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"call","ownerKind":"Class","ownerName":"ChildInterpolationBinding","id":1360},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"connect","ownerKind":"Class","ownerName":"ChildInterpolationBinding","id":1361},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"ChildInterpolationBinding","id":1362},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"updateTarget","ownerKind":"Class","ownerName":"ChildInterpolationBinding","id":1363},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Class","apiName":"InterpolationBinding","id":1364},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"InterpolationBinding","id":1365},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"interpolate","ownerKind":"Class","ownerName":"InterpolationBinding","id":1366},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"InterpolationBinding","id":1367},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"updateOneTimeBindings","ownerKind":"Class","ownerName":"InterpolationBinding","id":1368},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Class","apiName":"InterpolationBindingExpression","id":1369},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"createBinding","ownerKind":"Class","ownerName":"InterpolationBindingExpression","id":1370},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Class","apiName":"SyntaxInterpreter","id":1371},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Property","apiName":"inject","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1372},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1373},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"call","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1374},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"capture","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1375},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"delegate","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1376},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"determineDefaultBindingMode","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1377},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"for","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1378},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"from-view","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1379},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"handleUnknownCommand","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1380},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"interpret","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1381},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"one-time","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1382},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"options","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1383},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"to-view","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1384},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"trigger","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1385},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"two-way","ownerKind":"Class","ownerName":"SyntaxInterpreter","id":1386},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Class","apiName":"TemplatingBindingLanguage","id":1387},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Property","apiName":"inject","ownerKind":"Class","ownerName":"TemplatingBindingLanguage","id":1388},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"createAttributeInstruction","ownerKind":"Class","ownerName":"TemplatingBindingLanguage","id":1389},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"inspectAttribute","ownerKind":"Class","ownerName":"TemplatingBindingLanguage","id":1390},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"inspectTextContent","ownerKind":"Class","ownerName":"TemplatingBindingLanguage","id":1391},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Method","apiName":"parseInterpolation","ownerKind":"Class","ownerName":"TemplatingBindingLanguage","id":1392},{"libraryName":"Templating-Binding","libraryHref":"docs/api/templating-binding","apiKind":"Function","apiName":"configure","id":1393},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"AbstractRepeater","id":1394},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"addView","ownerKind":"Class","ownerName":"AbstractRepeater","id":1395},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"insertView","ownerKind":"Class","ownerName":"AbstractRepeater","id":1396},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"matcher","ownerKind":"Class","ownerName":"AbstractRepeater","id":1397},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"moveView","ownerKind":"Class","ownerName":"AbstractRepeater","id":1398},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"removeAllViews","ownerKind":"Class","ownerName":"AbstractRepeater","id":1399},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"removeView","ownerKind":"Class","ownerName":"AbstractRepeater","id":1400},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"removeViews","ownerKind":"Class","ownerName":"AbstractRepeater","id":1401},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"updateBindings","ownerKind":"Class","ownerName":"AbstractRepeater","id":1402},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"view","ownerKind":"Class","ownerName":"AbstractRepeater","id":1403},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"viewCount","ownerKind":"Class","ownerName":"AbstractRepeater","id":1404},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"views","ownerKind":"Class","ownerName":"AbstractRepeater","id":1405},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"ArrayRepeatStrategy","id":1406},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"getCollectionObserver","ownerKind":"Class","ownerName":"ArrayRepeatStrategy","id":1407},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceChanged","ownerKind":"Class","ownerName":"ArrayRepeatStrategy","id":1408},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceMutated","ownerKind":"Class","ownerName":"ArrayRepeatStrategy","id":1409},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"AttrBindingBehavior","id":1410},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"AttrBindingBehavior","id":1411},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"AttrBindingBehavior","id":1412},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"BindingSignaler","id":1413},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"signals","ownerKind":"Class","ownerName":"BindingSignaler","id":1414},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"signal","ownerKind":"Class","ownerName":"BindingSignaler","id":1415},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"Compose","id":1416},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"model","ownerKind":"Class","ownerName":"Compose","id":1417},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"swapOrder","ownerKind":"Class","ownerName":"Compose","id":1418},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"view","ownerKind":"Class","ownerName":"Compose","id":1419},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"viewModel","ownerKind":"Class","ownerName":"Compose","id":1420},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"Compose","id":1421},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"Compose","id":1422},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"modelChanged","ownerKind":"Class","ownerName":"Compose","id":1423},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"Compose","id":1424},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"viewChanged","ownerKind":"Class","ownerName":"Compose","id":1425},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"viewModelChanged","ownerKind":"Class","ownerName":"Compose","id":1426},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"Compose","id":1427},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"DebounceBindingBehavior","id":1428},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"DebounceBindingBehavior","id":1429},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"DebounceBindingBehavior","id":1430},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"Else","id":1431},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"Else","id":1432},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"Else","id":1433},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"Focus","id":1434},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"attached","ownerKind":"Class","ownerName":"Focus","id":1435},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"detached","ownerKind":"Class","ownerName":"Focus","id":1436},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"handleEvent","ownerKind":"Class","ownerName":"Focus","id":1437},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"valueChanged","ownerKind":"Class","ownerName":"Focus","id":1438},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"Focus","id":1439},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"FromViewBindingBehavior","id":1440},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"HTMLSanitizer","id":1441},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"sanitize","ownerKind":"Class","ownerName":"HTMLSanitizer","id":1442},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"Hide","id":1443},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"Hide","id":1444},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"Hide","id":1445},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"valueChanged","ownerKind":"Class","ownerName":"Hide","id":1446},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"Hide","id":1447},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"If","id":1448},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"condition","ownerKind":"Class","ownerName":"If","id":1449},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"swapOrder","ownerKind":"Class","ownerName":"If","id":1450},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"If","id":1451},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"conditionChanged","ownerKind":"Class","ownerName":"If","id":1452},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"If","id":1453},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"IfCore","id":1454},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"IfCore","id":1455},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"IfCore","id":1456},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"MapRepeatStrategy","id":1457},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"getCollectionObserver","ownerKind":"Class","ownerName":"MapRepeatStrategy","id":1458},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceChanged","ownerKind":"Class","ownerName":"MapRepeatStrategy","id":1459},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceMutated","ownerKind":"Class","ownerName":"MapRepeatStrategy","id":1460},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"NullRepeatStrategy","id":1461},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"getCollectionObserver","ownerKind":"Class","ownerName":"NullRepeatStrategy","id":1462},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceChanged","ownerKind":"Class","ownerName":"NullRepeatStrategy","id":1463},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"NumberRepeatStrategy","id":1464},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"getCollectionObserver","ownerKind":"Class","ownerName":"NumberRepeatStrategy","id":1465},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceChanged","ownerKind":"Class","ownerName":"NumberRepeatStrategy","id":1466},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"OneTimeBindingBehavior","id":1467},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"OneWayBindingBehavior","id":1468},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"Repeat","id":1469},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"items","ownerKind":"Class","ownerName":"Repeat","id":1470},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"key","ownerKind":"Class","ownerName":"Repeat","id":1471},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"local","ownerKind":"Class","ownerName":"Repeat","id":1472},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"value","ownerKind":"Class","ownerName":"Repeat","id":1473},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"addView","ownerKind":"Class","ownerName":"Repeat","id":1474},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"Repeat","id":1475},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"call","ownerKind":"Class","ownerName":"Repeat","id":1476},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"handleCollectionMutated","ownerKind":"Class","ownerName":"Repeat","id":1477},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"handleInnerCollectionMutated","ownerKind":"Class","ownerName":"Repeat","id":1478},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"insertView","ownerKind":"Class","ownerName":"Repeat","id":1479},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"itemsChanged","ownerKind":"Class","ownerName":"Repeat","id":1480},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"matcher","ownerKind":"Class","ownerName":"Repeat","id":1481},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"moveView","ownerKind":"Class","ownerName":"Repeat","id":1482},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"removeAllViews","ownerKind":"Class","ownerName":"Repeat","id":1483},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"removeView","ownerKind":"Class","ownerName":"Repeat","id":1484},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"removeViews","ownerKind":"Class","ownerName":"Repeat","id":1485},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"Repeat","id":1486},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"updateBindings","ownerKind":"Class","ownerName":"Repeat","id":1487},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"view","ownerKind":"Class","ownerName":"Repeat","id":1488},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"viewCount","ownerKind":"Class","ownerName":"Repeat","id":1489},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"views","ownerKind":"Class","ownerName":"Repeat","id":1490},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"RepeatStrategyLocator","id":1491},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"addStrategy","ownerKind":"Class","ownerName":"RepeatStrategyLocator","id":1492},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"getStrategy","ownerKind":"Class","ownerName":"RepeatStrategyLocator","id":1493},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"Replaceable","id":1494},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"Replaceable","id":1495},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"Replaceable","id":1496},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"SanitizeHTMLValueConverter","id":1497},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"toView","ownerKind":"Class","ownerName":"SanitizeHTMLValueConverter","id":1498},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"SelfBindingBehavior","id":1499},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"SelfBindingBehavior","id":1500},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"SelfBindingBehavior","id":1501},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"SetRepeatStrategy","id":1502},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"getCollectionObserver","ownerKind":"Class","ownerName":"SetRepeatStrategy","id":1503},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceChanged","ownerKind":"Class","ownerName":"SetRepeatStrategy","id":1504},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceMutated","ownerKind":"Class","ownerName":"SetRepeatStrategy","id":1505},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"Show","id":1506},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"Show","id":1507},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"Show","id":1508},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"valueChanged","ownerKind":"Class","ownerName":"Show","id":1509},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"Show","id":1510},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"SignalBindingBehavior","id":1511},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Property","apiName":"signals","ownerKind":"Class","ownerName":"SignalBindingBehavior","id":1512},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"SignalBindingBehavior","id":1513},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"SignalBindingBehavior","id":1514},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"inject","ownerKind":"Class","ownerName":"SignalBindingBehavior","id":1515},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"ThrottleBindingBehavior","id":1516},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"ThrottleBindingBehavior","id":1517},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"ThrottleBindingBehavior","id":1518},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"ToViewBindingBehavior","id":1519},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"TwoWayBindingBehavior","id":1520},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"UpdateTriggerBindingBehavior","id":1521},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"UpdateTriggerBindingBehavior","id":1522},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"UpdateTriggerBindingBehavior","id":1523},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Class","apiName":"With","id":1524},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"With","id":1525},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"With","id":1526},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"valueChanged","ownerKind":"Class","ownerName":"With","id":1527},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Interface","apiName":"RepeatStrategy","id":1528},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"getCollectionObserver","ownerKind":"Interface","ownerName":"RepeatStrategy","id":1529},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceChanged","ownerKind":"Interface","ownerName":"RepeatStrategy","id":1530},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Method","apiName":"instanceMutated","ownerKind":"Interface","ownerName":"RepeatStrategy","id":1531},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Constant","apiName":"aureliaHideClassName","id":1532},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Constant","apiName":"lifecycleOptionalBehaviors","id":1533},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"configure","id":1534},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"createFullOverrideContext","id":1535},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"getElementName","id":1536},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"getItemsSourceExpression","id":1537},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"indexOf","id":1538},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"injectAureliaHideStyleAtBoundary","id":1539},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"injectAureliaHideStyleAtHead","id":1540},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"isOneTime","id":1541},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"unwrapExpression","id":1542},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"updateOneTimeBinding","id":1543},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"updateOverrideContext","id":1544},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"updateOverrideContexts","id":1545},{"libraryName":"Templating-Resources","libraryHref":"docs/api/templating-resources","apiKind":"Function","apiName":"viewsRequireLifecycle","id":1546},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Class","apiName":"RouteHref","id":1547},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"attributeChanged","ownerKind":"Class","ownerName":"RouteHref","id":1548},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"RouteHref","id":1549},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"processChange","ownerKind":"Class","ownerName":"RouteHref","id":1550},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"unbind","ownerKind":"Class","ownerName":"RouteHref","id":1551},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Class","apiName":"RouterView","id":1552},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Property","apiName":"element","ownerKind":"Class","ownerName":"RouterView","id":1553},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Property","apiName":"layoutModel","ownerKind":"Class","ownerName":"RouterView","id":1554},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Property","apiName":"layoutView","ownerKind":"Class","ownerName":"RouterView","id":1555},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Property","apiName":"layoutViewModel","ownerKind":"Class","ownerName":"RouterView","id":1556},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Property","apiName":"swapOrder","ownerKind":"Class","ownerName":"RouterView","id":1557},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"bind","ownerKind":"Class","ownerName":"RouterView","id":1558},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"created","ownerKind":"Class","ownerName":"RouterView","id":1559},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"process","ownerKind":"Class","ownerName":"RouterView","id":1560},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"swap","ownerKind":"Class","ownerName":"RouterView","id":1561},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Class","apiName":"RouterViewLocator","id":1562},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"findNearest","ownerKind":"Class","ownerName":"RouterViewLocator","id":1563},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Class","apiName":"TemplatingRouteLoader","id":1564},{"libraryName":"Templating-Router","libraryHref":"docs/api/templating-router","apiKind":"Method","apiName":"loadRoute","ownerKind":"Class","ownerName":"TemplatingRouteLoader","id":1565},{"libraryName":"Testing","libraryHref":"docs/api/testing","apiKind":"Function","apiName":"configure","id":1566}]}}