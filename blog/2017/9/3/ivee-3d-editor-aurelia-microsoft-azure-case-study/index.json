{"name":"Case Study: Ivee 3D Editor - Aurelia+Azure+ASP.NET+Redux+ThreeJS","description":"Today, I'm pleased to introduce you to Daniel Radu. Dan is a member of our Aurelia community who has been building some pretty awesome stuff by combining Aurelia [http://aurelia.io] with Microsoft Azure [https://azure.microsoft.com]. I'll let Dan tell you about his experiences, in his own words...","author":{"name":"AureliaEffect"},"links":{"static":"blog/2017/9/3/ivee-3d-editor-aurelia-microsoft-azure-case-study","html":"blog/2017/9/3/ivee-3d-editor-aurelia-microsoft-azure-case-study/index.html","fragment":"blog/2017/9/3/ivee-3d-editor-aurelia-microsoft-azure-case-study/index-fragment.html","self":"blog/2017/9/3/ivee-3d-editor-aurelia-microsoft-azure-case-study/index.json"},"content":"\nToday, I'm pleased to introduce you to Daniel Radu. Dan is a member of our Aurelia community who has been building some pretty awesome stuff by combining [Aurelia](http://aurelia.io) with [Microsoft Azure](https://azure.microsoft.com). I'll let Dan tell you about his experiences, in his own words...\n\n[Ivee 3d Editor](http://editor.ivee.tech) is an online editor which allows the creation of beautiful 3D presentations. It provides features like adding various 3D objects - cubes, spheres, torus, etc., configuring materials, textures, shaders, providing animations, tweening etc.\n\n![Ivee 3D Editor](/content/images/2017/08/1.png)\n\nIn the following article I'm going to explain a bit about the internals of the editor and my journey of building Ivee using Aurelia and ThreeJS.\n\nOn the server-side, Ivee 3D Editor uses a .NET Web API with a SQL Server database to store user authentication information. The editor output is stored as a JSON file on the server, in a dedicated user space. The database and web application is hosted on [Microsoft Azure](https://azure.microsoft.com).\n\n## Why Aurelia?\n\nI started working on Ivee on Dec 2016. It was a pet project, and I couldn't afford to dedicate a lot of time, only nights and weekends. My regular job is full stack .NET developer and the frontend framework I'm using at work is Angular. That means I didn't have much experience (even knowledge, to be honest) with Aurelia.\n\nI came across Aurelia by talking to my friend Dragos, who was disappointed by Angular and its awkward syntax - which I never liked myself. He started exploring Aurelia and I was interested to learn how to use it as well. I thought learning another framework would be beneficial to my technical knowledge.\n\nAt that time, my thought was that if things are not working well with Aurelia, I can always go back to Angular.\n\n## Choosing Aurelia CLI\n\nSo I started looking at Rob's video on [aurelia.io](http://aurelia.io) and from the first go I was impressed with the simplicity and naturalness of Aurelia. I installed [Aurelia CLI](https://github.com/aurelia/cli) and in 10 minutes I had a fully running application, with routing, components, data binding and output events. From that point, I had no doubt about my choice, even though I had a little fear that along the way I will encounter difficulties. With this in mind, I set my expectation that my plans to integrate legacy or non-Aurelia libraries might not work as smoothly as I would like. \n\nLater on, it turned out that this is one of the features that sets Aurelia apart - the ease of integrating almost everything with Aurelia without spending hours and hours of research and bug chasing. \n\n## Integrating ThreeJS (and other libraries)\n\nAfter setting up the app component and the routes, which was a breeze, I must say, my next concern was how I could integrate [ThreeJS](https://threejs.org/). I was pretty familar with the library, as I had tried various JavaScript experiments, but never using TypeScript and Aurelia. After digging a little bit, I found that there was already an [npm package for ThreeJS](https://www.npmjs.com/package/three). I installed it and I checked the Aurelia documentation about how to [configure libraries](http://aurelia.io/hub.html#/doc/article/aurelia/framework/latest/the-aurelia-cli/10). In no time, I learned how to modify the *aurelia.json* file to include the client libraries and I had my little three js scene up and running - the little rotating cube at the XYZ axis that's on the Ivee 3D Editor [home page](http://editor.ivee.tech).\n\nThe configuration for ThreeJS in my *aurelia.json* file looks like this:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    {\n      \"name\": \"three\",\n      \"path\": \"../node_modules/three/build\",\n      \"main\": \"three\"\n    },\n  </source-code>\n</code-listing>\n\n> Note: The Aurelia CLI can automatically install and configure most libraries, but you can always do it manually, as shown above.\n\nThe usage in the component is trivial:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import * as THREE from 'three';\n    \n    export class Viewer {\n      private selectedObj: THREE.Object3D = null;\n      protected w: WglUtil = new WglUtil();\n      private clock: THREE.Clock = new THREE.Clock();\n    \n      private onDocumentMouseDown(e) {\n        this.w.dndMouseDown(e);\n        this.selectedObj = this.w.dndSelectedObject;\n    \n        if (this.selectedObj) {\n          let obj: Iv3dObject = <Iv3dObject>this.selectedObj.userData;\n          console.log(obj);\n        }\n      }\n    \n      public animate() {\n        let elapsedTime = this.clock.getElapsedTime();\n        console.log(elapsedTime);\n      }\n    }\n  </source-code>\n</code-listing>\n\nOther libraries I'm using:\n\n* [OrbitControls](https://www.npmjs.com/package/three-orbitcontrols) - user interaction with the presentation via mouse and touch;\n* [dat.GUI](https://www.npmjs.com/package/dat-gui) - a quick and easy to use GUI to configure properties;\n* [expr-eval](https://www.npmjs.com/package/expr-eval) - a JavaScript expression evaluator;\n* [tween.js](https://www.npmjs.com/package/tween.js) - a tweening engine for simple animations;\n* [threeleapcontrols](https://www.npmjs.com/package/threeleapcontrols) - a package for [VR Leap Motion](https://www.leapmotion.com/) integration;\n* [three-stereo-effect](https://www.npmjs.com/package/three-stereoeffect) - stereo effect for VR visualization;\n* [three-anaglypheffect](https://www.npmjs.com/package/three-anaglypheffect) - effect for 3D Anaglyph visualization;\n* [three-asciieffect](https://www.npmjs.com/package/three-asciieffect) - effect for ASCII visualization.\n\n\n## Authentication\n\nAuthentication is a tricky part of single-page applications which use routes. You want to have authenticated pages, like user settings, as well as pages with anonymous access like home page, login, and signup pages. Aurelia helps a lot with its very own **setRoot** method which can be called conditionally:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    let userSvc: UserService = aurelia.container.get(UserService);\n    let url = window.location.href;\n    let noAuthPages: string[] = ['home', 'editor', 'viewer', 'login', 'signup'];\n    let isNoAuth = noAuthPages.filter(item => url.indexOf(item) >= 0).length > 0;\n      \n    aurelia.start().then(() => {\n      if (userSvc.isAuthenticated || isNoAuth) {\n        aurelia.setRoot('app');\n      } else {\n        aurelia.setRoot('./components/pages/login-page/login-page');\n      }\n    });\n  </source-code>\n</code-listing>\n\nOn the server side I use token authentication using [ASP.NET Identity Framework](https://www.asp.net/identity). The token is passed with every authenticated call. On the client side, the token is stored in the browser's local storage, managed by the **UserService** service class.\n\n## Data\n\nIntegrating data with Aurelia was really easy and I loved that there are options to either use Fetch API, using *aurelia-fetch-client* or XMLHttpRequest API using *aurelia-http-client*. Preferable is Fetch [HttpClient](http://aurelia.io/hub.html#/doc/api/aurelia/fetch-client/latest/class/HttpClient), however, for compatibility reasons, you can use the *xhr* plugin.\n\n[Dependency Injection](http://aurelia.io/hub.html#/doc/article/aurelia/dependency-injection/latest/dependency-injection-basics/1) works nicely with Aurelia and you can easily swap one plugin with another. I started with [*xhr*](https://github.com/aurelia/http-client), but later on I moved to fetch client with minimal changes.\n\nHere is a sample code from my data service:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    @inject(HttpClient, UserService)\n    export class DataService {\n      constructor(private httpClient: HttpClient, private userSvc: UserService) { }\n    \n      loadData(url: string, addToken?: boolean) {\n        let headers: Headers = new Headers();\n    \n        if (addToken) {\n          headers.append('Authorization', `Bearer ${this.userSvc.token}`);\n        }\n    \n        return this.httpClient.fetch(url, {\n          credentials: 'include',\n          headers: headers\n        }).then(response => {\n          return this.handleResponse(response);\n        });\n      }\n    }\n  </source-code>\n</code-listing>\n\n## Forms\n\nI use forms in for user authentication (login, signup) and user space management (a feature where user can upload, rename, delete, download files, create, rename, delete folders). The two-way binding for controls is natural in Aurelia and you don't need to do anything special. \n\nHow neat and tidy is this template, when you tell Aurelia to bind the **userName** property to your input and apply validation:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    <div>\n      <label for=\"user\">Username</label>\n      <input type=\"text\" name=\"user\" value.bind=\"userName & validate\">\n    </div>\n  </source-code>\n</code-listing>\n\nValidation, which is a must when working with forms, was very easy to integrate thanks to the *aurelia-validation* plugin.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    aurelia.use\n      .plugin('aurelia-validation')\n  </source-code>\n</code-listing>\n\nThe validation rules are simply added to the component early, somewhere in the constructor or **attached** hook. I really like the fluent validation API:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    ValidationRules\n      .ensure((m: LoginPage) => m.userName).displayName(\"Username\").required()\n      .ensure((m: LoginPage) => m.password).displayName(\"Password\").required()\n      .on(this);\n  </source-code>\n</code-listing>\n\nThen use **ValidationController** to apply the rules by calling the **validate** method which returns a promise:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    this.validationController\n      .validate()\n      .then(result => {\n        if (result.valid) {\n          this.loginError = false;\n          this.loginErrorMessage = null;\n          this.login();\n        } else {\n          this.loginError = true;\n          this.loginErrorMessage = 'Validaton error(s):';\n    \n          for (let error of this.validationController.errors) {\n            this.loginErrorMessage += error.message + ' ';\n          }\n        }\n      });\n  </source-code>\n</code-listing>\n\nIt can't be any cleaner than this.\n\n## Using Redux\n\nGiven the fact that most of the user work is performed on the client side, I wanted to have a proper way to manage state in Ivee 3D Editor. One great pattern for managing application state is [Redux](http://redux.js.org/docs/introduction/). \n\nHaving used Redux in Angular 2, I was familiar with the patterns: actions, reducers, state, stores, effects, etc. However, Angular 2 takes advantage of [ngrx](https://github.com/ngrx) library which does a lot of heavy lifting and returns Observables ready to use by Angular components.\n\nI couldn't find anything similar for Aurelia, however the standard [Redux NPM packages](https://www.npmjs.com/package/redux) works without any issue. I spent a bit of time - one user story, about the whole 2 week sprint - to integrate the packages and create my own functionality for loading and saving editor data as JSON files, but it was really worth it.\n\nThe Redux configuration in the *aurelia.json* file looks as follows (redux thunk is used for middleware associated with asynchronous calls, like Ajax or Fetch calls):\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    {\n      \"name\": \"redux\",\n      \"path\": \"../node_modules/redux/dist\",\n      \"main\": \"redux.min\"\n    },\n    {\n      \"name\": \"redux-thunk\",\n      \"path\": \"../node_modules/redux-thunk/dist\",\n      \"main\": \"redux-thunk.min\"\n    }\n  </source-code>\n</code-listing>\n\nAn example for load data [actions](http://redux.js.org/docs/basics/Actions.html):\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export class DataMgrActions {\n      static actionTypes = {\n        LOAD_DATA: 'LOAD_DATA',\n        LOAD_DATA_SUCCESS: 'LOAD_DATA_SUCCESS',\n        LOAD_DATA_FAIL: 'LOAD_DATA_FAIL',\n      }\n    \n      constructor(private dataSvc: DataService, private userSvc: UserService) { }\n    \n      // action creators\n      loadData = (fileName: string) => {\n        return {\n          type: DataMgrActions.actionTypes.LOAD_DATA,\n          payload: fileName\n        };\n      };\n    \n      loadDataSuccess = (data: DataModel) => {\n        return {\n          type: DataMgrActions.actionTypes.LOAD_DATA_SUCCESS,\n          payload: data\n        };\n      };\n    \n      loadDataError = (error) => {\n        return {\n          type: DataMgrActions.actionTypes.LOAD_DATA_FAIL,\n          payload: error\n        };\n      };\n    \n      loadDataSvc = (fileName: string) => {\n        return (dispatch, getState) => {\n          dispatch(this.loadData(fileName));\n          return dispatch(() => {\n            return this.dataSvc.loadFile(fileName)\n              .then((response: any) => {\n                let result: SvcResponse = <SvcResponse>response;\n                if (result.result) {\n                  return dispatch(this.loadDataSuccess(result.data));\n                } else {\n                  let error = new Error(result.message);\n                  return dispatch(this.loadDataError(error));\n                }\n              }).catch((error) => {\n                return dispatch(this.loadDataError(error))\n              });\n            });\n          };\n        };\n      }\n  </source-code>\n</code-listing>\n\nThe load data [reducers](http://redux.js.org/docs/basics/Reducers.html):\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export class DataMgrState {\n      data: DataModel = null;\n      isError: boolean = false;\n      error: any = null;\n      actionState: ActionState = ActionState.none;\n    }\n    \n    const initialState: DataMgrState = {\n      data: null, isError: false, error: null, actionState: ActionState.none\n    }\n    \n    export function dataMgr(state: DataMgrState = initialState, action: IvAction) {\n      switch (action.type) {\n        case actions.DataMgrActions.actionTypes.LOAD_DATA:\n          return <DataMgrState>{\n            data: action.payload.data,\n            actionState: ActionState.pending\n          };\n        case actions.DataMgrActions.actionTypes.LOAD_DATA_SUCCESS:\n          return <DataMgrState>{\n            data: action.payload,\n            actionState: ActionState.completed\n          };\n        case actions.DataMgrActions.actionTypes.LOAD_DATA_FAIL:\n          return <DataMgrState>{\n            data: null,\n            isError: true,\n            error: action.payload,\n            actionState: ActionState.completed\n          };\n        default:\n          return state;\n      }\n    }\n  </source-code>\n</code-listing>\n\nI separated my components into container and presentation components. The containers are dealing with the store, despatching actions and handling responses, whereas the presentation components simply get data and output events to their parents, following the unbeatable one-way data flow pattern.\n\nHere is an example of my *editor-page* component which is the parent of the main 3D editor:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export class EditorPage {\n      fileName: string;\n      data: DataModel;\n    \n      store: Store<DataMgrState> = createStore(dataMgr,\n        applyMiddleware(\n          thunk // lets us dispatch() functions\n        )\n      );\n    \n      private dataMgrActions: DataMgrActions;\n      private actionState: ActionState = ActionState.none;\n    \n      constructor(private ea: EventAggregator,\n        private dialogService: DialogService,\n        private router: Router,\n        private dataSvc: DataService,\n        private userSvc: UserService\n        ) {\n          this.dataMgrActions = new DataMgrActions(this.dataSvc, this.userSvc);\n      }\n    \n      activate(params) {\n        this.fileName = params.fn; // from route\n      }\n    \n      private loadFile() {\n        if (this.fileName) {\n          this.actionState = ActionState.pending;\n          this.store.dispatch(this.dataMgrActions.loadDataSvc(this.fileName)).then(() => {\n            let state: DataMgrState = <DataMgrState>this.store.getState();\n            this.actionState = state.actionState;\n            if (state.isError) {\n              console.log(state.error);\n              this.raiseOnError(state.error);\n            } else {\n              this.data = state.data;\n            }\n          });\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n\nThis is the corresponding HTML template, where the **data** property (of **DataModel** type) is passed as input to the presentation component **editor**:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    <template>\n      <require from=\"../../editor/editor\"></require>\n      <editor data.bind=\"data\"\n              save-data.call=\"saveData(data)\"\n              changed.call=\"editorChanged(data)\"></editor>\n    </template>\n  </source-code>\n</code-listing>\n\nAs usual, there are lots of shades of gray, and, depending on how complex your application is, soon you realise that input data and output events in a component structure of more than three levels is hard to follow, debug and maintain. But don't despair, the smart people behind Aurelia thought of that too and they introduced the [Event Aggregator](https://github.com/aurelia/event-aggregator) which is a beautiful implementation of a well-known pattern. Used wisely, the event aggregator is a powerful tool which can make your code really tidy and easy to understand and maintain.\n\nFor example, to manage errors in a central location in your app, you can use Redux and that works nicely. However, using the Event Agreggator you can publish a custom error (applicable at every component level) and let a central component (like **App**) handle it. \n\nA quick example is how I check if WebGL is enabled:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    if (!WglUtil.detectWebGL()) {\n      this.ea.publish(CustomEventNames.APP_ERROR, { message: 'Your browser doesn\\'t support WebGL.' });\n    }\n  </source-code>\n</code-listing>\n\nIn the root component, *app.ts*, I subscribe to my error custom event. Then I use a simple dismissable popup component to display the error message to the user:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    this.appErrorSubscr = this.eventAggregator.subscribe(CustomEventNames.APP_ERROR, payload => {\n      this.showError = true;\n      this.errorMessage = payload.message;\n    });\n  </source-code>\n</code-listing>\n\nThe property **errorMessage** is passed in the template to the **error** component:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    <require from=\"./components/error/error\"></require>\n    <iv-3d-error show-error.bind=\"showError\" error-message.bind=\"errorMessage\"></iv-3d-error>\n  </source-code>\n</code-listing>\n\nTo avoid memory leaks, I always dispose the subscription in the **detached** hook:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    detached() {\n      this.appErrorSubscr.dispose();\n    }\n  </source-code>\n</code-listing>\n\n## Dynamic Content\n\nIvee 3D Editor is able to display HTML content in configurable panels. My intention was to leverage the power of HTML in the presentations created using the editor. To be honest, I was prepared to leave this feature out, thinking it might be difficult to integrate dynamic content in a component. Aurelia came to my rescue though, and this was an eye opener for how powerful Aurelia is. Behind its simplicity there are a lot of complex features which developers can reuse and take advantage of. After checking the documentation and after digging in a few Stack Overflow questions, I found that there is a neat way to override the view strategy of a component. \n\nThis is the code of my **ContentPanel** component which uses the **ViewCompiler** service to create the component view at runtime, based on content provided by a custom model (**AdditionalContent**). If you check the code, there is a binding context hooked into the view, which means that even after the initial creation, the view will be updated if the content changes, as it happens with a normal, static template. These features are out of the box, without installing any additional plugin, 3rd party library or framework! I love Aurelia, because things just work! \n\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    import {inject, noView, ViewCompiler, ViewSlot, Container, ViewResources, bindable} from 'aurelia-framework';\n    \n    import { AdditionalContent } from '../../models/additional-content';\n    \n    @noView\n    @inject(ViewCompiler, ViewSlot, Container, ViewResources)\n    export class ContentPanel {\n      private viewCompiler: ViewCompiler;\n      private viewSlot: ViewSlot;\n      private container: Container;\n      private resources: ViewResources;\n      private bindingContext = {\n        content: new AdditionalContent()\n      };\n    \n      @bindable content: AdditionalContent;\n    \n      constructor(vc, vs, container, resources) {\n        this.viewCompiler = vc;\n        this.viewSlot = vs;\n        this.container = container;\n        this.resources = resources;\n      }\n    \n      reloadView(content: AdditionalContent) {\n        let template = `\n    <template>\n        <div class=\"panel panel-default\" id.bind=\"content.name\" css.bind=\"content.css\" show.bind=\"content.showFlag\">\n            <div class=\"panel-heading\">\n                <h3 class=\"panel-title pull-left\" inner-text.bind=\"content.title\"></h3>\n                <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\" click.trigger=\"content.hide()\"><span aria-hidden=\"true\">&times;</span></button>\n                <div class=\"clearfix\"></div>\n            </div>\n            <div class=\"panel-body iv-3d-content-panel-body\" innerhtml.bind=\"content.content | sanitizeHTML\">\n            </div>\n        </div>\n    </template>`;\n        content.hide = () => {\n          this.content.showFlag = false;\n        };\n    \n        content.show = () => {\n          this.content.showFlag = true;\n        };\n    \n        this.bindingContext = {\n          content: content\n        };\n    \n        let viewFactory = this.viewCompiler.compile(template, this.resources);\n        let view = viewFactory.create(this.container);\n        view.bind(this.bindingContext);\n        this.viewSlot.add(view);\n        this.viewSlot.attached();\n      }\n    \n      contentChanged(newValue: AdditionalContent) {\n        if (newValue) {\n          this.reloadView(newValue);\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n\nYou can see the dynamic content panels in action in my [Aurelia presentation](http://editor.ivee.tech/#/viewer?d=1&fn=aurelia.json), created using Ivee. Click on the topics on the left and you can see the coresponding panel opening.\n\nAnother win, I wanted to provide the user with a nice HTML editing experience and I looked for a nice HTML editor that I could integrate. I chose [squire-rte](https://github.com/neilj/Squire). It almost goes without saying: to integrating the Squire editor was as easy as 1-2-3...\n\n![HTML Editor](/content/images/2017/08/2.png)\n\n## Exposing Viewer API\n\nI always liked extensibility. The thought of exposing your own object model to the developer is fascinating. With Aurelia and TypeScript / ES6, I found that this is actually possible, providing you have designed a nice component structure and a properly written API. Ivee 3D Editor has two major features: the editor and the viewer. The editor is the tool that allows the users to create presentations, by adding objects, setting properties, creating animation timelines, etc. and the viewer is the tool that puts all the presentation parts together and executes them.\n\nBut what if you want to interact with the presentation at runtime? No problem, Aurelia and TypeScript / ES6 work for you. The current instance of the **Viewer** type is available for scripting, using plain JavaScript:\n\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    private evaluateInitScripts() {\n      if (!this.data.script) {\n        return;\n      }\n    \n      try {\n        let scriptCode: string = `\n    var viewer;\n    ${this.data.script.init ? this.data.script.init : ''}\n    `;\n    \n        this.createScript(scriptCode);\n      } catch (e) {\n        console.log('Init script creation failed. Check the error: ', e);\n      }\n    \n      try {\n        this.createScript(this.data.script.update);\n      } catch (e) {\n        console.log('Update script creation failed. Check the error: ', e);\n      }\n    \n      try {\n        let scriptCode: string = `\n    viewer = this; // this line exposes the viewer for runtime use\n    ${this.data.script.execInit ? this.data.script.execInit : ''}\n    `;\n    \n        if (this.runExecInit) {\n          let fn = new Function(scriptCode);\n          fn.call(this);\n        }\n      } catch (e) {\n        console.log('Init script evaluation failed. Check the error: ', e);\n      }\n    }\n  </source-code>\n</code-listing>\n\nAdmittedly, exposing the API opens the door to vulnerabilities, but in my case, the **Viewer** only provides access to the presentation runtime objects. Examples of **Viewer** methods and properties that can be used at runtime:\n\n* ```data: DataModel``` - the presentation data object model;\n* ```w: WglUtil``` - an instance of the **WglUtil** class, which contains a set of helper functions for ThreeJS;\n* ```findObjectById(uuid: string)``` - finds a presentation object by its unique identifier;\n* ```findObjectByName(name: string)``` - finds a presentation object by its unique identifier;\n* ```find3dObjectById(uuid: string)``` - finds a 3D object by its unique identifier;\n* ```find3dObjectByName(name: string)``` - finds a 3D object by its name.\n\n\nJust as a quick test, I used this feature to create a panoramic image for the Aurelia presentation (this code is executed at runtime, when the presentation is loaded):\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    function addSkyBox() {\n      var cfg = {\n        srcFile: 'http://localhost/Iv3DEditorApi/data/ivusers/demo@ivee.tech/av8Rgdveqz/images/skyboxsun5deg2.png',\n        size: 1024 \n      };\n    \n      viewer.w.addSkyBoxFromFile(cfg, viewer.mainGroup);\n    }\n    \n    addSkyBox();\n  </source-code>\n</code-listing>\n\n![Presentation modified at runtime](/content/images/2017/08/3.png)\n\n## Conclusion\n\nThe Ivee 3D Editor is still in alpha. It has many features, timelines, tweening, data sources, shaders, but it's still rough and needs a lot of refining. However, I think that for a one man job outside working hours, it is a pretty good achievement. All these features would have been much more painful to implement without Aurelia. \n\nAurelia is beautiful because it doesn't get in your way; it guides you to do things then goes on the side, admitting that you need to focus on your business. It helps and it doesn't ask for anything in return. It is your quiet and supportive friend always close to you during your journey, ensuring that you have all the resources necessary to climb the highest peaks.\n\nWe live in amazing times, where dreams get closer and closer to reality. Our job now is much simpler than before - we only need to learn and use these wonderful gems that people like the Aurelia team create. Aurelia is a gem that doesn't have a huge learning curve and the time invested to learn it is returned a thousandfold. If I had to add my own motto for Aurelia, it would be as simple as this: \"Aurelia - let amazing things happen\"."}