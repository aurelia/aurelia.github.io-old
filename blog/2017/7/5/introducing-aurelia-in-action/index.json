{"name":"Introducing Aurelia in Action","description":"Aurelia in Action [https://www.manning.com/books/aurelia-in-action] is a book targeted at teaching you what you need to build compelling, real-world applications in Aurelia from the ground up. The book centres around a fictional virtual bookshelf application (similar to Goodreads.com [https://www.goodreads.com/]) called my-books. We start off by creating a bare-bones application via the Aurelia CLI, then progressively layer on various features that users would want in a virtual bookshelf. By the end of the book we've built out a fully fledged SPA, giving you the chance to familiarise yourself with the many tools available in Aurelia's tool-belt along the way. Save 45% off Aurelia in Action [https://www.manning.com/books/aurelia-in-action] with discount code aureliash at Manning.com [https://www.manning.com/] today!","author":{"name":"AureliaEffect"},"links":{"static":"blog/2017/7/5/introducing-aurelia-in-action","html":"blog/2017/7/5/introducing-aurelia-in-action/index.html","fragment":"blog/2017/7/5/introducing-aurelia-in-action/index-fragment.html","self":"blog/2017/7/5/introducing-aurelia-in-action/index.json"},"content":"\n[Aurelia in Action](https://www.manning.com/books/aurelia-in-action) is a book targeted at teaching you what you need to build compelling, real-world applications in Aurelia from the ground up. The book centres around a fictional virtual bookshelf application (similar to [Goodreads.com](https://www.goodreads.com/)) called my-books. We start off by creating a bare-bones application via the Aurelia CLI, then progressively layer on various features that users would want in a virtual bookshelf. By the end of the book we've built out a fully fledged SPA, giving you the chance to familiarise yourself with the many tools available in Aurelia's tool-belt along the way. Save 45% off [Aurelia in Action](https://www.manning.com/books/aurelia-in-action) with discount code `aureliash` at [Manning.com](https://www.manning.com/) today!\n\nSome of areas covered include:\n\n* Binding\n* Templating\n* Custom attributes\n* Custom elements\n* Value converters\n* Binding behaviours\n* Working with HTTP\n* Routing\n* Working with forms\n* Inter-component communication patterns \n* Deployment\n\nIn this blog post we'll take a sneak peek at some of the topics covered in Chapter 7 - Working with Forms. \n\n# Working with Forms in Aurelia\n\nForms are one of the primary ways that users interact with your website. Well-implemented forms make users happy. Conversely, poorly implemented forms can slow down or stop user's activity on your site. You can address two of the main aspects of well-built  forms using Aurelia’s data-binding and validation components. Data-binding can be used to provide rapid feedback, guiding the user on the correct form journey by making their next action obvious. Validation can be used to show users the feedback they need to submit the form in a way that’s unobtrusive and avoids breaking user flow. \n\nOne of the pages in the my-books application provides users with the ability to add new books to their bookshelf. In this blog post we'll look at how to add form validation with [Bootstrap 4](https://v4-alpha.getbootstrap.com/) and the [aurelia-validation](https://github.com/aurelia/validation) plugin to ensure that users provide valid values for the book title, and times-read input fields. You can see a screenshot of this form below:\n![my-books form ](https://sean-hunter.io/wp-content/uploads/2017/07/Figure_1.1.png)\n\nFeel free to have a poke around with the source code and check out the running application on GistRun https://gist.run/?id=c9c19fbe1e147fc39ac864cf0b694fd1.\n\n# Validation\n\nThe Aurelia validation plugin allows you to apply validation to view-model fields bound to input elements in the view. It’s built with the Aurelia architecture in mind, and because of this, it fits hand in glove with Aurelia’s binding and templating engine. There are many validation libraries out there, and if you have a favorite library, it’s easy enough to wire it in. The advantage you get with the Aurelia validation plugin is its ease of use within the Aurelia framework. We'll only be able to scratch the surface of what the validation plugin has to offer here. If you are interested in reading more you can check out Jeremy Danyow's great in-depth article on the [Aurelia Hub](http://aurelia.io/hub.html#/doc/article/aurelia/validation/latest/validation-basics/5).\n\nTo implement validation in our form we'll need five main components:\n\n1. The **validation controller** to orchestrate the entire process\n2. A **view-model** to validate\n3. Some **validation rules** that will be applied to the title, times-read view-model properties\n4. A **validation renderer** to render the results to the view\n5. A **view** to trigger validation and display results\n\n## Validation Controller\n\nThe `ValidationController` is a component of the Aurelia validation plugin. Each view-model that requires validation has one or more mapped validation controllers. Validation controllers are orchestrators, responsible for receiving validation triggers (such as an input change or blur event) and responding to these triggers by applying the relevant validation feedback to the view via a validation renderer. \n\nThe add-book page consists of a main component `edit-book` which sits as a custom element inside the main `app` component. The first step to adding validation to this form is to inject a new `ValidationController` instance using the `NewInstance` class. The `NewInstance` resolver allows us to inject an instance specific to this view-model, overriding the default dependency injection behavior of singleton within a container. \n\n## Validation Renderer\n\nBecause we want to render the validation results using Bootstrap styles, the next step is to implement a validation renderer which you can see in this [Gist](https://gist.github.com/freshcutdevelopment/c9c19fbe1e147fc39ac864cf0b694fd1#file-bootstrap-form-renderer-js). The validation renderer is a component of the Aurelia validation plugin that is responsible for rendering validation results to the view. The plugin provides an implementation of this component out of the box, the `validation-errors` attribute. This custom attribute can be applied to an element and makes all validation errors associated with the element available to both the element and its decedents. \n\nYou can then use markup in the view to display validation results to users. Alternatively, you can implement your own custom validation renderer (as we do in this case). This is useful if you want to avoid muddying the view markup with validation display code and when you have a specific style that should be applied. For example, you can implement a Bootstrap validation renderer to show validation results in a Bootstrap style, or a [Materialize](http://materializecss.com/) validation renderer to show validation results in a material design style, and so on. This is my preferred approach to validation, because it keeps the validation display code separated from the main view. With the validation renderer created we need to register it with the validation controller `this.controller.addRenderer(new BootstrapFormRenderer())`.\n\n## Validation Rules\n\nValidation rules allow you to apply various constraints to view-model properties. They can be applied either to simple values (such as a string), or to an entire object. Several built-in validation rules come along with the Aurelia framework. In this case we'll use a combination of 3 validation rules to validate two input fields:\n\n* **title** : Required validation rule.\n* **timesRead** : Required validation rule, and custom validation rule to ensure that the user specifies a number which is either 0, or a positive integer. The validation rules will be applied as follows:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    ValidationRules\n      .ensure('title').required() //ensure title provided\n      .ensure('timesRead').required()  //ensure user specifies a value for times-read\n      .satisfiesRule('positiveInteger') //validate the positiveInteger custom rule\n      .on(this); //apply validation rules to the current view-model\n  </source-code>\n</code-listing>\n\n## Executing the Validation\n\nWith the plumbing of the validation controller, validation renderer, and validation rules in place, the last step is to configure triggers for when we want to execute the validation rules. While we're on the subject of the view-model, we'll add a validation trigger to execute the validation rules on form submit, and only raise an `added` notification if the validation results return successfully using the validation controller's `validate` method. This method returns a promise to allow to also handle the case where the validation may take some time (for example a server side validation over HTTP):\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n     addBook(){\n        this.controller.validate().then(result => {\n          if(result.valid) this.eventAggregator.publish('book-added');  \n         //publish the book-added event only when the edit-book form is valid.\n        });\n      }\n  </source-code>\n</code-listing>\n\nPutting this all together, the `edit-book` view-model looks like this. There are some elements of this code sample that we won't cover here, but stay tuned as these aspects will be covered in Chapter 7 of Aurelia in Action.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {inject,NewInstance} from 'aurelia-framework'; //import the new instance class\n    import {EventAggregator} from 'aurelia-event-aggregator'; \n    import {BooksApi} from 'books-api';\n    import {BootstrapFormRenderer} from 'bootstrap-form-renderer'; //import the validation renderer\n    import {ValidationRules, ValidationController} from 'aurelia-validation'; //import the validation rules and controller\n    \n    @inject(EventAggregator, BooksApi, NewInstance.of(ValidationController)) \n    //inject a new instance of the validation controller\n    export class BookForm {\n      constructor(eventAggregator, bookApi, controller) {\n        this.title = \"\";\n        this.eventAggregator = eventAggregator; \n        this.bookApi = bookApi;\n        this.controller = controller;\n        this.controller.addRenderer(new BootstrapFormRenderer()); //configure the validation renderer\n        this.configureValidationRules(); //configure the validation rules\n        this.createEventListeners();\n      }\n      \n      configureValidationRules() {\n          ValidationRules.customRule( //create the positiveInteger validation rule\n          'positiveInteger',\n          (value, obj) => value === null || value === undefined \n            || (Number.isInteger(value) || value >= 0),\n          `Books can only be read 0 or more times.` \n          );\n          \n          ValidationRules\n            .ensure('title').required() //ensure title provided\n            .ensure('timesRead').required()  //ensure user specifies a value for times-read\n            .satisfiesRule('positiveInteger') //validate the positiveInteger custom rule\n            .on(this); //apply validation rules to the current view-model\n      }\n      \n      addBook() {\n        this.controller.validate().then(result => { //validate when a book is added\n          if(result.valid) this.eventAggregator.publish('book-added');  \n        });\n      }\n      \n      bind() {\n        this.bookApi.getGenres().then(genres => {\n          this.genres = genres;\n        });\n      }\n      \n      createEventListeners() {\n        this.genreSelectedListener =  e => {\n          if(e && e.detail){\n            this.genre = e.detail.value;  \n          }\n        };\n    \n        this.ratingChangedListener =  e => this.rating = e.rating;\n      }\n      \n      attached() {\n          this.selectGenreElement.addEventListener(\"change\", this.genreSelectedListener );\n          this.selectGenreElement.addEventListener(\"change\", this.ratingChangedListener );\n      }\n      \n      detached() {\n          this.ratingElement.removeEventListener('change', this.ratingChangedListener);\n          this.selectGenreElement.removeEventListener('change', this.genreSelectedListener);\n      }\n    }\n  </source-code>\n</code-listing>\n\n## The Validate Binding Behavior\n\nYou can enroll view elements for validation using the `validate` binding behavior provided by the Aurelia validation plugin. For example, applying validation to an input element is a simple matter of `<input value.bind=\"title & validate\"/>`, which applies the validate binding behavior to the input value binding. \n\nFrom there, the view can take as large a role as you want in the validation process. You can use either the `validation-errors` renderer, which means more validation markup in your view, or a custom validation renderer, which incurs little to no involvement from the view in deciding how the validation results should be displayed to the user. \n\nWith the view-model in place the last step is to wire up validation triggers in the view itself on the relevant input fields as shown in the following code listing.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"typeahead\"></require>\n      <require from=\"star-rating\"></require>\n      <form class=\"form card\" submit.trigger=\"addBook()\">\n        <div class=\"card-block\">\n          <h4 class=\"card-title\">Add book <i class=\"fa fa-book\" aria-hidden=\"true\"></i></h4>\n          <h6 class=\"card-subtitle mb-2 text-muted\">add a book to your bookshelf</h6>\n          <hr/>\n            <div class=\"form-group\">\n              <label for=\"title\">Title</label>\n              <input name=\"title\" class=\"form-control\" \n                     placeholder='enter a title' \n                     value.bind=\"title & validate\"></input> \n                     <!-- validation trigger added to title input field -->\n            </div>\n            <div class=\"form-group\">\n              <label for=\"genre\">Genre</label>\n              <input value.bind=\"genre\" \n                     typeahead=\"items.bind:genres\" \n                     type=\"text\" \n                     name=\"genre\" \n                     class=\"form-control\"\n                     ref=\"selectGenreElement\"></input>\n            </div>\n            <div class=\"form-group\">\n              <label for=\"times-read\">Times read</label>\n              <input name=times-read class=\"form-control\" \n                      value.bind=\"timesRead & validate\"></input> \n                      <!-- validation trigger added to times-read input field -->\n            </div>\n            <hr/>\n            <star-rating \n                  view-model.ref=\"starRatingViewModel\" \n                  ref=\"ratingElement\" \n                  rating.bind=\"rating\">\n           </star-rating>\n          </form>\n        </div>\n       <div class=\"card-footer\">\n          <button type=\"submit\" class=\"btn btn-primary col-sm-3 push-sm-9\" \n                  disabled.bind=\"title.length == 0\">\n            add\n          </button>  \n       </div>\n      </div>\n    </template>\n  </source-code>\n</code-listing>\n\nThis completes our implementation of Bootstrap 4 form validation in the edit-book form. You can see this in action and review the entire source code on [GistRun](https://gist.run/?id=c9c19fbe1e147fc39ac864cf0b694fd1). There are many more goodies hidden away in this form. Check out the [Aurelia in Action website](https://www.manning.com/books/aurelia-in-action) to read more. At the time of writing we are currently under the Early Access Program. You can download the first chapter free, and feedback via either the books forum or the  [GitHub](https://github.com/freshcutdevelopment/Aurelia-in-Action) repository is much appreciated."}