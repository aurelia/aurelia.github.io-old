{"name":"Announcing \"Learning Aurelia\" from Packt Publishing","description":"I'm very pleased to announce that Packt has published Learning Aurelia [https://www.packtpub.com/web-development/learning-aurelia] by long-time Aurelia community member Manuel Guilbault [http://manuelguilbault.com]. In conjunction with the book release, Manuel put together a short excerpt from the book, which I'm sure the whole community will enjoy. Read on to learn more about Aurelia from Manuel and don't forget to pick up your copy today [https://www.packtpub.com/web-development/learning-aurelia].","author":{"name":"AureliaEffect"},"links":{"static":"blog/2017/2/4/announcing-learning-aurelia-from-packt-publishing","html":"blog/2017/2/4/announcing-learning-aurelia-from-packt-publishing/index.html","fragment":"blog/2017/2/4/announcing-learning-aurelia-from-packt-publishing/index-fragment.html","self":"blog/2017/2/4/announcing-learning-aurelia-from-packt-publishing/index.json"},"content":"\nI'm very pleased to announce that Packt has published [Learning Aurelia](https://www.packtpub.com/web-development/learning-aurelia) by long-time Aurelia community member [Manuel Guilbault](http://manuelguilbault.com). In conjunction with the book release, Manuel put together a short excerpt from the book, which I'm sure the whole community will enjoy. Read on to learn more about Aurelia from Manuel and [don't forget to pick up your copy today](https://www.packtpub.com/web-development/learning-aurelia).\n\n---\n\nIn my book [Learning Aurelia](https://www.packtpub.com/web-development/learning-aurelia), you can see, among other things, how to build an image file picker component, supporting drag and drop and showing a preview of the selected image. In this post, we'll use the techniques described in the book to build a multi-select image file picker, also supporting drag and drop, with a gallery-style preview feature.\n\n## Picking Files\n\nLet's start by creating a custom `file-picker` element, which will encapsulate an `<input type=\"file\">` element:\n\n##### resources/elements/file-picker.ts\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    import {customElement, useView, bindable, bindingMode} from 'aurelia-framework';\n    \n    @customElement('file-picker')\n    @useView('./file-picker.html')\n    export class FilePicker {\n    \n      @bindable accept = '';\n      @bindable multiple = false;\n      @bindable({ defaultBindingMode: bindingMode.twoWay }) files: FileList;\n    \n      input: HTMLInputElement;\n    \n      filesChanged() {\n        if (!this.files) {\n          this.clearSelection();\n        }\n      }\n    \n      private clearSelection() {\n        this.input.type = '';\n        this.input.type = 'file';\n      }\n    }\n  </source-code>\n</code-listing>\n\nThis view-model declares three bindable properties:\n\n* `accept`: will be bound to the `input`'s `accept` attribute, which is used\n  to limit the type of files the browser's dialog will show to the user.\n* `multiple`: will be bound to the `input`'s `multiple` attribute, which\n  tells the browser's dialog if it should support selection of multiple files \n  or not.\n* `files`: will be bound to the `input`'s `files` attribute. This property is\n  bound two way by default, so the file(s) selected by the user are assigned\n  back to the bound property.\n\nThe view-model also declares an `input` property, to which the template will\nassign a reference on the `<input type=\"file\">` element.\n\nLastly, since the `input`'s `files` property is read-only and the DOM API doesn't expose a method to clear the `input`'s file selection (other than calling the `reset` method on the whole surrounding `form`), the view-model uses a hack to clear the selected files when an empty value is assigned to the `file-picker`'s `files` property: it sets the `input`'s `type` to an empty string then resets it back to `file`.\n\n##### resources/elements/file-picker.html\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <input type=\"file\" accept.bind=\"accept\" multiple.bind=\"multiple\" \n             files.bind=\"files\" ref=\"input\"\n             style=\"visibility: hidden; width: 0; height: 0;\">\n      <button class=\"btn btn-primary\" click.delegate=\"input.click()\">\n        <slot>Select</slot>\n      </button>\n    </template>\n  </source-code>\n</code-listing>\n\nThe `file-picker`'s template defines an `<input type=\"file\">` element, styled so it is invisible and so it occupies no space in the DOM. Its `accept`, `multiple`, and `files` attributes are also properly bound to their corresponding property on the view-model. Lastly, it assigns a reference on the `input` to the view-model's `input`\nproperty.\n\nThe template also declares a `button` element, styled using Bootstrap's classes. Inside it, there is a default content projection slot, with the *Select* text as its default content. Additionally, the `button`'s `click` event calls the `input`'s `click` method. Thanks to this, the browser's file dialog will show up when the user clicks the button, even though the `input` element is not visible.\n\nThis component basically just replaces the ugly native file picker with a cleaner button.\n\n## Adding a file drop target\n\nNext, let's create a custom attribute allowing to transform any element into a file drag and drop target:\n\n##### resources/attributes/file-drop-target.ts\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    import {customAttribute, bindingMode, autoinject} from 'aurelia-framework';\n    \n    @customAttribute('file-drop-target', bindingMode.twoWay)\n    @autoinject\n    export class FileDropTarget {\n    \n      value: FileList | (({files: FileList}) => void);\n      \n      constructor(private element: Element) {}\n    \n      attached() {\n        this.element.addEventListener('dragover', this.onDragOver);\n        this.element.addEventListener('drop', this.onDrop);\n        this.element.addEventListener('dragend', this.onDragEnd);\n      }\n    \n      private onDragOver = (e) => {\n        e.stopPropagation();\n        e.preventDefault();\n    \n        e.dataTransfer.dropEffect = 'copy';\n      };\n    \n      private onDrop = (e) => {\n        e.stopPropagation();\n        e.preventDefault();\n    \n        if (typeof this.value === 'function') {\n          this.value({ files: e.dataTransfer.files });\n        } else {\n          this.value = e.dataTransfer.files;\n        }\n      };\n    \n      private onDragEnd = (e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        \n        e.dataTransfer.clearData();\n      };\n    \n      detached() {\n        this.element.removeEventListener('dragend', this.onDragEnd);\n        this.element.removeEventListener('drop', this.onDrop);\n        this.element.removeEventListener('dragover', this.onDragOver);\n      }\n    }\n  </source-code>\n</code-listing>\n\nThe attribute's target element will be injected in the view-model's constructor. When the attribute is `attached` to the DOM, it starts listening for the `dragover`, `drop`, and `dragend` events on the target element. When the attribute is `detached` from the DOM, the \nevent listeners are removed.\n\nThe attribute is bound two way by default, so the file(s) assigned to its `value` when a user drops them on the target element are assigned back to the bounded property, if any. However, upon files being dropped on the target element, the view-model checks if the \n`value` is a function or not. This means that the attribute can be used either with the `.bind` command, so the dropped files are assigned to the bound expression, or with the `.call` command, so the bound expression is called and passed the dropped files whenever \na `drop` event occurs.\n\n## Chunking an Array\n\nIn order to display the selected images as a gallery, we'll use Bootstrap's grid system. This means we'll need to break the files array down in chunks, so we can iterate on chunks to render rows, then on each chunk's files to render columns.\n\nThe best way to do this in Aurelia is with a value converter:\n\n##### resources/value-converters/chunk.ts\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    import {valueConverter} from 'aurelia-framework';\n    \n    @valueConverter('chunk')\n    export class Chunk {\n      toView(array: any[], size: number): any[][] {\n        let result = [];\n        let nbChunks = Math.ceil(array.length / size);\n        for (let i = 0; i < nbChunks; ++i) {\n          const offset = i * size;\n          result.push(array.slice(offset, offset + size));\n        }\n        return result;\n      }\n    }\n  </source-code>\n</code-listing>\n\nThe `chunk` value converter expects an array and the chunks' size as its parameter and returns an array of array.\n\n## Displaying a Blob Object as an Image\n\nThe last part we'll need is some way to display a `File` instance inside an `img` element. To do this, we'll leverage the browser's `URL.createObjectURL` function, which takes a `Blob` object as a parameter and returns a special URL leading to this resource. Our \ncustom attribute, which will be used essentially on `img` elements, will be bound to a `Blob` object, will generate an object URL from it, and will assign this URL to the `img` element's `src` attribute.\n\nSome of you might think that a value converter would be a better fit for this type of feature, and I would absolutely agree. A value converter could take as an input a `Blob` object and return the object URL. It could then be used on a binding between an `img` element's `src` attribute and a property containing a `Blob` object.\n\nHowever, in this particular case, each object URL must be released after usage in order to prevent memory leaks, and value converters offer no mechanism to be notified when a value is no longer used. On the contrary, HTML behaviors offer a much richer workflow and a wider set of extension points. That's why we will create a custom attribute instead:\n\n##### resources/attributes/blob-src.ts\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    import {customAttribute, inject} from 'aurelia-framework';\n    \n    @customAttribute('blob-src')\n    @inject(Element)\n    export class BlobSrc {\n    \n      private objectUrl: string;\n    \n      constructor(private element: HTMLImageElement) {}\n    \n      private disposeObjectUrl() {\n        if (this.objectUrl) {\n          this.element.src = '';\n          URL.revokeObjectURL(this.objectUrl);\n          this.objectUrl = null;\n        }\n      }\n    \n      valueChanged(value) {\n        this.disposeObjectUrl();\n    \n        if (value instanceof Blob) {\n          this.objectUrl = URL.createObjectURL(value);\n          this.element.src = this.objectUrl;\n        }\n      }\n    \n      unbind() {\n        this.disposeObjectUrl();\n      }\n    }\n  </source-code>\n</code-listing>\n\n## Bringing It All Together\n\n> Each of the parts we saw up to this point is shown in the book,\n> even though some have been modified to fit the current context.\n\nThe last missing piece is the one that brings everything together: an `image-files-picker` custom element.\n\n##### resources/elements/image-files-picker.html\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <div class=\"jumbotron jumbotron-fluid\" file-drop-target.call=\"add(files)\">\n        <div class=\"container\">\n          <div class=\"text-center\">\n            <p>You can drop image files anywhere inside this area</p>\n          </div>\n          <div class=\"row\" repeat.for=\"row of files | chunk:3\">\n            <div class=\"col-md-4\" repeat.for=\"file of row\">\n              <div class=\"card card-inverse\">\n                <img class=\"card-img img-fluid\"\n                    alt=\"Preview for ${file.name & oneTime}\"\n                    blob-src.one-time=\"file\">\n                <div class=\"card-img-overlay\">\n                  <button type=\"button\" class=\"close\" aria-label=\"Remove\" \n                          click.delegate=\"remove($parent.$index * 3 + $index)\">\n                    <span aria-hidden=\"true\">&times;</span>\n                  </button>\n                  <p class=\"card-text\">\n                    <small class=\"text-muted\">${file.name & oneTime}</small>\n                  </p>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <file-picker accept.bind=\"accept\" multiple.one-time=\"true\" \n                   files.bind=\"selectedFiles\" \n                   change.delegate=\"addSelectedFiles()\">\n        Add\n      </file-picker>\n    </template>\n  </source-code>\n</code-listing>\n\nThe template starts with a `jumbotron` container, which acts as a `file-drop-target`. When files are dragged and dropped on this element, the view-model's `add` method will be called and passed the dropped `files`.\n\nInside this container, the `files` array is rendered on three columns using the `chunk` value converter, each file displayed inside a Bootstrap `card` component. Each `card` displays the file in an `img` element using the `blob-src` attribute, a `button` whose `click` event calls the view-model's `remove` method, and the file's `name`.\n\nLastly, underneath the image gallery, a `file-picker` element allows the user to select image files. The selected files are bound to the view-model's `selectedFiles` property, then the `change` event dispatched by the underlying `<input type=\"file\">` element and bubbling up the DOM triggers a call to the `addSelectedFiles` method. The \n`file-picker`'s default projection slot is also overwritten with the text *Add*.\n\n##### resources/elements/image-files-picker.ts\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    import {customElement, useView, bindable, bindingMode} from 'aurelia-framework';\n    \n    @customElement('image-files-picker')\n    @useView('./image-files-picker.html')\n    export class ImageFilesPicker {\n    \n      @bindable({ defaultBindingMode: bindingMode.twoWay }) files: File[] = [];\n    \n      selectedFiles: FileList;\n    \n      add(files: FileList) {\n        for (let i = 0; i < files.length; ++i) {\n          const file = files.item(i);\n          this.files.push(file);\n        }\n      }\n    \n      remove(index) {\n        this.files.splice(index, 1);\n      }\n    \n      addSelectedFiles() {\n        this.add(this.selectedFiles);\n        this.selectedFiles = null;\n      }\n    }\n  </source-code>\n</code-listing>\n\nThe view-model declares a `files` bindable property, which is bound two way by default. This property is expected to initially contain an empty array.\n\nWhen files are dropped on the drop target element, the `add` method is called and the dropped `files` are appended to the `files` property. When the user selects files using the `file-picker`, the selected files are assigned back to the `selectedFiles` property, then the `change` event handler calls the `addSelectedFiles`, which appends the `selectedFiles` to the `files` property, and finally assigns `null` to the `selectedFiles`.\n\nThis last step makes sure that the underlying `<input type=\"file\">` element has its selection cleared. Without it, if a user tries to add the same file twice in a row, the `change` event would not be triggered the second time, because the `input`'s value would not change, so the second file selection would fail from the user's perspective.\n\n### Using the Image Files Picker\n\nUsing the `image-files-picker` element is then pretty simple. We first need to declare a property hosting the array of files on the `App` view-model:\n\n##### app.ts\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    export class App {\n      files: File[] = [];\n    }\n  </source-code>\n</code-listing>\n\nNext, we simply need to add the custom element in the template of our `App` component:\n\n##### app.html\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"bootstrap/css/bootstrap.min.css\"></require>\n      \n      <section class=\"container\">\n        <image-files-picker files.bind=\"files\"></image-files-picker>\n      </section>\n    </template>\n  </source-code>\n</code-listing>\n\nOf course, the various parts need to be loaded, either using the `require` statement in the `app.html` template, or in the `resources/index.ts` feature's `configure` function.\n\n## Filtering out Non-Image Files\n\nAt this point, a user can select or drop any type of files using our component. Some logic allowing only image files should be somehow added.\n\nA basic filtering logic, using the same syntax as the `<input type=\"file\">` element's `accept` attribute, is implemented in the complete code sample, which you can find \n[here](https://github.com/manuel-guilbault/learning-aurelia-image-files-picker). A more complete solution, showing error messages to the user, can easily be implemented. I'll leave this as an exercise to the reader.\n\n## Exploiting the Selected Images\n\nTypically, such a component would be used to first select a bunch of image files, then to upload those files to some remote endpoint. This is pretty easy to do with  Aurelia's Fetch client and the `FormData` class from the Fetch API.\n\nHere's an example of a client service used to upload an array of `File` instances to some remote endpoint:\n\n\n<code-listing>\n  <source-code lang=\"TypeScript\">\n    import {autoinject} from 'aurelia-framework';\n    import {HttpClient} from 'aurelia-fetch-client';\n    \n    @autoinject\n    export class SomeAPI {\n      constructor(private http: HttpClient) {}\n    \n      uploadFiles(files: File[]): Promise<void> {\n        const body = new FormData();\n        for (let i = 0; i < files.length; ++i) {\n          body.append(`files[${i}]`, files[i]);\n        }\n        return this.http.fetch('some/url', { method: 'POST', body });\n      }\n    }\n  </source-code>\n</code-listing>\n\n> The Mozilla Developer Network has [some great docs](https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects) about the `FormData` class.\n\n## Summary\n\nOnce again, Aurelia makes things easy. Its various constructs, such as custom attributes,\nelements, and value converters, help us decompose a problem and solve each of its parts\nwith a generic, reusable solution, and then recombine them together to address our initial,\nspecific problem. **Shameless plug alert**: this aspect is one of the many topics addressed \nin [Learning Aurelia](https://www.packtpub.com/web-development/learning-aurelia). You should definitely give it a look!"}