{"name":"Creating Reactive, Loosely Coupled Apps with Aurelia and Flux - Episode 2","description":"Recently we featured Tomasz Frydrychewicz, the Aurelia community member who authored the aurelia-flux plugin. Today, we're happy to bring you the second article in his series where he'll take you on a reactive, application-building adventure. Read on to dive into the details.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/8/6/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-2","html":"blog/2015/8/6/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-2/index.html","fragment":"blog/2015/8/6/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-2/index-fragment.html","self":"blog/2015/8/6/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-2/index.json"},"content":"\nRecently we featured Tomasz Frydrychewicz, the Aurelia community member who authored the `aurelia-flux` plugin. Today, we're happy to bring you the second article in his series where he'll take you on a reactive, application-building adventure. Read on to dive into the details.\n\n---\n\nIn the [previous episode](http://blog.durandal.io/2015/07/23/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-1/) I covered different parts of [aurelia-flux](https://github.com/tfrydrychewicz/aurelia-flux). This time, I would like to get you through creating a fully working reactive Aurelia application. Let us start with the simple Todo List application and we'll see where we can get to. \n\n### The Code\nThe described project is available for checkout [here](https://github.com/tfrydrychewicz/aurelia-flux-todo). \n\n### Let's Get to Work\nIf you don't know how to get started with Aurelia, there is a [great introduction](http://aurelia.io/get-started.html) available on Aurelia's web site. From now on I assume that you already know how to setup a basic Aurelia project, build and run it. \n\nWith that in place, let's start with installing aurelia-flux:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    jspm install aurelia-flux\n  </source-code>\n</code-listing>\nand enabling it in our brand new application, in *main.js*.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .plugin('aurelia-flux');\n    \n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n</code-listing>\n\n### First Screen\n\nAlthough your application will have only one screen, we will still configure a router to start serving the todo list. Open *app.js* and add the **list** view to the router configuration. \n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import 'bootstrap';\n    import 'bootstrap/css/bootstrap.css!';\n    \n    export class App {   \n      configureRouter(config, router){\n        config.title = 'ToDo List';\n        config.map([\n          { \n            route: [''], \n            name: 'list', \n            moduleId: './list', \n            nav: true, \n            title:'List' \n          }      \n        ]);\n    \n        this.router = router;\n      }\n    }\n  </source-code>\n</code-listing>\n\nTo finalize the application routing configuration, let's check that *app.html* contains all the necessary components. You should have that file already generated, if you created your application using the guide from the Aurelia site.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <require from='./nav-bar'></require>\n    \n      <nav-bar router.bind=\"router\"></nav-bar>\n    \n      <div class=\"container\">\n        <router-view></router-view>\n      </div>\n    </template>\n  </source-code>\n</code-listing>\n\nHaving that done, you can start creating the app. Let's start with the *list.html* view. In order to add new todos, you need an input box and a button.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\t\n    \t<div class=\"row\">\n    \t\t<div class=\"col-md-12 text-center\">\n    \t\t\t<h1>ToDo List</h1>\n    \t\t</div>\n    \t</div>\n    \t<hr />\n    \t<div class=\"row\">\n    \t\t<div class=\"col-md-10\">\n    \t\t\t<input type=\"text\" \n    \t\t\t\t   class=\"form-control input-lg\" \n    \t\t\t\t   ref=\"text\"\n    \t\t\t\t   placeholder=\"What would you like to do?\">\n    \t\t</div>\n    \t\t<div class=\"col-md-2\">\n    \t\t\t<button class=\"btn btn-lg btn-success btn-block\" \n    \t\t\t\t    click.delegate=\"addItem(text.value); text.value = ''\">Add</button>\n    \t\t</div>\n    \t</div>\n    </template>\n  </source-code>\n</code-listing>\n\nSo far, so good. You've come to the point where you have to add some logic to the application. This is the moment when you actually start adding reactive behavior to your todo list. To accompany our first view, we need a view model (*app.js*) with an `addItem(...)` method accepting a string.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {inject} from 'aurelia-framework';\n    import {Dispatcher} from 'aurelia-flux';\n    \n    @inject(Dispatcher)\n    export class List {\n    \tconstructor(dispatcher) {\n    \t\tthis.dispatcher = dispatcher;\t\t\t\t\n    \t}\t\n    \t\n    \taddItem(text) {\n    \t\tlet newItemText = (text || '').trim();\n    \t\t\n    \t\tif(newItemText === '') {\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tthis.dispatcher.dispatch('list.addItem', newItemText);\t\t\t\t\t\n    \t}\t\n    }\n  </source-code>\n</code-listing>\n\nWell... that wasn't much of an effort, was it? So what's so special about that code? What actually makes the code reactive and dependencies loosely coupled is the `list.addItem` action being dispatched, instead of a method being invoked. When you dispatch an action, you don't have any hard dependency, you don't really care about who listens and reacts to that action. \n\n### The List, Your First Reactive Component\n\nYour application can already collect todos from the input box and ask (it doesn't really know who, but it's always kind to ask) someone to add it to the list. Now you are going to create that someone who will react to the requested action. As reactive programming alleviates feature driven development, let's create a new *todo-list* folder for the component that will hold todos list. Inside, there will be three (all your reactive components, will consist not only of the view and the view-model, but also of the *Store*, responsible for handling actions and exposing data) files: *todo-list.html*, *todo-list.js* and *todo-list.store.js*. The view will be a standard component view.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n    \t<div class=\"panel panel-default ${item.completed ? 'item-completed' : 'item-uncompleted'}\" \n    \t\t repeat.for=\"[id, item] of todoListStore.items\">\n    \t\t<div class=\"panel-body\">\n    \t\t\t<div class=\"row\">\n    \t\t\t\t<div class=\"col-xs-1 item-mark\" \n    \t\t\t\t\t click.trigger=\"$parent.toggleCompleted(item)\">\n    \t\t\t\t\t<i class=\"fa fa-check fa-2x\"></i>\n    \t\t\t\t</div>\n    \t\t\t\t<div class=\"col-xs-11 item-text\">\n    \t\t\t\t\t${item.text}\n    \t\t\t\t</div>\n    \t\t\t</div>\n    \t\t</div>\n    \t</div>\n    </template>\n    \n  </source-code>\n</code-listing>\nThis view is built from a series of div blocks, one for each item in `todoListStore.items` (you'll see the *Store* in a couple of sentences). Each block contains a completion mark, which, when clicked, will trigger `$parent.toggleCompleted(...)` and `${item.text}`. Yet again, that is not anything new or unexpected. Here's the accompanying view-model.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {customElement, inject} from 'aurelia-framework';\n    import {Dispatcher} from 'aurelia-flux';\n    import {TodoListStore} from './todo-list.store';\n    \n    @customElement(\"todo-list\")\n    @inject(Dispatcher, TodoListStore)\n    export class TodoList {\n    \tconstructor(dispatcher, todoListStore) {\n    \t\tthis.dispatcher = dispatcher;\n    \t\tthis.todoListStore = todoListStore;\n    \t}\t\n    \t\n    \ttoggleCompleted(item) {\n    \t\tif(item.completed === false) {\n    \t\t\tthis.dispatcher.dispatch('list.completeItem', item.id);\n    \t\t} else {\n    \t\t\tthis.dispatcher.dispatch('list.undoCompleteItem', item.id);\n    \t\t}\n    \t}\n    }\n    \n  </source-code>\n</code-listing>\nJust like the first view-model, the TodoList doesn't have any hard dependencies. Instead of that, it just kindly asks to either complete the item or undo its completion and hopes that there will be someone to hear it. It also exposes its *Store* `todoListStore` to the view.  \n\nSo what's in the *Store*?\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {handle} from 'aurelia-flux';\n    \n    export class TodoListStore {\n    \t\n    \t_items = new Map();\n    \t\t\n    \tget items() {\n    \t\treturn this._items;\n    \t}\n    \t\n    \t@handle('list.addItem')\n    \taddItem(action, text) {\t\t\t\t\n    \t\tlet newItem = new ListItem(text);\n    \t\tthis._items.set(newItem.id, newItem);\n    \t}\n    \t\n    \t@handle('list.completeItem')\n    \tcompleteItem(action, id) {\t\t\n    \t\tif(this._items.has(id)) {\n    \t\t\tthis._items.get(id).completed = true;\t\n    \t\t}\t\t\t\t\n    \t}\n    \t\n    \t@handle('list.undoCompleteItem')\n    \tundoCompleteItem(action, id) {\t\t\n    \t\tif(this._items.has(id)) {\n    \t\t\tthis._items.get(id).completed = false;\t\n    \t\t}\n    \t}\t\t\t\n    }\n    \n    export class ListItem {\n    \tconstructor(text) {\n    \t\tthis.id =  (+new Date() + Math.floor(Math.random() * 999999)).toString(36);\n    \t\tthis.text = text;\n    \t\tthis.completed = false;\t\t\n    \t}\n    }\n    \n  </source-code>\n</code-listing>\nAs you can see, the *Store* is the one who listens. It actually knows just three words: `list.addItem`, `list.completeItem` and `list.undoCompleteItem`. To allow it to hear, use the `@handle(...)` decorator from the [aurelia-flux](https://github.com/tfrydrychewicz/aurelia-flux) library. When applied to a method, it tells the dispatcher to invoke that method, whenever a given action is being dispatched. Let's take a closer look at the `addItem(...)` method.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    @handle('list.addItem')\n    addItem(action, text) {\t\t\t\t\n    \tlet newItem = new ListItem(text);\n    \tthis._items.set(newItem.id, newItem);\n    }\n  </source-code>\n</code-listing>\n\nThe first line tells the flux dispatcher that this method is interested in handling the `list.addItem` action. An important details is that every handler method will expect an action name on its first parameter. The following parameters will match those passed to the `dispatch(...)` method. The `action` parameter will contain the actual action name that triggered this method (in this case it'll be `list.addItem`). You may ask, why do I need that information if I already have it in `@handle(...)` decorator? That is because, apart from a specific name, the decorator accepts wildcards: `*` for any string, `?` for one character. For example:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    @handle('*')\n    ...\n    \n    @handle('list.*')\n    ...\n    \n    @handle('list?.add*')\n    ...\n  </source-code>\n</code-listing>\n\nHaving that said, you may not always be able to tell which action you're currently handling. That is why actually dispatching action's name is always available on the first parameter. \n\nThe rest of the `addItem(...)` method should be rather straightforward. \n\nHaving all those files set, you're ready to add the `todo-list` component to the main view. Below the input box div block add a new div block with the `todo-list` element.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n    \t<require from=\"todo-list/todo-list\"></require>\n    \t...\n    \t<hr />\n    \t<div class=\"row\">\n    \t\t<div class=\"col-md-12\">\n    \t\t\t<todo-list></todo-list>\n    \t\t</div>\t\t\n    \t</div>\n    \t...\n    </template>\n  </source-code>\n</code-listing>\n\nFrom now on, `TodoListStore` will handle adding new items, completing them, undoing the completion and will expose the list to the `todo-list` component.\n\n### Measuring Can Be Fun\n \nWho doesn't like statistics? Let's assume that you'd like to add a new functionality to the application and start collecting some statistics about the todos you collect. At first, just for a second, imagine that you're not creating a reactive application. Most probably, in order to start collecting new, statistical data the current code base would have to be modified. That is definitely not a happy place. Luckily, the application is already reactive. \n\nAs previously, start with creating a component folder *todo-stats* with three files in it: *todo-stats.html*, *todo-stats.js* and *todo-stats.store.js*. The view presents simple data.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n    \t<div class=\"panel panel-default\">\n    \t\t<div class=\"panel-heading\">\n    \t\t\t<h3 class=\"panel-title\">Statistics</h3>\n    \t\t</div>\n    \t\t<div class=\"panel-body\">\n    \t\t\t<table class=\"table\">\n    \t\t\t\t<tr>\n    \t\t\t\t\t<td>Items</td>\n    \t\t\t\t\t<td>${stats.items}</td>\n    \t\t\t\t</tr>\n    \t\t\t\t<tr>\n    \t\t\t\t\t<td>Completed</td>\n    \t\t\t\t\t<td>${stats.completed}</td>\n    \t\t\t\t</tr>\n    \t\t\t\t<tr>\n    \t\t\t\t\t<td>Not completed</td>\n    \t\t\t\t\t<td>${stats.uncompleted}</td>\n    \t\t\t\t</tr>\n    \t\t\t\t<tr>\n    \t\t\t\t\t<td>Words</td>\n    \t\t\t\t\t<td>${stats.words}</td>\n    \t\t\t\t</tr>\n    \t\t\t\t<tr>\n    \t\t\t\t\t<td>Characters</td>\n    \t\t\t\t\t<td>${stats.characters}</td>\n    \t\t\t\t</tr>\n    \t\t\t</table>\n    \t\t</div>\n    \t</div>\n    </template>\n  </source-code>\n</code-listing>\n\nThe view-model couldn't be any simpler.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {customElement, inject} from 'aurelia-framework';\n    import {TodoStatsStore} from './todo-stats.store';\n    \n    @customElement('todo-stats')\n    @inject(TodoStatsStore)\n    export class TodoStats {\n    \tconstructor(todoStatsStore) {\n    \t\tthis.stats = todoStatsStore.stats;\n    \t}\n    }\n  </source-code>\n</code-listing>\n\nAnd now, for the *Store*. If the application is going to be truly decoupled, how does the `todo-stats` component know that a new item has been collected by the `todo-list` component? It just has to hear about that. As you remember, the main view says `list.addItem` on an *Add* button click. Just make your `TodoStatsStore` hear and handle the same action. The same goes for the `list.completeItem` and `list.undoCompleteItem` actions. Finally, let's assume that you would like to assure that the `todo-list` component will handle all those actions before the stats component does it. With the aurelia-flux dispatcher you get the `@waitFor(...)` decorator, which allows you to build such ordered processing declaratively. \n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {handle, waitFor} from 'aurelia-flux';\n    import {TodoListStore} from 'todo-list/todo-list.store';\n    \n    export class TodoStatsStore {\n    \tstats = {\n    \t\titems:       0,\n    \t\tcompleted:   0,\n    \t\tuncompleted: 0,\n    \t\twords:       0,\n    \t\tcharacters:  0\n    \t};\n    \t\n    \t@handle('list.addItem')\n    \t@waitFor(TodoListStore)\n    \tnewItem(action, text) {\n    \t\tthis.stats.items++;\n    \t\tthis.stats.uncompleted++;\n    \t\tthis.stats.words += text.split(' ').length;\n    \t\tthis.stats.characters += text.length;\t\t\n    \t}\n    \t\n    \t@handle('list.completeItem')\n    \t@waitFor(TodoListStore) \n    \titemCompleted(action, id) {\n    \t\tthis.stats.completed++;\n    \t\tthis.stats.uncompleted--;\n    \t}\n    \t\n    \t@handle('list.undoCompleteItem')\n    \t@waitFor(TodoListStore)\n    \titemUncompleted(action, id) {\n    \t\tthis.stats.completed--;\n    \t\tthis.stats.uncompleted++;\n    \t}\t\n    }\n  </source-code>\n</code-listing>\n\nWait a second! That's not loosely coupled. It depends on an existing type - you probably thought. Well, that is not totally true. For unit testing purposes, instead of having the real `TodoListStore` injected, you can inject whatever object you want. The aurelia-flux dispatcher will determine that this type didn't take part in dispatching the given action and will resolve it automatically to prevent you from being locked.\n\nThe only thing left is to add the newly created `todo-stats` component to the main view.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n    \t<require from=\"todo-list/todo-list\"></require>\n    \t<require from=\"todo-stats/todo-stats\"></require>\n    \t...\n    \t<hr />\n    \t<div class=\"row\">\n    \t\t<div class=\"col-md-8\">\n    \t\t\t<todo-list></todo-list>\n    \t\t</div>\n    \t\t<div class=\"col-md-4\">\n    \t\t\t<div class=\"row\">\n    \t\t\t\t<div class=\"col-xs-12\">\n    \t\t\t\t\t<todo-stats></todo-stats>\n    \t\t\t\t</div>\n    \t\t\t</div>\t\t\t\n    \t\t</div>\n    \t</div>\n    \t...\n    </template>\n  </source-code>\n</code-listing>\n\n### Hash Tag aurelia-flux\n\nWho doesn't like hash tags? Everybody does :), so why don't you have them in your Todo List app? Every time you start thinking about a new reactive component, always consider it an independent, self-sufficient being, containing just what is needed to accomplish its task. In this case, what you need is a *Store* that will parse every new added todo item, look for hash tags and collect them along with the item's id. Your first thought might be to react to the `list.addItem` action. Unfortunately, it doesn't carry the item's id, as it is being dispatched before an item was actually created. What can you do about that? The dispatcher can help you here, with its capability of queuing an action during dispatching another one. Just enrich `TodoListStore` (*todo-list/todo-list.store.js*) with the ability of saying \"Hey, I've just added a new item. Isn't that awesome?!\"\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {inject} from 'aurelia-framework';\n    import {handle, Dispatcher} from 'aurelia-flux';\n    \n    @inject(Dispatcher)\n    export class TodoListStore {\n    \t\n    \t_items = new Map();\n    \t\n    \tconstructor(dispatcher) {\n    \t\tthis.dispatcher = dispatcher;\n    \t}\n    \t\n    \tget items() {\n    \t\treturn this._items;\n    \t}\n    \t\n    \t@handle('list.addItem')\n    \taddItem(action, text) {\t\t\t\t\n    \t\tlet newItem = new ListItem(text);\n    \t\tthis._items.set(newItem.id, newItem);\n    \t\tthis.dispatcher.dispatch('list.itemAdded', newItem);\n    \t}\n    \t\n    \t...\t\n    }\n  </source-code>\n</code-listing>\n\nNow you have something you can react to, so lay the first stone and create the folder and the three files for your `todo-item-tags` component.\n\nThe view will be used to display tags for each of the todos list items.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n    \t<div if.bind=\"tags.length\">\n    \t\tTags:\n    \t\t<span repeat.for=\"tag of tags\">\n    \t\t\t<span class=\"label ${$parent.isItemCompleted ? 'label-default' : 'label-primary'}\">\n    \t\t\t\t${tag}\n    \t\t\t</span>&nbsp;\n    \t\t</span>\n    \t</div>\n    </template>\n  </source-code>\n</code-listing>\n\nThe view-model will expose the `TodoItemTagsStore` data to the view. As the `todo-item-tags` component is going to be used for each item, it needs a bindable property to store the item's id. It would also be awesome to change the component's styling when a corresponding item changes its completion state. Managing that in the *Store* may not be the best idea, as that is actually not part of its planned functionality. Let's stop for a second and think, what do we call a *Store*? Does it have to inherit from any special class, does it have to follow any particular convention? No. In fact the only thing that distinguishes it is its behavior. **It hears and reacts**. Can a view-model play the same role? Yes, of course. In your case the view model will have to react to `list.completeItem` and `list.undoCompleteItem`.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {customElement, inject, bindable} from 'aurelia-framework';\n    import {handle} from 'aurelia-flux';\n    import {TodoItemTagsStore} from './todo-item-tags.store';\n    \n    @customElement(\"todo-item-tags\")\n    @inject(TodoItemTagsStore)\n    export class TodoItemTags {\t\n    \t@bindable itemId;\n    \t\n    \tconstructor(todoItemTagsStore) {\t\n    \t\tthis.todoItemTagsStore = todoItemTagsStore;\n    \t\tthis.isItemCompleted = false;\n    \t}\n    \t\n    \tget tags() {\n    \t\treturn this.todoItemTagsStore.tags.get(this.itemId);\t\t\n    \t}\n    \t\n    \t@handle('list.completeItem')\n    \titemCompleted(action, id) {\n    \t\tif(this.itemId === id) {\n    \t\t\tthis.isItemCompleted = true;\n    \t\t}\n    \t}\n    \t\n    \t@handle('list.undoCompleteItem')\n    \tundoItemCompleted(action, id) {\n    \t\tif(this.itemId === id) {\n    \t\t\tthis.isItemCompleted = false;\n    \t\t}\n    \t}\n    }\n    \n  </source-code>\n</code-listing>\nNow to the *Store*: the `todo-list` component is already capable of saying that it has collected a new item and you know how to hear about it. You also know that a dispatcher can queue upcoming actions. Add a pinch of business logic and voila, you're done!\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {inject} from 'aurelia-framework';\n    import {Dispatcher, handle} from 'aurelia-flux';\n    \n    @inject(Dispatcher)\n    export class TodoItemTagsStore {\n    \t_tags = new Map();\n    \t\n    \tconstructor(dispatcher) {\n    \t\tthis.dispatcher = dispatcher;\n    \t}\n    \t\n    \tget tags() {\n    \t\treturn this._tags;\n    \t}\n    \t\n    \t@handle('list.itemAdded')\n    \tnewItem(action, item) {\t\t\n    \t\tlet itemTags = item.text.match(/\\#[^ $]+/g);\n    \t\t\n    \t\tif(itemTags !== null) {\t\t\t\n    \t\t\tfor(let tag of itemTags) {\n    \t\t\t\tthis.dispatcher.dispatch('tags.addTag', tag, item.id);\n    \t\t\t}\t\t\t\t\t\t\n    \t\t}\t\t\t\t\t\t\t\t\n    \t}\t\t\t\n    \t\n    \t@handle('tags.addTag')\n    \taddTag(action, tag, itemId) {\t\t\n    \t\ttag = (tag || '').trim().toLowerCase().substring(1)\n    \t\t\n    \t\tif(this.tags.has(itemId) === false) {\n    \t\t\tthis.tags.set(itemId, []);\n    \t\t}\n    \t\t\n    \t\tif(this.tags.get(itemId).indexOf(tag) === -1) {\n    \t\t\tthis.tags.get(itemId).push(tag);\n    \t\t}\n    \t}\n    }\n  </source-code>\n</code-listing>\n\nFinally, the last piece of the puzzle: connect `todo-item-tags` with the `todo-list` component (*todo-list/todo-list.html*) and give it a try. \n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n    \t<require from=\"todo-item-tags/todo-item-tags\"></require>\n    \n    \t<div class=\"panel panel-default ${item.completed ? 'item-completed' : 'item-uncompleted'}\" \n    \t\t repeat.for=\"[id, item] of todoListStore.items\">\n    \t\t<div class=\"panel-body\">\n    \t\t\t<div class=\"row\">\n    \t\t\t\t<div class=\"col-xs-1 item-mark\" \n    \t\t\t\t\t click.trigger=\"$parent.toggleCompleted(item)\">\n    \t\t\t\t\t<i class=\"fa fa-check fa-2x\"></i>\n    \t\t\t\t</div>\n    \t\t\t\t<div class=\"col-xs-11 item-text\">\n    \t\t\t\t\t${item.text}\n    \t\t\t\t</div>\n    \t\t\t</div>\n    \t\t</div>\n    \t\t<div class=\"panel-footer\">\n    \t\t\t<todo-item-tags item-id.bind=\"item.id\"></todo-item-tags>\n    \t\t</div>\n    \t</div>\n    </template>\n  </source-code>\n</code-listing>\n\n### Summary\n\nCreating reactive applications with [aurelia-flux](https://github.com/tfrydrychewicz/aurelia-flux) is not only fun but also gives you the opportunity to create a truly decoupled system. I hope you enjoyed this journey and that it's just the beginning of your reactive adventure."}