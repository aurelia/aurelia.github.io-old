{"name":"JWT Authentication in Aurelia","description":"This week community member Ryan Chenkie [https://twitter.com/ryanchenkie] shows us how to implement JWT Authentication in Aurelia. Ryan is a full-stack developer from Canada who works for Auth0 [https://auth0.com] as a Tech Writer where he provides in-depth tutorials and seed projects for the newest frameworks such as Angular 2, React, and Aurelia as well as other modern web technologies.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/8/2/jwt-authentication-in-aurelia","html":"blog/2015/8/2/jwt-authentication-in-aurelia/index.html","fragment":"blog/2015/8/2/jwt-authentication-in-aurelia/index-fragment.html","self":"blog/2015/8/2/jwt-authentication-in-aurelia/index.json"},"content":"\nThis week community member [Ryan Chenkie](https://twitter.com/ryanchenkie) shows us how to implement JWT Authentication in Aurelia. Ryan is a full-stack developer from Canada who works for [Auth0](https://auth0.com) as a Tech Writer where he provides in-depth tutorials and seed projects for the newest frameworks such as Angular 2, React, and Aurelia as well as other modern web technologies.\n\n---\n\n**TL;DR**: Aurelia is a great client-side JavaScript framework and adding JWT authentication to Aurelia apps is easy with the [aurelia-auth package](https://github.com/paulvanbladel/aurelia-auth). Checkout the [GitHub repo](https://github.com/chenkie/aurelia-jwt-auth) for this article to find out how to add authentication to your Aurelia app.\n\n---\n\n## Getting Started\n\nGetting started with Aurelia is a piece of cake. The framework's [getting started guide](http://aurelia.io/get-started.html) offers an in-depth set of instructions along with a [seed project](https://github.com/aurelia/skeleton-navigation/releases) that make it very simple to get up and running quickly.\n\nThis tutorial will expand upon the seed project and show how to add JWT authentication to a random quote application. We'll be using the [NodeJS JWT Authentication Sample](https://github.com/auth0/nodejs-jwt-authentication-sample) as our backend to show how we can retrieve a JWT upon login, save it in local storage, and send it along with every subsequent request. Our app will let all visitors retrieve a random quote, but logged-in users will be able to get a super-secret quote.\n\n![](https://www.dropbox.com/s/lxzd6qeq69l0p6y/aurelia-welcome.png?dl=1)\n\n### Two Ways to Get Going\n\nYou can go through the [getting started](http://aurelia.io/get-started.html) guide that Aurelia provides and follow along, changing files in their seed project as we go. Alternatively, you can clone [the project for this tutorial](https://github.com/chenkie/aurelia-jwt-auth) and follow along from there.\n\nIf you are starting from Aurelia's seed project, be sure to split it out into two subdirectories, `client` and `server`. The `server` directory is where the [NodeJS JWT authentication sample](https://github.com/auth0/nodejs-jwt-authentication-sample) will go.\n\nTo get the server setup, you can follow the instructions in the readme for the [NodeJS JWT Authentication Sample](https://github.com/auth0/nodejs-jwt-authentication-sample).\n\n### A Little Help From Aurelia-Auth\n\nTo help us with our token dealings on the front-end, we'll use the awesome [aurelia-auth plugin](https://github.com/paulvanbladel/aurelia-auth) provided by Paul van Bladel, along with some pointers from his [sample app repo](https://github.com/paulvanbladel/aurelia-auth-sample).\n\n## Setting Up the Client Config Files\n\nThere's a bit of configuration setup to do, but once it's in place things will be a breeze.\n\nAfter doing `npm install` and `jspm install` to pull in all the dependencies, we'll need to also install the `aurelia-auth` plugin. We can do this with `jspm` within the client directory:\n\n\tjspm install github:paulvanbladel/aurelia-auth\n\n### Application Bootstap Config\n\nLet's give our app a name of `quotes-app` and reflect this on the `body` tag of `index.html` where the app loads.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <!-- client/index.html -->\n    \n    ...\n    \n    <body aurelia-app=\"quotes-app\">\n      <script src=\"jspm_packages/system.js\"></script>\n      <script src=\"config.js\"></script>\n      <script>\n        System.import('aurelia-bootstrapper');\n      </script>\n    </body>\n    \n    ...\n    \n  </source-code>\n</code-listing>\n\nAurelia looks for a JavaScript file with the same name in the `src` directory for the main app config details. Let's create that now:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    \n    // client/src/quotes-app.js\n    \n    import config from './auth-config';\n    \n    export function configure(aurelia) {\n    \n      // Here we provide configuration for our application and can\n      // bring in the configuration settings we put within auth-config.js\n      // that will tell the aurelia-auth plugin the specific settings\n      // for our application's authentication context\n      aurelia.use\n        .standardConfiguration()\n        .developmentLogging()\n        .plugin('paulvanbladel/aurelia-auth', (baseConfig) => {\n             baseConfig.configure(config);\n        });\n    \n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n</code-listing>\n\nYou can see here that we're importing a file called `auth-config.js` and that it's the export from this file that is passed to the `baseConfig` for the plugin. The `auth-config` file will let us override the aurelia-auth plugin's defaults with our own specifics. Let's create it now:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/auth-config.js\n    \n    // Specific settings for our application's\n    // authentication context. These will override\n    // the default settings provided by aurelia-auth\n    \n    var config = {\n    \n      // Our Node API is being served from localhost:3001\n      baseUrl: 'http://localhost:3001',\n      // The API specifies that new users register at the POST /users enpoint\n      signupUrl: 'users',\n      // Logins happen at the POST /sessions/create endpoint\n      loginUrl: 'sessions/create',\n      // The API serves its tokens with a key of id_token which differs from\n      // aurelia-auth's standard\n      tokenName: 'id_token',\n      // Once logged in, we want to redirect the user to the welcome view\n      loginRedirect: '#/welcome',\n    \n    }\n    \n    export default config;\n  </source-code>\n</code-listing>\n\nThe API is accessible at `localhost:3001`, so we set this as our `baseUrl`. Next, we setup the proper endpoints that we'll need for signing users up and logging them in. We also need to override the `tokenName` with what our API serves, which in this case is `id_token`. Finally we say that we want to redirect the user to the `welcome` view once they login.\n\n### Application Routing Config\n\nWe'll now need to setup the application's routing configuration. Let's first setup the HTML that will require and load our nav bar and other views:\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <!-- client/src/app.html -->\n    <template>\n      <require from=\"bootstrap/css/bootstrap.css\"></require>\n      <require from='./nav-bar'></require>\n    \n      <nav-bar router.bind=\"router\"></nav-bar>  \n    \n      <div class=\"container\">      \n        <router-view></router-view>\n      </div>\n      \n    </template>\n  </source-code>\n</code-listing>\n\nHere we are requiring the `nav-bar` and binding it to the router. We will serve our views from the `<router-view>` within our containing `<div>`.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/app.js\n    \n    import 'bootstrap';\n    \n    import {inject} from 'aurelia-framework';\n    import {Router} from 'aurelia-router';\n    import HttpClientConfig from 'paulvanbladel/aurelia-auth/app.httpClient.config';\n    import AppRouterConfig from 'router-config';\n    \n    // Using Aurelia's dependency injection, we inject Aurelia's router,\n    // the aurelia-auth http client config, and our own router config\n    // with the @inject decorator\n    @inject(Router, HttpClientConfig, AppRouterConfig)\n    \n    export class App {\n    \n      constructor(router, httpClientConfig, appRouterConfig) {\n        \n        this.router = router;\n    \n        // Client configuration provided by the aurelia-auth plugin\n        this.httpClientConfig = httpClientConfig;\n    \n        // The application's configuration, including the\n        // route definitions that we've declared in router-config.js\n        this.appRouterConfig = appRouterConfig;\n      };\n      \n      activate() {\n        \n        // Here we run the configuration when the app loads\n        this.httpClientConfig.configure();\n        this.appRouterConfig.configure();\n    \n      };\n    }\n  </source-code>\n</code-listing>\n\nThe HTTP configuration that `aurelia-auth` provides is what handles adding the JWT as a header if the user is authenticated. The `httpClientConfig` file has logic that checks for the existence of a token in `localstorage` and then adds an `Authorization` header with a value of `Bearer <token>` if one exists. The token will be sent for all HTTP requests to the API, but will obviously only be needed for protected resources.\n\n![](https://www.dropbox.com/s/1hzmzsla8l1vm7d/aurelia-auth-bearer.png?dl=1)\n\nWe can keep our routing logic within the main `app.js` file, like is done in a lot of Aurelia projects, but in our case we'll put this configuration in a separate file called `router-config.js` which we are injecting. Let's setup this routing configuration:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/router-config.js\n    \n    import {AuthorizeStep} from 'paulvanbladel/aurelia-auth';\n    import {inject} from 'aurelia-framework';\n    import {Router} from 'aurelia-router';\n    \n    // Using Aurelia's dependency injection, we inject Router\n    // with the @inject decorator\n    @inject(Router)\n    \n    export default class {\n    \n      constructor(router) {\n        this.router = router;\n      };\n    \n      configure() {\n    \n        var appRouterConfig = function(config) {\n          \n          config.title = 'Random Quotes App';\n    \n          // Here we hook into the authorize extensibility point\n          // to add a route filter so that we can require authentication\n          // on certain routes\n          config.addPipelineStep('authorize', AuthorizeStep);\n    \n          // Here we describe the routes we want along with information about them\n          // such as which they are accessible at, which module they use, and whether\n          // they should be placed in the navigation bar\n          config.map([\n              { route: ['','welcome'], name: 'welcome', moduleId: './welcome', nav: true, title:'Welcome' },\n              { route: 'random-quote', name: 'random-quote', moduleId: './random-quote', nav: true, title:'Random Quote' },          \n              // The secret-quote route is the only one that the user needs to be logged in to see,  so we set auth: true\n              { route: 'secret-quote', name: 'secret-quote', moduleId: './secret-quote', nav: true, title:'Super Secret Quote', auth: true },\n              { route: 'signup', name: 'signup', moduleId: './signup', nav: false, title:'Signup', authRoute: true },\n              { route: 'login', name: 'login', moduleId: './login', nav: false, title:'Login', authRoute: true },\n              { route: 'logout', name: 'logout', moduleId: './logout', nav: false, title:'Logout', authRoute: true }\n            ]);\n          };\n    \n        // The router is configured with what we specify in the appRouterConfig\n        this.router.configure(appRouterConfig);\n    \n      };\n    }\n  </source-code>\n</code-listing>\n\nAurelia gives us the ability to customize the navigation pipeline with some extensibility points, including an `authorize` route filter. Using this filter means we can specify which routes we would like authentication to be required for. Since our `super-secret-quotes` route needs to remain top secret until the user is logged in, we put `auth: true` on it. We hook into this filter by calling `addPipelineStep`, passing in the `AuthorizeStep` that is provided by the `aurelia-auth` plugin.\n\nWith the configuration out of the way, let's get to coding the actual routes and their views! We'll need to have files that take care of each route in place before the app will work, so you can comment out the routes in `router-config.js` that aren't ready yet.\n\n## Setting Up Routes and Views\n\nTwo files are required for each route in Aurelia---a JavaScript file for the view model logic and an HTML file for the view itself. Views are enclosed within `<template>` tags but are otherwise made of normal HTML that can make use of Aurelia's databinding. \n\n### The Nav Bar and Welcome Route\n\nLet's start at the top and setup the navigation bar.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <!-- nav-bar.html -->\n    \n    ...\n        \n    <ul class=\"nav navbar-nav\">\n      <li repeat.for=\"row of router.navigation | authFilter: isAuthenticated\" class=\"${row.isActive ? 'active' : ''}\">\n        <a data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1.in\" href.bind=\"row.href\">${row.title}</a>\n      </li>\n    </ul>\n    \n    <ul if.bind=\"!isAuthenticated\" class=\"nav navbar-nav navbar-right\">\n      <li><a href=\"/#/login\">Login</a></li>\n      <li><a href=\"/#/signup\">Signup</a></li>\n    </ul>\n    \n    <ul if.bind=\"isAuthenticated\" class=\"nav navbar-nav navbar-right\">\n      <li><a href=\"/#/logout\">Logout</a></li>\n    </ul>\n    \n    ...      \n  </source-code>\n</code-listing>\nNotice here that we're running a filter on the repeated navigation items with `authFilter: isAuthenticated`. This allows us to hide any nav menu items that are to be protected if the user isn't authenticated and will be how we hide the `super-secret-quote` menu item when the user isn't logged in. We're also conditionally showing the Signup, Login and Logout links. See the [GitHub repo](https://github.com/chenkie/aurelia-jwt-auth/blob/master/client/src/nav-bar.html) for the rest of the markup.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/nav-bar.js\n    \n    import {bindable} from 'aurelia-framework';\n    import {inject} from 'aurelia-framework';\n    import {AuthService} from 'paulvanbladel/aurelia-auth';\n    \n    @inject(AuthService)\n    \n    export class NavBar {\n      // User isn't authenticated by default\n      _isAuthenticated = false;\n      @bindable router = null;\n    \n      constructor(auth) {\n        this.auth = auth;\n      };\n    \n      // We can check if the user is authenticated\n      // to conditionally hide or show nav bar items\n      get isAuthenticated() {\n        return this.auth.isAuthenticated();\n      };\n    }\n  </source-code>\n</code-listing>\n\nHere in the `nav-bar.js` file we have a method that checks whether the user is logged in which is what we hook into in the view.\n\nThe Aurelia seed comes with a welcome route, but in our case we can trim it down to be simpler.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <!-- client/src/welcome.html -->\n    \n    <template>\n      <section>\n        <h2>${heading}</h2>\n    \n        <div class=\"well\">\n          <h4>${info}</h4>\n        </div>\n        \n      </section>\n    </template>\n  </source-code>\n</code-listing>\nThe JavaScript becomes simpler as well.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/welcome.js\n    \n    export class Welcome {\n    \n      heading = 'Welcome to the Random Quotes App!';\n      info = 'You can get a random quote without logging in, but if you do login you can get a super secret quote!';\n    \n    }\n  </source-code>\n</code-listing>\n\n### Signup, Login and Logout\n\nNext, let's setup the `signup`, `login` and `logout` routes.\n\n### Signup\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <!-- client/src/signup.html -->\n    \n    ...\n    \n    <form role=\"form\" submit.delegate=\"signup()\">\n      <div class=\"form-group\">\n        <label for=\"email\">Email</label>\n        <input type=\"text\" value.bind=\"email\" class=\"form-control\" id=\"email\" placeholder=\"Email\">\n      </div>\n      <div class=\"form-group\">\n        <label for=\"password\">Password</label>\n        <input type=\"password\" value.bind=\"password\" class=\"form-control\" id=\"password\" placeholder=\"Password\">\n      </div>\n      <button type=\"submit\" class=\"btn btn-default\">Signup</button>\n    </form>\n    <hr>\n    <div class=\"alert alert-danger\" if.bind=\"signupError\">${signupError}</div>\n    \n    ...\n  </source-code>\n</code-listing>\nIn this view we're providing two `<input>`s that take the user's email and password. We've also got an alert box at the bottom to show the user any errors that are returned. We'll need to setup the view models for these next.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/signup.js\n    \n    import {inject} from 'aurelia-framework';\n    import {AuthService} from 'paulvanbladel/aurelia-auth';\n    \n    // Using Aurelia's dependency injection, we inject the AuthService\n    // with the @inject decorator\n    @inject(AuthService)\n    \n    export class Signup {\n      \n      heading = 'Sign Up';\n    \n      // These view models will be given values\n      // from the signup form user input\n      email = '';\n      password = '';\n    \n      // Any signup errors will be reported by\n      // giving this view model a value in the\n      // catch block within the signup method\n      signupError = '';\n    \n      constructor(auth) {\n        this.auth = auth;\n      };\n    \n      signup() {\n    \n        // Object to hold the view model values passed into the signup method\n        var userInfo = { email: this.email, password: this.password }\n    \n        return this.auth.signup(userInfo)\n        .then((response) => {\n          console.log(\"Signed Up!\");\n        })\n        .catch(error => {\n          this.signupError = error.response;\n        });\n        \n      };\n    }\n  </source-code>\n</code-listing>\nThe `signup()` method uses `aurelia-auth` to send a POST request to the API which either creates a new user or returns an error if there was a problem.\n\n### Login\n\nThe `login` route is pretty similar. You'll just need to swap out `submit.delegate=\"signup()\"` for`submit.delegate=\"login()\"` and adjust the other [pieces of markup](https://github.com/chenkie/aurelia-jwt-auth/blob/master/client/src/login.html) appropriately\n\nThe JavaScript for `login` looks similar as well, but this time we are sending the POST request to the `sessions/create` endpoint:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/login.js\n    \n    ...\n    \n      login() {\n        return this.auth.login(this.email, this.password)\n        .then(response => {\n          console.log(\"Login response: \" + response);\n        })\n        .catch(error => {\n          this.loginError = error.response;\n        });\n      };\n    \n    ...\n  </source-code>\n</code-listing>\n\n### Logout\n\nThe `logout` route essentially follows the same pattern using `authService.logout()` to remove the user's JWT from `localstorage`. See [the repo](https://github.com/chenkie/aurelia-jwt-auth/blob/master/client/src/logout.js) for further detail.\n\nWith all this in place, we should now be able to signup, login and logout users. Test it out to make sure everything is running as expected. If everything is working properly, when the user logs in there will be a JWT set in `localstorage`.\n\n![](https://www.dropbox.com/s/t6f3rzevv1kmd3d/aurelia-localstorage-token.png?dl=1)\n\n## The Random Quote and Super-Secret Quote Routes\n\nWith signup, login and logout in place we now need to create the files for our quote routes. Let's first take care of the `random-quote` route.\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <!-- client/src/random-quote.js -->\n    \n    <template>\n      <section class=\"col-sm-12\">\n          <h2>${heading}</h2>\n          <div class=\"row\">\n            <div class=\"well\">\n              <h4>${randomQuote}</h4>\n            </div>\n          </div>\n      </section>\n    </template>\n  </source-code>\n</code-listing>\n\nThis view simply displays the heading and the text of the quote that we retrieve.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/random-quote.js\n    \n    import {inject} from 'aurelia-framework';\n    import {HttpClient} from 'aurelia-http-client';\n    \n    // Using Aurelia's dependency injection, we inject HttpClient\n    // with the @inject decorator to make HTTP requests\n    @inject(HttpClient)\n    \n    export class RandomQuote {\n    \n      heading = 'Random Quote';\n    \n      // View model that will be populated with the \n      // the random quote retrieved from the API and\n      // displayed in the view\n      randomQuote = '';\n    \n      constructor(http) {\n        this.http = http;\n      };\n    \n      activate() {\n        return this.http.get('http://localhost:3001/api/random-quote')\n        .then(response => {\n          this.randomQuote = response.content;\n        }).catch(error => {\n          console.log('Error getting quote');\n        });\n      };\n    }\n  </source-code>\n</code-listing>\n\nWe want to fetch the quote when the route is hit so within the `activate()` method we are making a GET request to our `random-quote` endpoint which is located at `localhost:3001/api/random-quote`. If we get a good response, we set the quote text onto `randomQuote` so that it can be accessed in the view.\n\nThe `super-secret-quote` route is pretty much the same, except that we make our requests to a different endpoint. For the view in `secret-quote.html`, make sure to change `${randomQuote}` to `${secretQuote}`\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // client/src/secret-quote.js\n    \n    ...\n    \n    activate() {\n      return this.http.get('http://localhost:3001/api/protected/random-quote')\n      .then(response => {\n        this.secretQuote = response.content;\n      }).catch(error => {\n        console.log('Error getting quote');\n      });\n    }\n    \n    ...\n  </source-code>\n</code-listing>\n\nAs you can see, the only real difference here is that the GET request we're making is going to the `protected/random-quote` endpoint. If there is no valid JWT in localstorage, we won't be able to get to this route. If somehow we got to it, the request will fail because no JWT will be sent to the server.\n\n![](https://www.dropbox.com/s/r73f7iuf0srqfz8/aurelia-super-secret-quote.png?dl=1)\n\n## Wrapping Up\n\nProtecting routes that we want to limit to logged-in users is actually quite simple with the `aurelia-auth` plugin because we can set the app up such that if a user isn't logged in they can't see or reach protected routes. If, for whatever reason, someone was able to get to a route they shouldn't be at and they don't have a valid JWT, any HTTP requests they make will be denied by the server. Properly authenticated users will have a valid JWT in `localstorage` which will be sent along as a header with all the requests they make which will give them access to protected resources.\n\nAurelia is a great next-generation JavaScript framework with a growing user base. As we saw in this tutorial, we can easily get users signed up and authenticated using the `aurelia-auth` plugin."}