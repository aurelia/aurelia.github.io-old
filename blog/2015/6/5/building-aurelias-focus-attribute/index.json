{"name":"Building Aurelia's Focus Attribute","description":"This week we are really excited to have our first community member highlight post! Manuel Guilbault [https://github.com/manuel-guilbault/] is a Canadian-born, Paris-based developer, where he works as a consultant in the financial sector. Passionate about software craftsmanship, agility and lean principles, he loves to learn and debate about how we do things, why we do them this way and how they can be improved. This week we've invited Manuel to guest blog with us and share the work he did implementing a new custom attribute that's shipping in the next Aurelia update.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/6/5/building-aurelias-focus-attribute","html":"blog/2015/6/5/building-aurelias-focus-attribute/index.html","fragment":"blog/2015/6/5/building-aurelias-focus-attribute/index-fragment.html","self":"blog/2015/6/5/building-aurelias-focus-attribute/index.json"},"content":"\r\nThis week we are really excited to have our first community member highlight post! [Manuel Guilbault](https://github.com/manuel-guilbault/) is a Canadian-born, Paris-based developer, where he works as a consultant in the financial sector. Passionate about software craftsmanship, agility and lean principles, he loves to learn and debate about how we do things, why we do them this way and how they can be improved. This week we've invited Manuel to guest blog with us and share the work he did implementing a new custom attribute that's shipping in the next Aurelia update.\r\n\r\nTake it away Manuel....\r\n\r\n## Introduction\r\n\r\nI've been a huge fan of [Durandal](http://durandaljs.com/) and [Knockout JS ](http://knockoutjs.com/) for many years now, and I've been closely following Aurelia since I first heard about it. After playing with it for a while, I noticed that one of the features I used with Knockout was missing from Aurelia: a ```focus```binding. I decided to take advantage of the [Custom Attribute](http://aurelia.io/docs.html#custom-attributes) API to develop a ```focus``` custom attribute for Aurelia.\r\n\r\n### Requirements\r\n\r\nThe custom attribute I have in mind would be used this way:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    export class ViewModel {\r\n      hasFocus = false;\r\n    }\r\n  \r\n```\r\n\r\n\r\n  ```HTML\r\n    <input focus.bind=\"hasFocus\" />\r\n  \r\n```\r\n\r\nThe requirements are as follows:\r\n\r\n* When ```hasFocus``` is set to ```true```, the input gets focus;\r\n* When ```hasFocus``` is set to ```false```, the input loses focus;\r\n* When input gains focus following a user action, ```hasFocus``` is set to ```true```;\r\n* When input loses focus following a user action, ```hasFocus``` is set to ```false```.\r\n\r\nSo, what I want is basically a two-way binding between the bound property and the focus state of the input. You might think that this kind of two-way binding will trigger an infinite loop, but rest assured: Aurelia's binding module will take care of that.\r\n\r\n## Getting Started\r\n\r\nFirst, let's follow the [documentation](http://aurelia.io/docs.html#custom-attributes) and create an empty custom attribute:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {customAttribute, inject, bindingMode} from 'aurelia-framework';\r\n    \r\n    @customAttribute('focus', bindingMode.twoWay)\r\n    @inject(Element)\r\n    export class Focus {\r\n      constructor(element) {\r\n      \tthis.element = element;\r\n      }\r\n    \r\n      valueChanged(newValue) {\r\n      }\r\n    }\r\n  \r\n```\r\n\r\nThe first and easiest step is to listen for changes of the ```value``` property, and to react accordingly, by focusing or bluring the target element. This is done inside the ```valueChanged``` method: \r\n\r\n\r\n\r\n  ```JavaScript\r\n    valueChanged(newValue) {\r\n      if (newValue) {\r\n      \tthis.element.focus();\r\n      } else {\r\n      \tthis.element.blur();\r\n      }\r\n    }\r\n  \r\n```\r\n\r\nPretty simple! Now, when our view model's ```hasFocus``` property changes, the input is properly focused or blured.\r\n\r\nNext, the attribute's ```value``` property needs to be updated when the input receives or loses focus after a user action. To do this, we need to register event listeners on the element. As mentioned in the [documentation](http://aurelia.io/docs.html#custom-attributes), this should be done in the ```attached()``` method:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    attached() {\r\n      this.element.addEventListener('focus', e => this.value = true);\r\n      this.element.addEventListener('blur', e => this.value = false);\r\n    }\r\n  \r\n```\r\n\r\nStill pretty straight forward, right? Yet, something's still missing: the event listeners need to be removed when the element is ```detached()``` from the document:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    detached() {\r\n      this.element.removeEventListener('focus', e => this.value = true);\r\n      this.element.removeEventListener('blur', e => this.value = false);\r\n    }\r\n  \r\n```\r\n\r\nNow if you go and test what we have so far, and you are running this on a setup that doesn't fully support ECMAScript 6 and uses a transpiler (like [Babel](https://babeljs.io/)), you will see the ```removeEventListener``` calls don't work. This is because the ```attached()``` and ```detached()``` methods get transpiled this way:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    function attached() {\r\n      var _this2 = this;\r\n      this.element.addEventListener('focus', function(e) { _this2.value = true; });\r\n      this.element.addEventListener('blur', function(e) { _this2.value = false; });\r\n    }\r\n    \r\n    function detached() {\r\n      var _this3 = this;\r\n      this.element.removeEventListener('focus', function(e) { _this3.value = true; });\r\n      this.element.removeEventListener('blur', function(e) { _this3.value = false; });\r\n    }\r\n  \r\n```\r\n\r\nAs you can see, the removed listeners are are not the same as the added ones. Let's try and make them methods, to see if it works:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    onFocus(e) {\r\n      this.value = true;\r\n    }\r\n    \r\n    onBlur(e) {\r\n      this.value = false;\r\n    }\r\n    \r\n    attached() {\r\n      this.element.addEventListener('focus', this.onFocus);\r\n      this.element.addEventListener('blur', this.onBlur);\r\n    }\r\n    \r\n    detached() {\r\n      this.element.removeEventListener('focus', this.onFocus);\r\n      this.element.removeEventListener('blur', this.onBlur);\r\n    }\r\n  \r\n```\r\n\r\nIt still doesn't work: when the ```onFocus``` and ```onBlur``` listeners are called by the browser, ```this``` doesn't contain the ```Focus``` instance but the element that fired the event. That's actually a common mistake; I should have known better. Let's solve this issue by creating instance functions that capture ```this``` in their scope:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    constructor(element) {\r\n      this.element = element;\r\n    \r\n      this.focusListener = e => this.value = true;\r\n      this.blurListener = e => this.value = false;\r\n    }\r\n    \r\n    attached() {\r\n      this.element.addEventListener('focus', this.focusListener);\r\n      this.element.addEventListener('blur', this.blurListener);\r\n    }\r\n    \r\n    detached() {\r\n      this.element.removeEventListener('focus', this.focusListener);\r\n      this.element.removeEventListener('blur', this.blurListener);\r\n    }\r\n  \r\n```\r\n\r\nThat works fine now.\r\n\r\n## Fine-tuning\r\n\r\nWe now have a ```Focus``` custom attribute that answers to all of our initial requirements. But if you play a little bit with it, you will see that there are still some edge cases that are not yet covered.\r\n\r\n### Interaction With Other Attributes\r\n\r\nBy definition, a custom attribute is used to decorate an element, so it has to work along fine with other custom attributes that can be on the same element.\r\n\r\nWhat if the view model property bound to our ```focus``` attribute is also bound to the ```show``` attribute? This will be problematic, because depending on the order of evaluation when the bound property turns to ```true```, the target element may not be visible yet when our attribute tries to give it focus. We can solve this problem by using another part of Aurelia's API: the ```TaskQueue``` class.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {customAttribute, inject, bindingMode, TaskQueue} from 'aurelia-framework';\r\n    \r\n    @customAttribute('focus', bindingMode.twoWay)\r\n    @inject(Element, TaskQueue)\r\n    export class Focus {\r\n      constructor(element, taskQueue) {\r\n        this.element = element;\r\n        this.taskQueue = taskQueue;\r\n      }\r\n    \r\n      giveFocus() {\r\n        this.taskQueue.queueMicroTask(() => {\r\n          if (this.value) {\r\n          \tthis.element.focus();\r\n          }\r\n        });\r\n      }\r\n    \r\n      valueChanged(newValue) {\r\n        if (newValue) {\r\n          this.giveFocus();\r\n        } else {\r\n          this.element.blur();\r\n        }\r\n      }\r\n    } \r\n  \r\n```\r\n\r\nIn the above snippet, I first added injection of the ```TaskQueue``` instance into the ```Focus``` constructor. I also added a ```giveFocus()``` method, which will enqueue a microtask responsible for giving focus to the element. This will actually delay the ```focus()``` call by pushing it to the end of the binding queue. This will ensure that all queued events, including the bound property's value change, are processed before the focus is given.\r\n\r\n### Handling Window Change\r\n\r\nYou may have noticed that our ```Focus``` custom attribute does not react correctly when the element is focused and you change browser tabs. How can we fix that?\r\n\r\n\r\n\r\n  ```JavaScript\r\n    constructor(element) {\r\n      this.element = element;\r\n    \r\n      this.focusListener = e => this.value = true;\r\n      this.blurListener = e => {\r\n        if (document.activeElement !== this.element) {\r\n          this.value = false;\r\n        }\r\n      };\r\n    }\r\n  \r\n```\r\n\r\nIn the above code snippet, I changed the ```blurListener``` function, so that, when a ```blur``` event is triggered, the ```value``` is set to ```false``` only if the element is not the document's active element. This scenario occurs typically when you change tabs in the browser (or change window in the OS). By preventing setting ```value``` to ```false```, we prevent ```valueChanged(false)``` from being called, which would call ```element.blur()``` and would make the document's active element to become the body, and therefore cause the element to have lost focus when you go back to the browser tab.\r\n\r\n## Summary\r\n\r\nAs you can see, it is pretty easy to create new features for Aurelia. We were able to quickly come up with a new ```focus``` attribute, thanks to Aurelia's modular and extensible design."}