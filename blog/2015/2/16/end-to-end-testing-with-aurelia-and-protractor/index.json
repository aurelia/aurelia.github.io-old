{"name":"End-to-End Testing with Aurelia and Protractor","description":"This week Core Aurelia Team member in charge of testability, Vildan Softic, shows us how to write End-to-End tests with Aurelia and Protractor.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/2/16/end-to-end-testing-with-aurelia-and-protractor","html":"blog/2015/2/16/end-to-end-testing-with-aurelia-and-protractor/index.html","fragment":"blog/2015/2/16/end-to-end-testing-with-aurelia-and-protractor/index-fragment.html","self":"blog/2015/2/16/end-to-end-testing-with-aurelia-and-protractor/index.json"},"content":"\r\nThis week Core Aurelia Team member in charge of testability, Vildan Softic, shows us how to write End-to-End tests with Aurelia and Protractor.\r\n\r\n# Introduction\r\n\r\nTesting front-end applications has become an important task for today's _Full Stack Developers_. Not only do you want to ensure that your application's internal code operates correctly, but you also want to validate the in-browser behavior. This article will show you how to achieve this by combining Aurelia and Protractor.\r\n\r\n#### About The Author\r\n\r\n**Vildan Softic** is a consultant and software developer from Graz/Austria. He is passionate about developing Single Page Applications, grinding LOB Apps with .NET and is pushing more and more towards Node.JS development. Moreover, he is hopelessly in love with the Durandal Framework and, while still using other libraries in his day job, he's working hard contributing as much as possible to Aurelia.\r\n\r\nYou can find Vildan on [GitHub](https://github.com/zewa666) and [LinkedIn](https://www.linkedin.com/pub/vildan-softic/92/a03/635).\r\n\r\n# What is E2E testing?\r\n\r\nEnd-To-End (E2E) testing is all about testing your application against specific _scenarios_. From a requirements-engineering-perspective you'd call those _User Stories_. Essentially, these stories describe a series of actions a user performs to achieve a certain goal. So by assembling a bunch of these - referred to as a _test suite_ - you are able to verify that your web app acts as expected. The key to success, of course, lies in the amount and quality of tests written.   \r\n\r\nWith E2E testing you are not interacting with the app's code per se, but with the app's interface. This is different than unit tests, which take care of isolated parts of the application - called _units_ - by verifying them through the removal or mocking of other parts. It's important to note that one method of testing does not replace the other, so don't take this article as an excuse to skip unit testing. \r\n\r\n## How are E2E tests different?\r\n\r\nOne of the key differences when working with E2E tests is that all of your work is located in the browser, which naturally leads to writing a lot of _asynchronous code_. It doesn't matter whether you request a DOM Element, send some fake keystrokes or trigger a click, each of these actions needs to be automatically translated to understandable instructions and sent to the browser under test. So working with `Promises` becomes a major enabler when keeping track of deferred executions and responses.\r\n\r\nAnother important aspect already noted is the necessity to translate programmatic actions into browser understandable ones. Needless to say, variations exist between the different browsers...\r\n\r\nWhen performing E2E tests you also need to take into consideration that you are actually testing a real web page. So, compared to unit tests, you will additionally need your web page up and accessible by the browser during test execution. Keep in mind that E2E tests, sometimes also referred to as _integration tests_, test your app's system as a whole. Thus, modifications which get persisted to databases or local storage will stay that way and may produce side effects for your next test run.\r\n\r\nLast but not least, there is a much higher test code maintenance cost, compared to unit tests. The reason is that now, not only one component is tested exclusively, but rather the whole system at once. Imagine trying to fill out an input element with the id `txtFirstname`, just to realize the next day your tests fail because your fellow front-end designer decided to change the name to `txtFirstName`. This makes it clear that you must treat your test code like general application logic and give it all the love it deserves.\r\n\r\n# Protractor\r\n\r\nAlthough the previous section may sound depressing, there is hope for developers by the name of [Protractor](http://angular.github.io/protractor/#/). It is an End-To-End testing framework originally created for the JavaScript front-end framework [AngularJS](https://angularjs.org/). Under the hood it's actually a Node.js application, which supports a wide variety of assertion/test libraries like [Jasmine](http://jasmine.github.io/), [Mocha](http://mochajs.org/) or [Cucumber](https://github.com/cucumber/cucumber-js).\r\n\r\n> The rest of the article will focus on the BDD Testing Framework Jasmine.  A nice tutorial on how to use it can be [found here](http://code.tutsplus.com/tutorials/testing-your-javascript-with-jasmine--net-21229).\r\n\r\nProtractor acts as a wrapper on top of the WebDriverJS-API, which is used to communicate with a Selenium Server, either local (standalone) or remote. The picture below depicts the whole process. Protractor communicates via the WebDriverJS-API (the way to talk to Selenium's WebDriver API) which is used to translate user interactions into browser understandable instructions.\r\n\r\n![](https://raw.githubusercontent.com/aurelia/documentation/master/images/protractor.png)\r\n\r\nNow the interesting thing is that instead of manually testing your application in each of the major browsers, automated Protractor tests can run on multiple browsers at the same time, saving you valuable time and money. Support is wide-spread and even includes headless browsers like [PhantomJS](http://phantomjs.org/).\r\n\r\nBesides that, being a wrapper, it offers additional convenience features, not present in vanilla WebDriverJS-API. One feature, perhaps the most important, is that it allows you to write asynchronous tests in a synchronous style. This means that Protractor will automatically execute the next task, the moment the previous pending tasks finish.\r\n\r\n## A Basic Example\r\n\r\nTo get a basic idea of how this works, take a look at the following example.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    describe('aurelia homepage', function() {\r\n      it('should load page', function() {\r\n        browser.get('http://www.aurelia.io');\r\n        expect(browser.getTitle()).toEqual('Home | Aurelia');\r\n      });\r\n    }); \r\n  \r\n```\r\n\r\nAs you can see, the test utilizes Jasmine for BDD style testing which is placed in a separate JavaScript file and defines a scenario/suite by using a `describe` block. Each test then gets handled by a separate `it` function. In this one we'd like to verify that after loading the Aurelia Homepage, the title equals our expected page title. The first line will issue a general `browser` method `get` which loads the given URL. This function now returns a promise, to which you'd normally append a `then` function, which gets called after the promise successfully resolves. In this test case though, we don't need to care about that, because Protractor will execute the expectation only after the previous line has successfully resolved. Protractor also adapts the Jasmine expectations to work in an async way, so by the time matchers like `toEqual` are called, the previous expectation is already resolved.\r\n\r\nBut sometimes you need to wait for a certain action to happen in the future. Again we can leverage the general browser object and utilize it's `sleep` method.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    describe('aurelia homepage', function() {\r\n      it('should navigate to a different subpage', function() {\r\n        // load page\r\n        // navigate to different subpage\r\n        // wait for X to happen after 2 seconds\r\n        browser.sleep(2000)\r\n        expect(WHATEVER).toEqual(SOMETHING);\r\n      });\r\n    });\r\n  \r\n```\r\n\r\n## Accessing DOM Elements\r\n\r\nGreat! So we know how to load a page. But how do we find DOM Elements and see whether they are rendered properly? Protractor provides the global object `element`, an `EelementFinder`, which offers a *locator factory* `by` used to define a way to search for elements. Let's take a look at the following example. \r\n\r\n\r\n\r\n  ```JavaScript\r\n    describe('aurelia homepage', function() {\r\n      beforeEach(function() {\r\n        browser.get('http://www.aurelia.io');\r\n      })  \r\n      \r\n      it('should have proper header text set', function() {\r\n        expect(element(by.tagName('h2')).getText()).toBe('EXPECTED HEADER');\r\n      });\r\n    \r\n      it('should find an about section', function() {\r\n        expect(element(by.id('about')).isPresent()).toBe(true);\r\n      });\r\n    });\r\n  \r\n```\r\nThe first test is looking for an `<h2>` tag by utilizing the `tagName` *locator*. The second test looks for an element with the ID `about` and expects it to be rendered on the page. Here we use the `isPresent` method, provided by the `EelementFinder`. \r\n\r\nYou may have noticed the method `beforeEach` at the top of the describe block. This is a setup method, which will get called before each test in the current scope, being the current describe block. To perform _tear down_ operations, you'd simply define a function `afterEach`, which gets called after each test.\r\n\r\n> You can find a full list of _locators_ [here](http://angular.github.io/protractor/#/locators). Just keep in mind that everything specific to AngularJS, like `binding` or `model` won't work with Aurelia Apps.\r\n\r\n## Interacting with Forms\r\n\r\nNow we know how to work with general elements, but what about inputs? Wouldn't it be nice to fake data entries in order to verify the logic of a form? To do so, let's look at the next example. Our test will navigate to the Google homepage, search for a specific keyword, trigger the search and expect to see an element containing the given value.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    describe('google homepage', function() {\r\n      beforeEach(function() {\r\n        browser.get('http://www.google.com');\r\n      });\r\n      \r\n      it('should load page', function() {\r\n          element(by.name('q')).sendKeys('Aurelia');\r\n          element(by.name('btnG')).click();\r\n      \r\n          browser.sleep(2000);\r\n          expect(element(by.css('h3 a')).getText()).toContain('Aurelia');\r\n      });\r\n    });\r\n  \r\n```\r\nFirst we navigate to the page using `browser.get` and look for an input with the name `q`. The `sendKeys` method now simulates the keystrokes for the keyword _Aurelia_. Afterwards we perform a search by clicking the button named `btnG`. Now we need to wait for Google to perform the search and render the result. We therefore leverage the `browser.sleep` method to give it some time. Finally we look for a link containing the word _Aurelia_. \r\n\r\n# Protractor and Aurelia\r\n\r\nIn order to work with Protractor, there is a little configuration that is necessary. This is done in a configuration file, e.g. protractor.conf.js, which sets up the basic information for Protractor so it can find our test files, start the standalone Selenium server and wire up the `JasmineOptions` for the console output. The Aurelia [Skeleton Navigation App](https://github.com/aurelia/skeleton-navigation) thankfully already shares a preconfigured setup. Let's take a look at it.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    exports.config = {\r\n      directConnect: true,\r\n      capabilities: {\r\n        'browserName': 'chrome'\r\n      },\r\n      onPrepare: function() {\r\n        browser.ignoreSynchronization = true;\r\n    \r\n        by.addLocator('valueBind', function (bindingModel, opt_parentElement) {\r\n          var using = opt_parentElement || document;\r\n          var matches = using.querySelectorAll('*[value\\\\.bind=\"' + bindingModel +'\"]');\r\n          var result = undefined;\r\n    \r\n          if (matches.length === 0) {\r\n            result = null;\r\n          } else if (matches.length === 1) {\r\n            result = matches[0];\r\n          } else {\r\n            result = matches;\r\n          }\r\n    \r\n          return result;\r\n        });\r\n    },\r\n    \r\n      //seleniumAddress: 'http://0.0.0.0:4444',\r\n      //add proper version number\r\n      seleniumServerJar: './node_modules/gulp-protractor/node_modules/protractor/selenium/selenium-server-standalone-2.44.0.jar',\r\n      specs: ['specs/e2e/dist/*.js'],\r\n    \r\n      //Options to be passed to Jasmine-node.\r\n      jasmineNodeOpts: {\r\n        showColors: true,\r\n        defaultTimeoutInterval: 30000\r\n      }\r\n    };\r\n  \r\n```\r\n\r\nThe first setting tells Protractor to directly connect to the Browser leveraging its WebDriver, in this case, Chrome, defined by the `capabilities` property. By doing so, Protractor won't need a Selenium Server and will talk directly to the mentioned Browser.  \r\n\r\nThe method `onPrepare` is useful for setting up code before Protractor starts. The first line tells Protractor not to expect an AngularJS homepage, but let ourselves do the checking for when a page is fully loaded. Afterwards we add an Aurelia specific Locator named `valueBind` which looks for elements binding their value to a specific model. The option `seleniumServerJar` now may be omitted since we are using `directConnect`. If specified together, it will simply be ignored by Protractor.  \r\n\r\nThe property `specs` takes the path to our spec files. Since Aurelia is built from ground up with full support for ES6, we encourage developers to write their tests using ES6 features.   \r\n\r\nSince we'd like to start tests only when Aurelia is fully loaded, we leverage another feature of Protractor called `executeAsyncScript`.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    beforeEach(() => {\r\n      browser.get('http://localhost:9000');\r\n    \r\n      browser.executeAsyncScript(\r\n        'var cb = arguments[arguments.length - 1];' +\r\n        'document.addEventListener(\"aurelia-composed\", function (e) {' +\r\n        '  cb(\"Aurelia App composed\")' +\r\n        '}, false);'\r\n      ).then(function(result){\r\n          console.log(result);\r\n      });\r\n    });\r\n  \r\n```\r\nThis method provides a way to execute JavaScript directly in the inspected Web page and work with the results after completion. We use this feature to listen for a DOM event fired by Aurelia after initial view composition. By placing this in a `beforeEach` section, we ensure that none of the tests will be started before the async script successfully finishes.\r\n\r\n## Testing the Aurelia Skeleton Navigation App\r\n\r\nBesides having the configuration file set up, the Skeleton Navigation App also defines a set of demo tests to help you get started with testing your own page. First you'd need to download the App directly from our [Github-Repo](https://github.com/aurelia/skeleton-navigation), or install it via [Yeoman](https://github.com/zewa666/generator-aurelia) and follow the installation instruction. Afterwards, in order to start E2E testing, simply open up a console and run the following command to start up the built in web server:\r\n\r\n\r\n\r\n  ```Shell\r\n    gulp watch\r\n  \r\n```\r\n\r\nAfter that, open another console and hit the following command to start up the E2E test run:\r\n\r\n\r\n\r\n  ```Shell\r\n    gulp e2e\r\n  \r\n```\r\n\r\nYou will find the demo spec in the folder `test/e2e/src/`.\r\n\r\n### Page Objects\r\n\r\nTo conclude this article we're going to quickly look at how to structure tests. We organize our test methods using a pattern called _Page Objects_ (POs). What this means is that you try to group information about _how_ you access parts of the application into a separate class. This makes it simple to access specific elements multiple times. Now instead of repeating the `element.by.xxx` code over and over across multiple tests, we unify the access making it easier to maintain and modify. \r\n\r\nSince Aurelia promotes the use of ES6, our page objects are simple ES6 classes, exposing functionality through methods. These methods contain the logic for how to interact with Protractor. The following example shows our main Skeleton PO, which takes care of general application information like the page title and page navigation. \r\n\r\n\r\n\r\n  ```JavaScript\r\n    export class PageObject_Skeleton {\r\n      constructor() {}\r\n    \r\n      getCurrentPageTitle() {\r\n        return browser.getTitle();\r\n      }\r\n    \r\n      navigateTo(href) {\r\n        var deferred = protractor.promise.defer();\r\n        element(by.css('a[href=\"' + href + '\"]')).click().then( () => {\r\n          browser.sleep(2000);\r\n          deferred.fulfill(true);\r\n        });\r\n    \r\n        return deferred.promise;\r\n      }\r\n    }\r\n  \r\n```\r\n\r\nThe second PO is all about the Welcome page.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    export class PageObject_Welcome {\r\n      constructor() {}\r\n    \r\n      getGreeting() {\r\n        return element(by.tagName('h2')).getText();\r\n      }\r\n    \r\n      setFirstname(value) {\r\n        return element(by.valueBind('firstName')).clear().sendKeys(value);\r\n      }\r\n    \r\n      setLastname(value) {\r\n        return element(by.valueBind('lastName')).clear().sendKeys(value);\r\n      }\r\n    \r\n      getFullname() {\r\n        return element(by.css('.help-block')).getText();\r\n      }\r\n    \r\n      pressSubmitButton() {\r\n        return element(by.css('button[type=\"submit\"]')).click();\r\n      }\r\n    \r\n      openAlertDialog() {\r\n        return browser.wait(() => {\r\n          this.pressSubmitButton();\r\n    \r\n          return browser.switchTo().alert().then(\r\n            function(alert) { alert.dismiss(); return true; },\r\n            function() { return false; }\r\n          );\r\n        });\r\n      }\r\n    }\r\n  \r\n```\r\n\r\n### Test Specification\r\n\r\nThe previously defined page objects can now be imported into our test specification by leveraging the ES6 `import` syntax. Using `beforeEach` we can instantiate the POs, navigate to the Web app and wait for the previously mentioned `aurelia-composed` event to start testing.\r\n\r\nOur page object methods, in combination with Jasmine's BDD style assertions, make each test become an easy to read English sentence.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {PageObject_Welcome} from './welcome.po.js';\r\n    import {PageObject_Skeleton} from './skeleton.po.js';\r\n    \r\n    describe('aurelia skeleton app', function() {\r\n      var po_welcome,\r\n          po_skeleton;\r\n    \r\n      beforeEach( () => {\r\n        po_skeleton = new PageObject_Skeleton();\r\n        po_welcome = new PageObject_Welcome();\r\n    \r\n        browser.get('http://localhost:9000');\r\n    \r\n        browser.executeAsyncScript(\r\n          'var cb = arguments[arguments.length - 1];' +\r\n          'document.addEventListener(\"aurelia-composed\", function (e) {' +\r\n          '  cb(\"Aurelia App composed\")' +\r\n          '}, false);'\r\n        ).then(function(result){\r\n            console.log(result);\r\n        });\r\n      });\r\n    \r\n      it('should load the page and display the initial page title', () => {\r\n        expect(po_skeleton.getCurrentPageTitle()).toBe('Welcome | Aurelia');\r\n      });\r\n    \r\n      it('should display greeting', () => {\r\n        expect(po_welcome.getGreeting()).toBe('Welcome to the Aurelia Navigation App!');\r\n      });\r\n    \r\n      it('should automatically write down the fullname', () => {\r\n        po_welcome.setFirstname('Rob');\r\n        po_welcome.setLastname('Eisenberg');\r\n        expect(po_welcome.getFullname()).toBe('ROB EISENBERG');\r\n      });\r\n    \r\n      it('should show alert message when clicking submit button', () => {\r\n        expect(po_welcome.openAlertDialog()).toBe(true);\r\n      });\r\n    \r\n      it('should navigate to flickr page', () => {\r\n        po_skeleton.navigateTo('#/flickr');\r\n        expect(po_skeleton.getCurrentPageTitle()).toBe('Flickr | Aurelia');\r\n      });\r\n    });\r\n  \r\n```\r\n\r\n# Summary\r\n\r\nWe hope you enjoyed this introduction to E2E Testing with Protractor and the Aurelia Framework. Start writing tests and see how it feels. If you encounter any problems join us in [our gitter channel](https://gitter.im/Aurelia/Discuss)."}