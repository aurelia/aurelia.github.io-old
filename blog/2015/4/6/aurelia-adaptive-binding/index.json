{"name":"Aurelia's Adaptive Binding","description":"This week, Core Team Member, Jeremy Danyow [https://github.com/jdanyow], shares with us how Aurelia's adaptive and extensible binding system works its magic.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/4/6/aurelia-adaptive-binding","html":"blog/2015/4/6/aurelia-adaptive-binding/index.html","fragment":"blog/2015/4/6/aurelia-adaptive-binding/index-fragment.html","self":"blog/2015/4/6/aurelia-adaptive-binding/index.json"},"content":"\nThis week, Core Team Member, [Jeremy Danyow](https://github.com/jdanyow), shares with us how Aurelia's adaptive and extensible binding system works its magic.\n\n## Observation Strategies\n\n[Aurelia](http://aurelia.io) employs several strategies when observing object properties.  The best strategy is chosen depending on the features of the browser and the type of object/property being observed.  Here's a run-down of the techniques used, in order of priority.\n \n> Note:  the following doesn't cover Aurelia's strategies for observing Arrays.  That's a subject for another post :)\n \n**1. Is the object being observed a DOM element?**\n \n  In this case an observer is chosen based on the element's type and the name of the element attribute being bound:\n  \n  * `<select>` element's `value` attribute?  Use the `SelectValueObserver` which simplifies [common scenarios](http://jdanyow.github.io/aurelia-examples/#/select-test) like two-way binding strings or objects or binding arrays in multi-select scenarios.\n \n  * `<input>` element's `checked` attribute?  Use the `CheckedObserver` which enables two-way binding a group of radios to a single \"selected item\" property as well as checkboxes to a \"selected items\" array.  Here are a [few examples](http://jdanyow.github.io/aurelia-examples/#checked-test) of what's possible with checked binding.\n \n  *  `<input>` or `<textarea>` element's `value` attribute?  Use the `ValueAttributeObserver` which enables two way binding of input values.\n  \n  * `xlink:`, `data-*`, `aria-*` attribute?  Each of these require specific logic around attribute value assignment and retrieval.  Aurelia includes specialized observers for these cases.\n  \n  * `style` attribute or it's alias, the `css` attribute?  Use the `StyleObserver` which enables binding strings or objects to an element's `style.cssText`.\n  \n  * All other scenarios fall through to #2 below...\n \n**2. Does the property being observed have a getter function (ie was the property defined using [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty))?**\n \n [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe) cannot be used in this scenario, at least not until [Object.getNotifier](http://arv.github.io/ecmascript-object-observe/#the-notifier-object) is well supported across browsers.  In this case Aurelia will first check whether [dependencies have been declared](#declaringpropertydependencies) for the property.  If no dependencies are declared Aurelia will check whether a [property observation adapter](#propertyobservationadapters) knows how to observe the property.  *Otherwise Aurelia falls back to dirty checking*.\n \n**3. OK, we have a standard object property...**\n \n  Use the **preferred** observation strategy, [**Object.observe**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe) if the browser supports it, otherwise re-write the property using [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) so  Aurelia can intercept the property assignments.\n \nAll this strategy-picking logic is encapsulated in [aurelia/binding's](https://github.com/aurelia/binding) `ObserverLocator` class.\n \n## Declaring Property Dependencies\nAny time you create a computed property on your view model you're introducing a situation where Aurelia needs to use dirty-checking to observe the property.  Most of the time this isn't a big deal but in situations where dirty-checking is used a lot your app will use more memory and potentially perform poorly.\n \nThe Aurelia \"starter kit\" app: [skeleton-navigation](https://github.com/aurelia/skeleton-navigation), includes a scenario where dirty-checking is required:  the `fullName` property.\n \n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export class Welcome{\n      constructor(){\n        this.heading = 'Welcome to the Aurelia Navigation App!';\n        this.firstName = 'John';\n        this.lastName = 'Doe';\n      }\n     \n      // **this property will require dirty-checking**\n      get fullName(){\n        return `${this.firstName} ${this.lastName}`;\n      }\n     \n      welcome(){\n        alert(`Welcome, ${this.fullName}!`);\n      }\n    }\n  </source-code>\n</code-listing>\n \nTo avoid dirty-checking we can tell Aurelia the `fullName` property's dependencies are `firstName` and `lastName`.  This will save Aurelia from having to constantly poll the `fullName` property for changes because it can observe `firstName` and `lastName` directly.  \n \nHere's how you declare property dependencies today:\n \n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // add this line:\n    import {declarePropertyDependencies} from 'aurelia-framework';\n     \n    // nothing changes in the class itself.\n    export class Welcome{\n      ...\n    }\n     \n    // and add this line:\n    declarePropertyDependencies(Welcome, 'fullName', ['firstName', 'lastName']);  \n  </source-code>\n</code-listing>\n \nDecorators are now supported in [babel](https://babeljs.io/) and [Typescript 1.5 alpha](http://blogs.msdn.com/b/typescript/archive/2015/03/27/announcing-typescript-1-5-alpha.aspx).  With this important feature in place, declaring property dependencies in Aurelia will be even easier after our release next week:\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    @computedFrom('firstName', 'lastName')\n    get fullName(){\n      return `${this.firstName} ${this.lastName}`;\n    }\n  </source-code>\n</code-listing>\n \n## Property Observation Adapters\nThe Aurelia binding system is pluggable.  This means you can supply an adapter to Aurelia that can observe certain types of properties when Aurelia isn't able to use a preferred binding strategy.\n \nA couple binding adapters are already in development.  One is for observing [Breeze](http://www.getbreezenow.com/) entities.  Breeze is a data management framework that employs property getters and setters to enable entity-state tracking when properties are changed.  You can find the aurelia-breeze plugin [here](https://github.com/jdanyow/aurelia-breeze).\n \nA second property observation adapter for [KnockoutJS](http://knockoutjs.com/) observables is [in development](https://github.com/jdanyow/aurelia-knockout).\n \n \n## Using the ObserverLocator\nSituations often [crop up](http://stackoverflow.com/questions/28419242/property-subscription-in-aurelia) where you need to observe a property's changes, outside of the standard data-binding scenarios Aurelia makes  easy.  It would be nice if we could simply use Object.observe in these scenarios.  Unfortunately [caniuse](http://caniuse.com/#feat=object-observe) says this is not an option in today's browser environment.\n \nThe good news is you can use Aurelia's ObserverLocator which provides a cross-browser approach for observing properties.  All you need to do is grab the observer locator from the container and start subscribing.\n \n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {ObserverLocator} from 'aurelia-binding';  // or 'aurelia-framework'\n     \n    class Foo {\n      static inject function() { return [ObserverLocator]; }\n      constructor(observerLocator) {\n        // the property we'll observe:\n        this.bar = 'baz';\n        \n        // subscribe to the \"bar\" property's changes:\n        var subscription = this.observerLocator\n          .getObserver(this, 'bar')\n          .subscribe(this.onChange);\n      }\n      \n      onChange(newValue, oldValue) {\n        alert(`bar changed from ${oldValue} to ${newValue}`);\n      }\n    }\n  </source-code>\n</code-listing>\n \nAs with any event subscription you need to unsubscribe/dispose-it when you no longer need it, to prevent memory leaks, etc.  This is why the `subscribe` method returns a function you can invoke to dispose of the subscription.\n \n> Note: future versions of Aurelia will include a more streamlined way to subscribe to property changes.\n \n### Doing more with the ObserverLocator\n \nA scenario came up in the Aurelia [gitter chat](https://gitter.im/Aurelia/Discuss) the other day where someone needed to update a property in their view-model when properties in another object changed.  To simplify the logic around this we put together a generic \"MultiObserver\" class that can observe any number of object properties and invoke a callback when something changes:\n \n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {ObserverLocator} from 'aurelia-framework'; // or 'aurelia-binding'\n     \n    export class MultiObserver {\n      static inject() { return [ObserverLocator]; }\n      constructor(observerLocator) {\n        this.observerLocator = observerLocator;\n      }\n     \n      observe(properties, callback) {\n        var subscriptions = [], i = properties.length, object, propertyName;\n        while(i--) {\n          object = properties[i][0];\n          propertyName = properties[i][1];\n          subscriptions.push(this.observerLocator.getObserver(object, propertyName).subscribe(callback));\n        }\n     \n        // return dispose function\n        return () => {\n          while(subscriptions.length) {\n            subscriptions.pop()();\n          }\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n \nUsing the MultiObserver we can create an OilSpeculator class that reacts to the different factors involved in speculating oil prices:\n \n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {MultiObserver} from 'multi-observer';\n    import {OilReserves} from 'oil-reserves';\n    import {Mood} from 'temperment';\n    import {FudgeFactor} from 'guessing';\n     \n    export class OilSpeculator {\n      static inject() { return [OilReserves, Mood, FudgeFactor, MultiObserver]; }\n      constructor(oilReserves, mood, fudgeFactor, multiObserver) {\n        this.oilReserves = oilReserves;\n        this.mood = mood;\n        this.fudgeFactor = fudgeFactor;\n        this.speculateOilPrice();\n        \n        // speculate the oil price when something changes... \n        multiObserver.observe(\n          [[oilReserves, 'barrels'],\n           [mood, 'crankiness'],\n           [fudgeFactor, 'value']],\n          () => this.speculateOilPrice());\n      }\n      \n      speculateOilPrice() {\n        this.oilPrice = this.mood.crankiness * this.oilReserves.barrels / this.fudgeFactor.value;\n      }\n    }\n  </source-code>\n</code-listing>"}