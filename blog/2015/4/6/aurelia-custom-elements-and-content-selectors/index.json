{"name":"Aurelia Custom Elements & Content Selectors","description":"This week, Core Aurelia Team member, Patrick Walters [https://github.com/PWKad], shows us how to create custom elements that leverage content selectors.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/4/6/aurelia-custom-elements-and-content-selectors","html":"blog/2015/4/6/aurelia-custom-elements-and-content-selectors/index.html","fragment":"blog/2015/4/6/aurelia-custom-elements-and-content-selectors/index-fragment.html","self":"blog/2015/4/6/aurelia-custom-elements-and-content-selectors/index.json"},"content":"\nThis week, Core Aurelia Team member, [Patrick Walters](https://github.com/PWKad), shows us how to create custom elements that leverage content selectors.\n\n> **Warning:** This blog post covers a deprecated version of Shadow DOM, known as Shadow DOM v0. Aurelia 1.0 and beyond uses the current specification, known as Shadow DOM v1, which leverages *slots*. [Please read our official documentation for more information](http://aurelia.io/hub.html#/doc/article/aurelia/templating/latest/templating-content-projection).\n\n### About the Author\n\nPatrick is a developer living in the DFW area and is passionate about making the developer experience as seamless and easy as possible in Aurelia, based on leveraging ideas from studying many other languages and frameworks.  His preferred stack is Aurelia with Ruby on Rails and his preferred development environment is Sublime Text 3 with iTerm2 and Chrome.\n\n**Code samples**: [aurelia-modal on github](https://github.com/PWKad/aurelia-modal.git)\n\n## The Problem\n\nImagine that you want to have a modal dialog in your application but you don't want to have to include a ton of HTML every time you use it. You also might want to toggle the visibility of different sections of the modal, depending on its use. Perhaps you also want to be able to skin it differently based on its content.\n\n## The Solution\n\nWith Aurelia we can create custom elements that take advantage of Content Selectors to solve these problems. Aurelia uses concepts from the [Shadow DOM](http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/#toc-separation) to separate content and presentation. To see how this works we'll build a single, shared modal dialog that dynamically changes its content as needed. This will give us a single visibility property to manage.  We will use Aurelia's `compose` and `custom elements` to swap out the content. Finally, we'll leverage content selectors to allow re-skinning the modal more easily and further abstracting style-specific logic out of our view, making it is easier to adjust styling.\n\n## Starting Out\n\nAs always let's get an Aurelia app running. To begin, download the [navigation skeleton](https://github.com/aurelia/skeleton-navigation/releases) and unzip it. After that, we need to do some basic setup at the root of that project directory.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    $ npm install\n    $ jspm install -y\n    \n    $ gulp watch\n  </source-code>\n</code-listing>\n\nNow we have our app being served at [localhost:9000](http://localhost:9000).\n\n## Using our Modal Dialog\n\nIn our `src/app.html` file, let's add a basic usage of the modal dialog that we want to create:\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <modal>\n      <modal-header title=\"Edit Person\"></modal-header>\n      <modal-body content=\"person-information\"></modal-body>\n      <modal-footer buttons.bind=\"['Cancel']\"></modal-footer>\n    </modal>\n  </source-code>\n</code-listing>\n\nHere we are using a `modal` custom element and and setting the `header`, `body`, and `footer` of it.  So far we haven't actually created these custom elements, but I wanted to show you first how they would be used, so you can understand the purpose of the following steps which describe their creation.\n\n## Creating the Modal Element\n\nLet's create the `modal` element first. There are two parts for each of the elements we will create, the View (HTML) and the View-Model (JS). Let's start with the view.\n\n**View** - *modal.html*\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <div class=\"modal fade\" ref=\"modal\">\n        <div class=\"modal-dialog\">\n          <div class=\"modal-content\">\n            <content select=\"modal-header\"></content>\n            <content select=\"modal-body\"></content>\n            <content select=\"modal-footer\"></content>\n          </div>\n        </div>\n      </div>\n    </template>\n  </source-code>\n</code-listing>\n\nHere we are using Bootstrap's default modal implementation.  Did you notice the `content selectors` in the `modal-content` div?  That is how we tell our modal element where to render the different content types that we defined in the app.html. The value of the `select` attribute is actually a CSS Selector. Cool isn't it?\n\nHere's the View-Model that encapsulates the behavior of the modal:\n\n**View-Model** - *modal.js*\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import $ from 'jquery';\n    \n    export class Modal {\n      attached(){\n        $(this.modal).modal();\n      }\n    }\n  </source-code>\n</code-listing>\n\nYou can see in our *attached* callback that all we are doing is passing our referenced modal to the Bootstrap modal plugin.\n\n## Creating The Header and Footer\n\nNow, let's create the header and footer elements. We'll start with the header's view: \n\n**View** - *modal-header.html*\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n          <span aria-hidden=\"true\">&times;</span>\n        </button>\n        <h4 class=\"modal-title\">${title}</h4>\n      </div>\n    </template>\n  </source-code>\n</code-listing>\nAgain, this is just a base Bootstrap modal header.  The only adjustment we've made is to add a string interpolation binding to render the title into the `h4` element. Here's how we define the accompanying view-model:\n\n**View-Model** - *modal-header.js*\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {bindable} from 'aurelia-framework';\n    \n    export class ModalHeader {\n      @bindable title = '';\n    }\n  </source-code>\n</code-listing>\n\nWe create the bindable property `title` with a default value of `''` (empty string).  Also, note that we are using ES7 property initializers to create the property.  If we didn't want to (or couldn't) use ES7 property initializers, we could always write that same code using class decorators, like this: \n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {bindable} from 'aurelia-framework';\n    \n    @bindable({name:'title', defaultValue:''})\n    export class ModalHeader{}\n  </source-code>\n</code-listing>\n\nAnd, just for the sake of completeness, if you didn't want to use any ES7 features, you could use pure ES6 like this:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {Decorators} from 'aurelia-framework';\n    \n    export class ModalHeader{\n      static decorators(){ \n        return Decorators.bindable({name:'title', defaultValue:''});\n      }\n    }\n  </source-code>\n</code-listing>\n\nRemember though, in all cases, this creates a custom element with a single HTML bindable property \"title\" that has a default value of the empty string.\n\nThe footer is constructed in a similar way. Let's see the view first:\n\n**View** - *modal-footer.html*\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" repeat.for=\"button of buttons\">${button}</button>\n      </div>\n    </template>\n  </source-code>\n</code-listing>\n\nAgain, it's just the base bootstrap footer, but we've changed the button so we can display more, based on what is bound.\n\n**View-model** - *modal-footer.js*\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {bindable} from 'aurelia-framework';\n    \n    export class ModalFooter {\n      @bindable buttons = [];\n    }\n  </source-code>\n</code-listing>\n\nAgain we create a buttons property that is bindable and is an array which will contain the labels for our buttons.\n\n## Creating the Body\n\nNow we need our modal-body template. It will be in charge of what gets shown in the main content area. \n\n**View** - *modal-body.html*\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <div class=\"modal-body\">\n        <compose view-model.bind=\"content\"></compose>\n      </div>\n    </template>\n  </source-code>\n</code-listing>\nIt is the base bootstrap body, but we've added Aurelia's `compose` element with a binding so that it renders whatever gets set for the content property. Here's the view-model:\n\n**View-model** - *modal-body.js*\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {bindable} from 'aurelia-framework';\n    \n    export class ModalBody {\n      @bindable content;\n    }\n  </source-code>\n</code-listing>\n\nOur content will be a string property which tells the view what to compose into the body.\n\n## Content to Render\n\nWe need to have some content to dynamically compose into the body of our modal.  Let's just steal from the starter kit's welcome.html in order to keep things simple:\n\n**View** - *person-information.html*\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <template>\n      <form role=\"form\">\n        <div class=\"form-group\">\n          <label for=\"fn\">First Name</label>\n          <input type=\"text\" value.bind=\"person.firstName\" class=\"form-control\" id=\"fn\" placeholder=\"first name\">\n        </div>\n        <div class=\"form-group\">\n          <label for=\"ln\">Last Name</label>\n          <input type=\"text\" value.bind=\"person.lastName\" class=\"form-control\" id=\"ln\" placeholder=\"last name\">\n        </div>\n      </form>\n    </template>\n  </source-code>\n</code-listing>\n\n**View-Model** - *person-information.js*\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export class PersonInformation {\n      constructor() {\n        this.person = new Person();\n      }\n    }\n    \n    class Person{\n      firstName = 'Patrick';\n      lastName = 'Patrick';\n    }\n  </source-code>\n</code-listing>\nHere we just create a person class and instantiate it to be our 'person'.  This will provide some demo data for our `person-information.html` \n\n## Summary\n\nNow, we have all the pieces for a functioning modal dialog which can dynamically display different content! To use it, don't forget to `require` the elements in your view or register them globally at startup (this is what my plugin does). As a reminder, here's the html you can now write to build a modal:\n\n\n<code-listing>\n  <source-code lang=\"HTML\">\n    <modal>\n      <modal-header title=\"Edit Person\"></modal-header>\n      <modal-body content=\"person-information\"></modal-body>\n      <modal-footer buttons.bind=\"['Cancel']\"></modal-footer>\n    </modal>\n  </source-code>\n</code-listing>\n\nFor the title we just used a string.  The modal-body has a content property that tells it which template to render as the body.  You can see this in our `modal-body.html` where we used the `compose` binding to render some content.  Finally, buttons is an array of button labels to show in our modal.\n\nWe've separated our template logic that is specific to bootstrap out of our main app.  Now if we wanted to we could switch from Bootstrap to Semantic-ui or some other CSS framework and swap it in and out as needed. That's it!"}