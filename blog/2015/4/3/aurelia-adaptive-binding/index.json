{"name":"Aurelia's Adaptive Binding","description":"This week, Core Team Member, Jeremy Danyow [https://github.com/jdanyow], shares with us how Aurelia's adaptive and extensible binding system works its magic.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/4/3/aurelia-adaptive-binding","html":"blog/2015/4/3/aurelia-adaptive-binding/index.html","fragment":"blog/2015/4/3/aurelia-adaptive-binding/index-fragment.html","self":"blog/2015/4/3/aurelia-adaptive-binding/index.json"},"content":"\r\nThis week, Core Team Member, [Jeremy Danyow](https://github.com/jdanyow), shares with us how Aurelia's adaptive and extensible binding system works its magic.\r\n\r\n## Observation Strategies\r\n\r\n[Aurelia](http://aurelia.io) employs several strategies when observing object properties.  The best strategy is chosen depending on the features of the browser and the type of object/property being observed.  Here's a run-down of the techniques used, in order of priority.\r\n \r\n> Note:  the following doesn't cover Aurelia's strategies for observing Arrays.  That's a subject for another post :)\r\n \r\n**1. Is the object being observed a DOM element?**\r\n \r\n  In this case an observer is chosen based on the element's type and the name of the element attribute being bound:\r\n  \r\n  * `<select>` element's `value` attribute?  Use the `SelectValueObserver` which simplifies [common scenarios](http://jdanyow.github.io/aurelia-examples/#/select-test) like two-way binding strings or objects or binding arrays in multi-select scenarios.\r\n \r\n  * `<input>` element's `checked` attribute?  Use the `CheckedObserver` which enables two-way binding a group of radios to a single \"selected item\" property as well as checkboxes to a \"selected items\" array.  Here are a [few examples](http://jdanyow.github.io/aurelia-examples/#checked-test) of what's possible with checked binding.\r\n \r\n  *  `<input>` or `<textarea>` element's `value` attribute?  Use the `ValueAttributeObserver` which enables two way binding of input values.\r\n  \r\n  * `xlink:`, `data-*`, `aria-*` attribute?  Each of these require specific logic around attribute value assignment and retrieval.  Aurelia includes specialized observers for these cases.\r\n  \r\n  * `style` attribute or it's alias, the `css` attribute?  Use the `StyleObserver` which enables binding strings or objects to an element's `style.cssText`.\r\n  \r\n  * All other scenarios fall through to #2 below...\r\n \r\n**2. Does the property being observed have a getter function (ie was the property defined using [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty))?**\r\n \r\n [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe) cannot be used in this scenario, at least not until [Object.getNotifier](http://arv.github.io/ecmascript-object-observe/#the-notifier-object) is well supported across browsers.  In this case Aurelia will first check whether [dependencies have been declared](#declaringpropertydependencies) for the property.  If no dependencies are declared Aurelia will check whether a [property observation adapter](#propertyobservationadapters) knows how to observe the property.  *Otherwise Aurelia falls back to dirty checking*.\r\n \r\n**3. OK, we have a standard object property...**\r\n \r\n  Use the **preferred** observation strategy, [**Object.observe**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe) if the browser supports it, otherwise re-write the property using [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) so  Aurelia can intercept the property assignments.\r\n \r\nAll this strategy-picking logic is encapsulated in [aurelia/binding's](https://github.com/aurelia/binding) `ObserverLocator` class.\r\n \r\n## Declaring Property Dependencies\r\nAny time you create a computed property on your view model you're introducing a situation where Aurelia needs to use dirty-checking to observe the property.  Most of the time this isn't a big deal but in situations where dirty-checking is used a lot your app will use more memory and potentially perform poorly.\r\n \r\nThe Aurelia \"starter kit\" app: [skeleton-navigation](https://github.com/aurelia/skeleton-navigation), includes a scenario where dirty-checking is required:  the `fullName` property.\r\n \r\n\r\n\r\n  ```JavaScript\r\n    export class Welcome{\r\n      constructor(){\r\n        this.heading = 'Welcome to the Aurelia Navigation App!';\r\n        this.firstName = 'John';\r\n        this.lastName = 'Doe';\r\n      }\r\n     \r\n      // **this property will require dirty-checking**\r\n      get fullName(){\r\n        return `${this.firstName} ${this.lastName}`;\r\n      }\r\n     \r\n      welcome(){\r\n        alert(`Welcome, ${this.fullName}!`);\r\n      }\r\n    }\r\n  \r\n```\r\n \r\nTo avoid dirty-checking we can tell Aurelia the `fullName` property's dependencies are `firstName` and `lastName`.  This will save Aurelia from having to constantly poll the `fullName` property for changes because it can observe `firstName` and `lastName` directly.  \r\n \r\nHere's how you declare property dependencies today:\r\n \r\n\r\n\r\n  ```JavaScript\r\n    // add this line:\r\n    import {declarePropertyDependencies} from 'aurelia-framework';\r\n     \r\n    // nothing changes in the class itself.\r\n    export class Welcome{\r\n      ...\r\n    }\r\n     \r\n    // and add this line:\r\n    declarePropertyDependencies(Welcome, 'fullName', ['firstName', 'lastName']);  \r\n  \r\n```\r\n \r\nDecorators are now supported in [babel](https://babeljs.io/) and [Typescript 1.5 alpha](http://blogs.msdn.com/b/typescript/archive/2015/03/27/announcing-typescript-1-5-alpha.aspx).  With this important feature in place, declaring property dependencies in Aurelia will be even easier after our release next week:\r\n\r\n\r\n  ```JavaScript\r\n    @computedFrom('firstName', 'lastName')\r\n    get fullName(){\r\n      return `${this.firstName} ${this.lastName}`;\r\n    }\r\n  \r\n```\r\n \r\n## Property Observation Adapters\r\nThe Aurelia binding system is pluggable.  This means you can supply an adapter to Aurelia that can observe certain types of properties when Aurelia isn't able to use a preferred binding strategy.\r\n \r\nA couple binding adapters are already in development.  One is for observing [Breeze](http://www.getbreezenow.com/) entities.  Breeze is a data management framework that employs property getters and setters to enable entity-state tracking when properties are changed.  You can find the aurelia-breeze plugin [here](https://github.com/jdanyow/aurelia-breeze).\r\n \r\nA second property observation adapter for [KnockoutJS](http://knockoutjs.com/) observables is [in development](https://github.com/jdanyow/aurelia-knockout).\r\n \r\n \r\n## Using the ObserverLocator\r\nSituations often [crop up](http://stackoverflow.com/questions/28419242/property-subscription-in-aurelia) where you need to observe a property's changes, outside of the standard data-binding scenarios Aurelia makes  easy.  It would be nice if we could simply use Object.observe in these scenarios.  Unfortunately [caniuse](http://caniuse.com/#feat=object-observe) says this is not an option in today's browser environment.\r\n \r\nThe good news is you can use Aurelia's ObserverLocator which provides a cross-browser approach for observing properties.  All you need to do is grab the observer locator from the container and start subscribing.\r\n \r\n\r\n\r\n  ```JavaScript\r\n    import {ObserverLocator} from 'aurelia-binding';  // or 'aurelia-framework'\r\n     \r\n    class Foo {\r\n      static inject function() { return [ObserverLocator]; }\r\n      constructor(observerLocator) {\r\n        // the property we'll observe:\r\n        this.bar = 'baz';\r\n        \r\n        // subscribe to the \"bar\" property's changes:\r\n        var subscription = this.observerLocator\r\n          .getObserver(this, 'bar')\r\n          .subscribe(this.onChange);\r\n      }\r\n      \r\n      onChange(newValue, oldValue) {\r\n        alert(`bar changed from ${oldValue} to ${newValue}`);\r\n      }\r\n    }\r\n  \r\n```\r\n \r\nAs with any event subscription you need to unsubscribe/dispose-it when you no longer need it, to prevent memory leaks, etc.  This is why the `subscribe` method returns a function you can invoke to dispose of the subscription.\r\n \r\n> Note: future versions of Aurelia will include a more streamlined way to subscribe to property changes.\r\n \r\n### Doing more with the ObserverLocator\r\n \r\nA scenario came up in the Aurelia [gitter chat](https://gitter.im/Aurelia/Discuss) the other day where someone needed to update a property in their view-model when properties in another object changed.  To simplify the logic around this we put together a generic \"MultiObserver\" class that can observe any number of object properties and invoke a callback when something changes:\r\n \r\n\r\n\r\n  ```JavaScript\r\n    import {ObserverLocator} from 'aurelia-framework'; // or 'aurelia-binding'\r\n     \r\n    export class MultiObserver {\r\n      static inject() { return [ObserverLocator]; }\r\n      constructor(observerLocator) {\r\n        this.observerLocator = observerLocator;\r\n      }\r\n     \r\n      observe(properties, callback) {\r\n        var subscriptions = [], i = properties.length, object, propertyName;\r\n        while(i--) {\r\n          object = properties[i][0];\r\n          propertyName = properties[i][1];\r\n          subscriptions.push(this.observerLocator.getObserver(object, propertyName).subscribe(callback));\r\n        }\r\n     \r\n        // return dispose function\r\n        return () => {\r\n          while(subscriptions.length) {\r\n            subscriptions.pop()();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n```\r\n \r\nUsing the MultiObserver we can create an OilSpeculator class that reacts to the different factors involved in speculating oil prices:\r\n \r\n\r\n\r\n  ```JavaScript\r\n    import {MultiObserver} from 'multi-observer';\r\n    import {OilReserves} from 'oil-reserves';\r\n    import {Mood} from 'temperment';\r\n    import {FudgeFactor} from 'guessing';\r\n     \r\n    export class OilSpeculator {\r\n      static inject() { return [OilReserves, Mood, FudgeFactor, MultiObserver]; }\r\n      constructor(oilReserves, mood, fudgeFactor, multiObserver) {\r\n        this.oilReserves = oilReserves;\r\n        this.mood = mood;\r\n        this.fudgeFactor = fudgeFactor;\r\n        this.speculateOilPrice();\r\n        \r\n        // speculate the oil price when something changes... \r\n        multiObserver.observe(\r\n          [[oilReserves, 'barrels'],\r\n           [mood, 'crankiness'],\r\n           [fudgeFactor, 'value']],\r\n          () => this.speculateOilPrice());\r\n      }\r\n      \r\n      speculateOilPrice() {\r\n        this.oilPrice = this.mood.crankiness * this.oilReserves.barrels / this.fudgeFactor.value;\r\n      }\r\n    }\r\n  \r\n```"}