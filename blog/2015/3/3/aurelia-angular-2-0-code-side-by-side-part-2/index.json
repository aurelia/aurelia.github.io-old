{"name":"Aurelia & Angular 2.0 Code Side by Side - Part 2","description":"Yesterday I showed an example of Angular 2.0 code side-by-side with Aurelia [http://blog.durandal.io/2015/03/16/aurelia-and-angular-2-code-side-by-side/]. I showed the \"reverse binding\" technique for Angular 2.0. Today I'm going to show how the Angular 2.0 Forms Model [https://docs.google.com/document/d/1US9h0ORqBltl71TlEU6s76ix8SUnOLE2jabHVg9xxEA/] can be used instead. I'll also show Aurelia next to it, so you can see the difference. Both examples will use the same Contact model.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/3/3/aurelia-angular-2-0-code-side-by-side-part-2","html":"blog/2015/3/3/aurelia-angular-2-0-code-side-by-side-part-2/index.html","fragment":"blog/2015/3/3/aurelia-angular-2-0-code-side-by-side-part-2/index-fragment.html","self":"blog/2015/3/3/aurelia-angular-2-0-code-side-by-side-part-2/index.json"},"content":"\nYesterday [I showed an example of Angular 2.0 code side-by-side with Aurelia](http://blog.durandal.io/2015/03/16/aurelia-and-angular-2-code-side-by-side/). I showed the \"reverse binding\" technique for Angular 2.0. Today I'm going to show how the [Angular 2.0 Forms Model](https://docs.google.com/document/d/1US9h0ORqBltl71TlEU6s76ix8SUnOLE2jabHVg9xxEA/) can be used instead. I'll also show Aurelia next to it, so you can see the difference. Both examples will use the same Contact model.\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    class Contact {\n      constructor(firstName, lastName){\n        this.firstName = firstName;\n        this.lastName = lastName;\n      }\n      \n      get fullName(){\n      \treturn `${this.firstName} ${this.lastName}`;\n      }\n    }\n  </source-code>\n</code-listing>\n\n<div>\n<div style=\"float: left; width: 50%\">\n<h3>Angular 2.0</h3>\n<strong>app.js</strong>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {Component, Template} from 'angular2/angular2';\n    \n    @Component({selector: 'my-app'})\n    @Template({url: 'app.html'})\n    class MyApp {\n      constructor() {\n        this.contact = new Contact('John', 'Doe');  \n        this.contactForm = new FormControlGroup(\"form\", [\n          new FormControl(\"firstName\"),\n          new FormControl(\"lastName\")\n        ]);\n        this.contactForm.readFrom(this.contact);\n      }\n    }\n  </source-code>\n</code-listing>\n</div>\n<div style=\"float: right; width: 48%\">\n<h3>Aurelia</h3>\n<strong>app.js</strong>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export class MyApp{\n      constructor(){\n        this.contact = new Contact('John', 'Doe');\n      }\n    }\n  </source-code>\n</code-listing>\n</div>\n</div>\n\n<div style=\"clear: both;\"></div>\n\nNote: Additional code is needed for Angular 2.0 if ES6/ES5/CoffeeScript is used rather than AtScript since annotations must be \"manually transpiled\" by the developer.\n\n<div>\n<div style=\"float: left; width: 50%\">\n<strong>app.html</strong>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    <form [control-group]='contactForm'>\n      First Name:\n      <input type=\"text\" control=\"firstName\">\n      Last Name:\n      <input type=\"text\" control=\"lastName\">\n      Full Name: {{contact.fullName}}\n    </form>\n  </source-code>\n</code-listing>\n</div>\n<div style=\"float: right; width: 48%\">\n<strong>app.html</strong>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    <form with.bind=\"contact\">\n      First Name:\n      <input type=\"text\" value.bind=\"firstName\">\n      Last Name:\n      <input type=\"text\" value.bind=\"lastName\">\n      Full Name: ${fullName}\n    </form>\n  </source-code>\n</code-listing>\n</div>\n</div>\n\n<div style=\"clear: both;\"></div>\n\nI wanted to let the code stand for itself, as in [yesterday's example](http://blog.durandal.io/2015/03/16/aurelia-and-angular-2-code-side-by-side/), but there is something that needs to be clarified about the Angular 2.0 code. It doesn't entirely work. At the bottom of the HTML file you can see where I have `{{contact.fullName}}`. This will not update in sync with the input controls. The reason is that all of the editable data is stored inside of the FormControl instances and not inside of the Contact model. The data is read in from the model with a call to `this.contactForm.readFrom(this.contact);` but after that point all state exists external to the model and is not synchronized. After a thorough study of [the Angular 2.0 Form Model design document](https://docs.google.com/document/d/1US9h0ORqBltl71TlEU6s76ix8SUnOLE2jabHVg9xxEA/), I could not determine how make this work without:\n\n1. Duplicating my model's internal logic by hard-coding it into the binding expressions inside the HTML form itself. So, we would have something like this `{{contactForm.controls.firstName.value}} {{contactForm.controls.lastName.value}}`. However, the design document explicitly calls this out as something that should not be done (because of implications on the binding system).\n2. Merging the Form Model code above, with the code from yesterday and manually calling `this.contactForm.writeTo(this.contact);` This will result in all the code used in \"reverse binding\" to be used to trigger calls to update the model. At this point, why use the Form Model?\n\nSo, at present, there doesn't seem to be a solution for this in Angular 2.0.\n\n#### Summary of Angular 2.0 Binding Approaches\n\nIf you've read both posts, you can see that there are two different approaches to databinding in Angular 2.0. Each requires using different APIs and binding techniques.\n\nWhile \"reverse binding\" appears to be capable of handling any input scenario, it requires authoring lots of code. In fact, what you have to place in your HTML is almost identical to what you would write in JavaScript if there was no binding system involved. This begs the question \"why do I need a framework if I have to write the same code anyway?\" Also you might be inclined to wonder why you now have to do it in HTML instead of JavaScript.\n\nOn the other hand, the Form Model lets you avoid the manual event wirups, but you must abandon your own model. It only works by creating an Angular FormControl model that matches the HTML structure. It's not clear how this approach can handle logic inside any existing model or whether it can allow the creation of more dynamic, data-driven forms. It's also not obvious how a model can be read in that doesn't map nicely to the form structure or written back our correctly. What if the model contains complex logic or its own internal validation?\n\n#### Summary of Aurelia Binding Approaches\n\nAurelia uses a single technique in all cases: binding commands. Whenever you see the dot, you know that's a binding. You can use `.bind` to invoke the default binding mode: one-way binding for everything except input controls, which are bound two-way by default. There's no need to use special models or manually wire events. Code is minimal and clean."}