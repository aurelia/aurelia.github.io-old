{"name":"Animating Apps with Aurelia - Part 1","description":"This week core team member Vildan Softic shares with us how the Aurelia animation system works as well as how you can get started using animation in your apps today.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/7/17/animating-apps-with-aurelia-part-1","html":"blog/2015/7/17/animating-apps-with-aurelia-part-1/index.html","fragment":"blog/2015/7/17/animating-apps-with-aurelia-part-1/index-fragment.html","self":"blog/2015/7/17/animating-apps-with-aurelia-part-1/index.json"},"content":"\r\nThis week core team member Vildan Softic shares with us how the Aurelia animation system works as well as how you can get started using animation in your apps today.\r\n\r\n----\r\n\r\nSimple, yet effective animations can bring your app to life. Remember the ominous `<blink>` tag? That was clearly too much. In this article we'll explain how Aurelia's animation architecture is designed. We'll then leverage the official Animator-CSS plugin to see how to create subtle animations. In a followup article, we'll introduce a more sophisticated implementation, built upon [VelocityJS](http://julian.com/research/velocity).\r\n\r\n## How does Aurelia support animations?\r\n\r\nA key goal in building animation support for Aurelia was to enable a flexible solution that allows you to choose whatever library you like. As a result, you're neither limited to a proprietary API nor to a certain style for how to implement your animations.\r\n\r\nTo enable this flexibility, Aurelia's animation system is built around a simple interface, which is part of the templating repository:\r\n\r\n```JavaScript\r\nexport class Animator {\r\n    static configureDefault(container, animatorInstance);\r\n    \r\n    move(element:Element):Promise;\r\n    enter(element:Element):Promise;\r\n    leave(element:Element):Promise;\r\n    \r\n    removeClass(element:Element, className:string):Promise;\r\n    addClass(element:Element, className:string):Promise;\r\n    \r\n    animate(element:Element, className:string, options:Object);\r\n    runSequence(sequence:string):Promise;\r\n    \r\n    /** (for JS based animators) **/\r\n    registerEffect(effectName:string, properties:Object);\r\n    unregisterEffect(effectName:string);\r\n}  \r\n```\r\n\r\n*[https://github.com/aurelia/templating/blob/master/src/animator.js](https://github.com/aurelia/templating/blob/master/src/animator.js)*\r\n\r\nAs you can see, the interface just declares available animation methods which return promises. Also note the `configureDefault` method which is used to register a default instance of the Animator with the framework.\r\n\r\nThe Animator interface methods are called from various places within the framework, most notably the templating engine's `ViewSlot` class. The `ViewSlot` is used by the framework to abstract the idea of a \"location\" or \"slot\" in the DOM where views can be added or removed. This abstraction allows the framework to enforce lifecycle hooks, play animations and more. The following listing depicts parts of the `ViewSlot.add` function, showing how a View is added into the DOM:\r\n\r\n```JavaScript\r\nvar element = view.firstChild ? nextElementSibling(view.firstChild) : null;\r\nif(view.firstChild &&\r\n  view.firstChild.nodeType === 8 &&\r\n  element &&\r\n  element.nodeType === 1 &&\r\n  element.classList.contains('au-animate')) {\r\n  this.animator.enter(element);\r\n}\r\n```\r\n    \r\n*[https://github.com/aurelia/templating/blob/master/src/view-slot.js#L75-L82](https://github.com/aurelia/templating/blob/master/src/view-slot.js#L75-L82)*\r\n\r\nWhat you see here is that Aurelia essentially calls the proper methods at various positions in the code base and thus *hints* the execution of potential animations. We say *hints* because of two reasons explained next.\r\n\r\n### Exchangeable Implementations\r\n\r\nThe default implementation of `Animator` does not do anything besides immediately resolving a promise. The reason for this is to not burden your app with something you might not need at all while still supporting a base for other implementations. Those other implementations can be provided as Aurelia Plugins. Throughout the rest of this article we're going to take a look at the official Plugin leveraging CSS3-Animations, but know that there are already several other implementations available and many more to come.\r\n\r\n### Opt-In Animations\r\n\r\nEven when you use animations, you might just want to use them only for specific elements. This is very true for business applications, where animations are rarely used and only need to highlight specific actions. In order to provide an efficent mechanism for Aurelia, preventing it from needing to observe every potential element, you must be specific about which elements should be animated. This is done by placing a special class called `au-animate` on your desired element.\r\n\r\n```HTML\r\n<section class=\"au-animate\">\r\n```\r\n\r\nIf you take a look at the previous `ViewSlot.add` function, you'll see that it checks whether the inspected element does contain the class `au-animate` and only then continues firing the respective animation method.\r\n\r\n## A Concrete Implementation with CSS-Animations\r\n\r\nThere are multiple ways to create animations of all kinds, whether by leveraging large Frameworks like [Famo.us](http://famo.us/) or [GreenSock](https://greensock.com/), more specific libraries like [Velocity.js](http://julian.com/research/velocity/) or even simple jQuery wrappers like [Transit](http://ricostacruz.com/jquery.transit/). Each of them focus on providing animations via JavaScript code. This approach offers you the most flexibility and control over how your animations are executed. But sometimes it feels like a lot of overhead if all you want is to change the color or the visibility of an element. So instead of touching the code base, an alternative approach is to use CSS3-Animations, which are completely handled by CSS-Markup.\r\n\r\nAs a rule of thumb you would use the CSS-Animator if:\r\n\r\n* all you need are subtle and sparse animations\r\n\r\n* you don't want to touch an existing code base\r\n\r\n* you'd like to utilize existing CSS3 code snippets \r\n\r\n> Please note that the CSS-Animator only supports animations through the `animation` property and NO `transitions`. Be assured though, that there are tons of possibilities you can achieve with CSS-Animations alone. Take a look at the following tutorials for more info: [W3School](http://www.w3schools.com/css/css3_animations.asp), [TutsPlus](http://webdesign.tutsplus.com/tutorials/a-beginners-introduction-to-css-animation--cms-21068)\r\n\r\n### How the Animation Process Works\r\n\r\nEssentially, all that is needed to make an animation work is to define CSS classes with special predefined suffixes. You get the chance to use preparation classes, added before the actual animation starts as well as activation classes, used to trigger the actual animation. Take a look at the following table for all available options.\r\n<style>\r\n.pretty-table\r\n{\r\n  width: 100%;\r\n  padding: 0;\r\n  margin: 0;\r\n  border-collapse: collapse;\r\n  border: 1px solid #333;\r\n}\r\n\r\n.pretty-table th, .pretty-table td\r\n{\r\n  border: 1px dotted #666;\r\n  padding: 0.5em;\r\n  text-align: left;\r\n}\r\n</style>\r\n<table class=\"pretty-table\">\r\n\t<thead>\r\n\t\t<th>Method</th>\r\n\t\t<th>Description</th>\r\n\t\t<th>Preparation</th>\r\n\t\t<th>Activation</th>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>Enter</td>\r\n\t\t\t<td>Element enters the DOM</td>\r\n\t\t\t<td>au-enter</td>\r\n\t\t\t<td>au-enter-active</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>Leave</td>\r\n\t\t\t<td>Element leaves the DOM</td>\r\n\t\t\t<td>au-leave</td>\r\n\t\t\t<td>au-leave-active</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>addClass</td>\r\n\t\t\t<td>Adds a CSS class</td>\r\n\t\t\t<td>n/a</td>\r\n\t\t\t<td>[className]-add</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>removeClass</td>\r\n\t\t\t<td>Removes a CSS class</td>\r\n\t\t\t<td>n/a</td>\r\n\t\t\t<td>[className]-remove</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\nIn order to understand how the CSS-Animator works, lets take a look at the `enter` method. We'll just highlight the most important parts but you can find the full source code [here](https://github.com/aurelia/animator-css/blob/master/src/animator.js#L182-L279).\r\n\r\nAll animation methods are supposed to return a Promise in order to allow async execution of logic after the animation completes. \r\n\r\n```JavaScript\r\nenter(element) {\r\n  return new Promise((resolve, reject) => {\r\n  ...\r\n```\r\n\r\nNext, a unique animation id is created to identify the current animation:\r\n\r\n```JavaScript\r\n// Step 1: generate animation id\r\nvar animId = element.toString() + Math.random(),\r\n  classList = element.classList;\r\n  ...\r\n```\r\n\r\nIn order to allow the developer to setup CSS-properties before the actual animation runs, the Animator will add the class `au-enter` to the element.\r\n\r\n```JavaScript\r\n//Step 2: Add animation preparation class\r\nclassList.add('au-enter');\r\n...\r\n```\r\n\r\nTo handle the animation flow, the Animator will listen for the `animationstart` event, fired on the specific element. Notice the use of multiple events since browsers may fire vendor-specific events.\r\n\r\n```JavaScript\r\n// Step 3: setup event to check whether animations started\r\nvar animStart;\r\nthis._addMultipleEventListener(\r\n  element, \r\n  \"webkitAnimationStart animationstart\", \r\n  animStart = (evAnimStart) => {\r\n  ...\r\n```\r\n\r\nNow that we know that the animation actually started, add it to the stack and start listening for its completion.\r\n\r\n```JavaScript\r\n// Step 3.1: Animation exists, put on stack\r\nthis._addAnimationToStack(animId);\r\n  \r\n// Step 3.2: Wait for animation to finish\r\nvar animEnd;\r\nthis._addMultipleEventListener(\r\n  element,\r\n  \"webkitAnimationEnd animationend\",\r\n  animEnd = (evAnimEnd) => {\r\n  ...\r\n```\r\n\r\nWhen the animation ends, remove the activation/preparation classes and the animation id from the stack. Then resolve the promise with `true`.\r\n\r\n```JavaScript\r\n// Step 3.2.1: remove animation classes\r\nclassList.remove('au-enter-active');\r\nclassList.remove('au-enter');\r\n  \r\n// Step 3.2.2 remove animation from stack\r\nthis._removeAnimationFromStack(animId);\r\n...          \r\nresolve(true);\r\n...\r\n```\r\n\r\nIn order to get the animation triggered, the animator adds the activation class.\r\n\r\n```JavaScript\r\n// Step 4: trigger animation      \r\n...      \r\nclassList.add('au-enter-active');\r\n...\r\n```\r\n  \r\nBut perhaps that class is not defined in your stylesheet. In that case the Animator will wait for a certain timeout to run out and cleanup the element classes, resolving the promise with `false` to indicate that no animation happened.\r\n\r\n```JavaScript\r\n// Step 5: if no animations happened cleanup animation classes\r\nsetTimeout(() => {\r\n  if (this.animationStack.indexOf(animId) < 0) {\r\n    classList.remove('au-enter-active');\r\n    classList.remove('au-enter');\r\n    ...\r\n    resolve(false);\r\n  }\r\n}, this._getElementAnimationDelay(element) + this.animationTimeout + delay);\r\n```\r\n\r\n### Working with Default Animation Triggers\r\n\r\nEnough theory. Let's get our hands dirty and create a simple list of elements, where each element is going to be animated separately. We start out with the following VM. It contains an array of strings which is going to be rendered and a function to remove a specific animator from that list.\r\n\r\n```JavaScript\r\nexport class AnimationDemo {\r\n  animators = [\r\n    'Base-Animator',\r\n    'CSS-Animator',\r\n    'Velocity-Animator',\r\n    'TinyAnimate-Animator',\r\n    'GreenSock-Animator'\r\n  ];\r\n  \r\n  removeAnimator(animator) {\r\n    var index = this.animators.indexOf(animator);\r\n    this.animators.splice(index, 1);\r\n  }\r\n}\r\n```\r\n\r\nThe view is rendered by using an unordered-list. We'll give it the class `aurelia-animators` to reference it later in our stylesheet. Now we scaffold each animator as a list-item. First we need to give them the class `au-animate` to tell Aurelia that those elements can be animated. Inside each item we display an icon, bound to the `removeAnimator` function.\r\n\r\n```HTML\r\n<template>\r\n  <section>\r\n    <ul class=\"aurelia-animators\">\r\n      <li class=\"au-animate\" repeat.for=\"anim of animators\">\r\n      <i class=\"fa fa-trash\" click.delegate=\"$parent.removeAnimator(anim)\"> </i> ${anim}</li>\r\n    </ul>\r\n  </section>\r\n</template>\r\n```\r\n\r\nFinally we need to implement the animations by creating the necessary CSS-classes. We start off first with some general design of the list. Next we define the enter animations for each item. To do so we utilize the selector `.aurelia-animators>li.au-enter` added automatically during the preparation phase. Since some browsers may not accept having new element enter invisible we should force it by using the `!important` override. The actual animation will be fired by adding the `au-enter-active` class to the element. In there, we leverage the animation property and its vendor-specific pendant, referencing a fadeIn-animation with a duration of two seconds. We do the same for the leave animation but may skip the preparation class and only define `au-leave-active`. Last but not least, we create the Animation-Keyframes and tell it to animate the element's opacity.\r\n\r\n```CSS\r\n.aurelia-animators {\r\n  padding: 20px;\r\n  list-style: none;\r\n}\r\n  \r\n.aurelia-animators>li.au-enter {\r\n  opacity: 0!important;\r\n}\r\n  \r\n.aurelia-animators>li.au-enter-active {\r\n  -webkit-animation: fadeIn 2s;\r\n  animation: fadeIn 2s;\r\n}\r\n  \r\n.aurelia-animators>li.au-leave-active {\r\n  -webkit-animation: fadeOut 2s;\r\n  animation: fadeOut 2s;\r\n}\r\n  \r\n/* CSS3-Animations */\r\n@-webkit-keyframes fadeIn {\r\n  0%   { opacity: 0; }\r\n  100% { opacity: 1; }\r\n}\r\n  \r\n@keyframes fadeIn {\r\n  0%   { opacity: 0; }\r\n  100% { opacity: 1; }\r\n}\r\n  \r\n@-webkit-keyframes fadeOut {\r\n  0%   { opacity: 1; }\r\n  100% { opacity: 0; }\r\n}\r\n  \r\n@keyframes fadeOut {\r\n  0%   { opacity: 1; }\r\n  100% { opacity: 0; }\r\n}\r\n```\r\n\r\nSo we end up with the following result.\r\n\r\n![](/content/images/2015/07/list-animate.gif)\r\n\r\nNow that's nice but wouldn't it be better if all of the items would get rendered one after each other instead of in parallel? Those kind of animations are called staggered animations, where a series of elements is simply executed with a short timeout in between each one. The CSS-Animator does this by adding a class `au-stagger` to the parent of the elements.\r\n\r\n```HTML\r\n<ul class=\"aurelia-animators au-stagger\">\r\n```\r\n\r\nAdditionally, we need to define a new CSS-class called, you guessed it `au-stagger` and in there define the timeout to be used in between each item.\r\n\r\n```JavaScript\r\n.aurelia-animators.au-stagger {\r\n  -webkit-animation-delay:50ms;\r\n  animation-delay:50ms;\r\n}\r\n```\r\n\r\nAnd the result looks like this.\r\n\r\n![](/content/images/2015/07/list-staggered-animate.gif)\r\n\r\n### Implementing Custom Animation Triggers\r\n\r\nWe've seen how to animate using pure CSS. But sometimes you'd like to trigger animations after certain actions. To do so, you can access all the animation methods via JavaScript inside your VM as well. In order to show that, lets animate the background of the list. We're adding a new button which is going to trigger the function `animateBackground`.\r\n\r\n```HTML\r\n<button click.delegate=\"animateBackground()\">Animate Background</button>\r\n```\r\n\r\nInside our VM we first need to request the animator and inject it into the constructor. We'll then store it for later use alongside the view's DOM-Element in the `animateBackground` method. When animating the background, we first get the list. Now we can call the `animate` Method of the CSS-Animator. It expects the element as first parameter, followed by a `className` which it's going to add and after successful animation remove afterwards. What happens behind the scenes is that `animate` just acts as an alias, which will call the methods `addClass` and `removeClass` sequentially.\r\n\r\n```JavaScript\r\nimport {CssAnimator} from 'aurelia-animator-css';\r\nimport {inject} from 'aurelia-framework';\r\n\r\n@inject(CssAnimator, Element)\r\nexport class AnimationDemo{\r\n    constructor(animator, element) {\r\n        this.animator = animator;\r\n        this.element = element;\r\n    }\r\n  \r\n    ...\r\n  \r\n    animateBackground() {\r\n        var list = this.element.querySelector('.aurelia-animators');\r\n        this.animator.animate(list, 'background-animation');\r\n    }\r\n}\r\n```\r\n\r\nThis gives us a chance to define a two-fold animation, when the class is added and when it's removed. We're actually not even forced to define the class `background-animation` itself but just its activation classes, which are shown next. Note how we use a more detailed KeyFrame definition this time, to switch through multiple background-colors.\r\n\r\n```JavaScript\r\n.background-animation-add {\r\n  -webkit-animation: changeBack 2s;\r\n  animation: changeBack 2s;\r\n}\r\n  \r\n.background-animation-remove {\r\n  -webkit-animation: fadeIn 2s;\r\n  animation: fadeIn 2s;\r\n}\r\n\r\n@-webkit-keyframes changeBack {\r\n  0% { background-color: green; }\r\n  25% { background-color: red; }\r\n  50% { background-color: blue; }\r\n  75% { background-color: violet; }\r\n  100% { background-color: yellow; }\r\n}\r\n  \r\n@keyframes changeBack {\r\n  0% { background-color: green; }\r\n  25% { background-color: red; }\r\n  50% { background-color: blue; }\r\n  75% { background-color: violet; }\r\n  100% { background-color: yellow; }\r\n}\r\n```\r\n\r\nAnd again, here is the result.\r\n\r\n![](/content/images/2015/07/animate-custom.gif)\r\n\r\n## Summary\r\n\r\nWe hope you enjoyed this introduction to working with Animation in the Aurelia Framework. There is much more to be told though. We'll continue this discussion in part 2 where we'll be presenting an alternative implementation via a JS-based Animator. Now go out and animate all the things! If you encounter any problems join us in [our gitter channel](https://gitter.im/Aurelia/Discuss)."}