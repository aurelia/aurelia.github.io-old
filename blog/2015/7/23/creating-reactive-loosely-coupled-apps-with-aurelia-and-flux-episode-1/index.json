{"name":"Creating Reactive, Loosely Coupled Apps with Aurelia and Flux - Episode 1","description":"This week we're excited to feature another fantastic member of the Aurelia community: Tomasz Frydrychewicz [https://github.com/tfrydrychewicz]. Thomas is a full stack developer in love with JavaScript and is always looking for an opportunity to spread that enthusiasm around. He's a big fan of reactive, event driven architectures and asynchronous programing. During the last five years he introduced Angular to different societies but is recently infatuated with Aurelia and its approach to modern JavaScript frameworks. Thomas is the author of the aurelia-flux [https://github.com/tfrydrychewicz/aurelia-flux] plugin, which you can hear about in his own words below.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/7/23/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-1","html":"blog/2015/7/23/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-1/index.html","fragment":"blog/2015/7/23/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-1/index-fragment.html","self":"blog/2015/7/23/creating-reactive-loosely-coupled-apps-with-aurelia-and-flux-episode-1/index.json"},"content":"\r\nThis week we're excited to feature another fantastic member of the Aurelia community: [Tomasz Frydrychewicz](https://github.com/tfrydrychewicz). Thomas is a full stack developer in love with JavaScript and is always looking for an opportunity to spread that enthusiasm around. He's a big fan of reactive, event driven architectures and asynchronous programing. During the last five years he introduced Angular to different societies but is recently infatuated with Aurelia and its approach to modern JavaScript frameworks. Thomas is the author of the [aurelia-flux](https://github.com/tfrydrychewicz/aurelia-flux) plugin, which you can hear about in his own words below.\r\n\r\n----\r\n\r\nWhy should we even bother with reactive programming? Well, we all do care about writing testable, loosely coupled code, but are our dependencies really loose? Imagine that you have a working piece of code implementing particular business logic, and you would like to connect a new feature into the flow. If your code isn't reactive yet, you would have to add more \"if-ology\" to it, causing you to have to change the existing code base - that is not what I believe loosely coupled dependencies look like.  How can the reactive, unidirectional [Flux](https://facebook.github.io/flux/docs/overview.html#content) pattern help?\r\n\r\nThe Flux approach is based on **actions**, which are the business information carriers, a central **dispatcher** responsible for controlling action flows and **stores**, which consume those actions and expose data from queries to views. If it reminds you of the [CQRS pattern](http://martinfowler.com/bliki/CQRS.html), you got it. \r\n\r\n![flux flow diagram](/content/images/2015/07/flux-simple-f8-diagram-1300w.png)\r\n*Image used from http://facebook.github.io/flux/*\r\n\r\n[Aurelia-Flux](https://github.com/tfrydrychewicz/aurelia-flux) is a small but useful library that brings the Flux dispatcher into Aurelia. As Aurelia's goal is to be as close to the programming language as possible, aurelia-flux doesn't require any special sort of inheritance chain, any configuration or conventions. It's ready to work out of the box and can be applied to any existing Aurelia application. \r\n\r\n### Installing\r\n\r\nIn order to start using [aurelia-flux](https://github.com/tfrydrychewicz/aurelia-flux), just install it with jspm...\r\n\r\n\r\n\r\n  ```JavaScript\r\n    jspm install aurelia-flux=\"github:tfrydrychewicz/aurelia-flux\"\r\n  \r\n```\r\n\r\n...load the plugin...\r\n\r\n\r\n\r\n  ```JavaScript\r\n    export function configure(aurelia) {\r\n      aurelia.use\r\n        .standardConfiguration()\r\n        .developmentLogging()\r\n        .plugin('aurelia-flux'); //Add this line to load the plugin\r\n    \r\n      aurelia.start().then(a => a.setRoot()); \r\n    }\r\n  \r\n```\r\n\r\n...and you're ready to go.\r\n\r\n### Basic Usage\r\n\r\nUsing aurelia-flux is as easy as falling off a log. You don't have to create any special types, just start using it with your ES6/7 classes. Create your store and decorate any method with the `@handle` decorator to make it start consuming the given action.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {inject} from 'aurelia-framework';\r\n    import {Dispatcher, handle} from 'aurelia-flux';\r\n    \r\n    @inject(Dispatcher)\r\n    export class MessagesStore {\r\n    \tmessages = [];\r\n    \r\n    \tconstructor(dispatcher) {\r\n    \t\tthis.dispatcher = dispatcher;\r\n    \t}\r\n    \r\n    \t@handle('message.send')\r\n    \taddMessage(action, message) {\r\n    \t\tthis.messages.push(message);\r\n    \t\tthis.dispatcher.dispatch('message.sent', message);\r\n    \t}\r\n    \r\n    \tgetMessages() {\r\n    \t\treturn this.messages;\r\n    \t}\r\n    }\r\n  \r\n```\r\n\r\nThen use your store in the view model, along with the dispatcher's `dispatch` method to make the dispatcher start processing your action and deliver it to all the handlers.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {inject} from 'aurelia-framework';\r\n    import {Dispatcher, handle} from 'aurelia-flux';\r\n    import {MessagesStore} from 'messages';\r\n    \r\n    @inject(Dispatcher, MessagesStore)\r\n    export class Welcome {\r\n    \tconstructor(dispatcher, store) {\r\n    \t\tthis.dispatcher = dispatcher;\r\n    \t\tthis.store = store;\r\n    \t}\r\n    \r\n    \tsubmit() {\r\n    \t\tthis.dispatcher.dispatch('message.send', this.message);\r\n    \t}\r\n    \r\n    \t@handle('message.sent')\r\n    \tnotifyWhenMessageSent(action, message) {\r\n    \t\tnotify(`Message sent: ${message}`);\r\n    \t}\t\t\r\n    }\r\n  \r\n```\r\n\r\nCreate a standard Aurelia view and feed it with the store's data...\r\n\r\n\r\n\r\n  ```HTML\r\n    <div class=\"row\">\r\n    \t<form role=\"form\" submit.delegate=\"submit()\">\r\n    \t\t<div class=\"form-group\">\r\n    \t\t\t<label for=\"msg\">Message</label>\r\n    \t\t\t<input type=\"text\" value.bind=\"message\" class=\"form-control\" id=\"msg\">\r\n    \t\t</div>\r\n    \t\t<button type=\"submit\" class=\"btn btn-default\">Submit</button>\r\n    \t</form>\r\n    </div>\r\n    <div class=\"row\">\r\n    \t<ul>\r\n    \t\t<li repeat.for=\"message of store.getMessages()\">${message}</li>\r\n    \t</ul>\r\n    </div>\r\n  \r\n```\r\n\r\n... and you have your application working in a reactive manner with aurelia-flux.\r\n\r\n### One-Timers\r\n\r\nThe defined `message.send` handler will be processing the `message.send` messages for the whole object life-cycle. If you want to control when it's being released, use the dispatcher's `handle` method. When invoked, it returns a release method, which will remove the callback from the dispatcher's registry.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    oneTimeHandle() {\r\n    \tvar release = this.dispatcher.handle('message.sent', (action, message) => {\r\n    \t\tconsole.log(message);\r\n    \t\trelease();\r\n    \t});\r\n    }\r\n  \r\n```\r\n\r\n### Promises\r\n\r\nAurelia-Flux is based on [BlueBird](https://github.com/petkaantonov/bluebird) promises [A+](https://promisesaplus.com/), therefore you can use it with any JavaScript promises. If your callback returns a promise, the flux dispatcher will not finish its current dispatching until the promise is resolved or rejected. If you don't want the dispatcher to wait for your asynchronous call to finish, just don't return the promise. \r\n\r\n\r\n\r\n  ```JavaScript\r\n    @handle('message.send')\r\n    handleAsync(action, message) {\r\n    \treturn Promise((resolve, reject) => {\r\n    \t\tthis.http.post('http://your.service.url/messages', message)\r\n    \t\t\t.then(() => {\r\n    \t\t\t\tthis.dispatcher.dispatch('message.sent', message);\r\n    \t\t\t\tresolve();\r\n    \t\t\t})\r\n    \t\t\t.catch(() => {\r\n    \t\t\t\tthis.dispatcher.dispatch('message.errorWhenSending', message);\r\n    \t\t\t\treject();\r\n    \t\t\t}); \r\n    \t});\t\r\n    }\r\n  \r\n```\r\n\r\n### WaitFor\r\n\r\nAs the order of handlers invoked when dispatching an action depends on the particular sequence of files you're loading into your app, you cannot rely on it. Luckily, [aurelia-flux](https://github.com/tfrydrychewicz/aurelia-flux) comes with `waitFor` which facilitates and alleviates building sequential action processing. If you want the whole callback function to wait for another store to finish processing, use the `@waitFor` decorator.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {handle, waitFor} from 'aurelia-flux';\r\n    import {MessagesStore} from 'messages';\r\n    \r\n    ...\r\n    \r\n    @handle('message.send')\r\n    @waitFor(MessagesStore)\r\n    logMessage(action, message) {\r\n    \t...\r\n    }\r\n  \r\n```\r\n\r\nIf only a part of a handler needs to wait, use the dispatcher's `waitFor` method.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {handle, waitFor} from 'aurelia-flux';\r\n    import {MessagesStore} from 'messages';\r\n    \r\n    ...\r\n    \r\n    @handle('message.send')\r\n    logMessage(action, message) {\r\n    \tvar prepared = prepare(message);\r\n    \tthis.dispatcher.waitFor(MessageStore, () => {\r\n    \t\tlog(prepared);\r\n    \t});\r\n    }\r\n  \r\n```\r\n\r\n### Summary\r\n\r\nHopefully this short introduction to creating reactive applications with [aurelia-flux](https://github.com/tfrydrychewicz/aurelia-flux) gave you a good starting point for your reactive adventure. Building applications in such a manner helps to maintain the loose coupling of dependencies, keeps code clean and avoids the excessive use of unnecessary branching. \r\n\r\nIn the next episode I will walk you through en example, reactive application created with aurelia-flux."}