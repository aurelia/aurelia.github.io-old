{"name":"Aurelia-Computed","description":"This week, Core Team Member Jeremy Danyow [https://github.com/jdanyow] shows us a new plugin to Aurelia's binding engine that he's been working on: aurelia-computed [https://github.com/jdanyow/aurelia-computed/].","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/5/4/aurelia-computed","html":"blog/2015/5/4/aurelia-computed/index.html","fragment":"blog/2015/5/4/aurelia-computed/index-fragment.html","self":"blog/2015/5/4/aurelia-computed/index.json"},"content":"\nThis week, Core Team Member [Jeremy Danyow](https://github.com/jdanyow) shows us a new plugin to Aurelia's binding engine that he's been working on: [aurelia-computed](https://github.com/jdanyow/aurelia-computed/).\n\n----\n\n[**aurelia-computed**](https://github.com/jdanyow/aurelia-computed/) is a plugin for the [Aurelia](http://www.aurelia.io/) platform that improves the efficiency of data-binding computed properties.  Binding to computed properties (properties with getter functions) typically requires dirty-checking.  This plugin uses Aurelia's javascript parser to parse the body of the property's getter function and check the resulting [abstract syntax tree (AST)](http://en.wikipedia.org/wiki/Abstract_syntax_tree) for \"observability\".  If the getter function is observable, a specialized observer is returned to Aurelia's [pluggable binding system](http://www.danyow.net/aurelia-property-observation/).  The observer publishes change events when properties accessed by the getter function change.\n\n#### What types of properties can aurelia-computed observe?\n\nOne-liners that access members that are accessible from the binding scope are good candidates for observation by this plugin.  Here's a few examples:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // \"firstName\" and \"lastName\" will be observed.\n    get fullName() {\n      return `${this.firstName} ${this.lastName}`;\n    }\n  </source-code>\n</code-listing>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // \"isLoggedIn\", \"user\" and \"user.name\" will be observed.\n    get userName() {\n      return this.isLoggedIn ? this.user.name : '(Anonymous)';\n    }\n  </source-code>\n</code-listing>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    // \"count\" will be observed.\n    get shoppingCartDescription() {\n      return this.count + ' ' + this.pluralize('item', this.count);\n    }\n  </source-code>\n</code-listing>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    var _bar = 'baz';\n    \n    export class Foo {\n    \n      // This property cannot be observed by aurelia-computed.\n      // Dirty-checking will be required.\n      // \"_bar\" can't be accessed from the binding scope.\n      get bar() {\n        return _bar;\n      }\n    }\n  </source-code>\n</code-listing>\n\n#### Other options\n\nAurelia's binding system already has a method for observing computed properties- the `@computedFrom` decorator.  Simply decorate any property with `@computedFrom(propertyName1[, propertyName2..., propertyNameN])` and Aurelia's binding system will observe the specified properties and re-evaluate bindings when any of the properties change.  The aurelia-computed plugin simply automates the dependency identification and is able to support more complex scenarios such as observing property paths (`this.aurelia.computed.supports.me`).  There's also the dirty-checking fallback which isn't anything to worry about most of the time.\n\n#### Development Logging\n\nEnable debug logging in your application (see below for instructions) to view aurelia-computed's log messages.  Aurelia-computed logs when it's not able to parse a property getter function or when the function's logic is not observable.  This will tell you when Aurelia is going to use dirty-checking.  Here's an example:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    <template>\n      Thanos wants ${whatThanosWants}\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    var infinityStones = ['Soul','Time','Space','Mind','Reality','Power'];\n    \n    export class Thanos {\n      get whatThanosWants() {\n        return infinityStones;\n      }\n    }\n  </source-code>\n</code-listing>\n\nSince `infinityStones` is declared in the module scope, which binding cannot access, aurelia-computed logs the following message:\n\n![console](http://i.imgur.com/c0euMic.png)\n\n\n## Get Started\n\n1) Install aurelia-computed:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    jspm install aurelia-computed\n  </source-code>\n</code-listing>\n2) Use the plugin in your app's main.js:\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    export function configure(aurelia) {\n      aurelia.use\n        .standardConfiguration()\n        // enable debug logging to see aurelia-computed's messages.\n        .developmentLogging()\n        // install the plugin\n        .plugin('aurelia-computed');\n    \n      aurelia.start().then(a => a.setRoot());\n    }\n  </source-code>\n</code-listing>"}