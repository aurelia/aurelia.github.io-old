{"name":"Porting an Angular 2.0 App to Aurelia","description":"Recently, Joe Eames [https://twitter.com/josepheames] had a nice PluralSight [http://www.pluralsight.com] webinar demonstrating some of the features of Angular 2.0. We thought \"Wouldn't it be cool to see the same app built with Aurelia?\" It seemed like a good opportunity to show what we feel makes Aurelia so easy-to-use and efficient.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/5/20/porting-an-angular-2-0-app-to-aurelia","html":"blog/2015/5/20/porting-an-angular-2-0-app-to-aurelia/index.html","fragment":"blog/2015/5/20/porting-an-angular-2-0-app-to-aurelia/index-fragment.html","self":"blog/2015/5/20/porting-an-angular-2-0-app-to-aurelia/index.json"},"content":"\r\nRecently, [Joe Eames](https://twitter.com/josepheames) had a nice [PluralSight](http://www.pluralsight.com) webinar demonstrating some of the features of Angular 2.0.  We thought \"Wouldn't it be cool to see the same app built with Aurelia?\" It seemed like a good opportunity to show what we feel makes Aurelia so easy-to-use and efficient.\r\n\r\n#### The Rules\r\n\r\nIn order to ensure that this is an even and accurate comparison, we set some ground rules:\r\n\r\n1. The code should be a direct port unless there is a blaring issue or error in the source.\r\n2. The code should use all of the same variables and names in order to avoid confusion.\r\n3. We'll use the standard Aurelia [skeleton](https://github.com/aurelia/skeleton-navigation) as our starting point.\r\n\r\n### Getting Started\r\n\r\nLooking at [Joe's original repo](https://github.com/joeeames/ng2-ps-webinar), the most logical place to start would be the \"TodoApp\" component. Let's see both versions side-by-side:\r\n\r\n<div>\r\n  <div style=\"float: left; width: 50%;\">\r\n    <h4>Angular 2.0</h4>\r\n    <strong>app.js</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {Component, View, bootstrap} from 'angular2/angular2';\r\n    import {NewItem} from 'components/new-item';\r\n    import {TodoList} from 'components/todo-list';\r\n\r\n    @Component({\r\n    \tselector: 'todo-app'\r\n    })\r\n    @View({\r\n    \ttemplateUrl: 'components/app.html',\r\n    \tdirectives: [NewItem, TodoList]\r\n    })\r\n    export class TodoApp {}\r\n\r\n    bootstrap(TodoApp);\r\n  \r\n```\r\n\r\n  </div>\r\n\r\n  <div style=\"float: right; width: 48%;\">  \r\n    <h4>Aurelia</h4>\r\n    <strong>app.js</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    export class TodoApp {}\r\n  \r\n```\r\n\r\n  </div>\r\n</div>\r\n\r\n<div style=\"clear: both;\"></div>\r\n\r\n<div>\r\n  <div style=\"float: left; width: 50%\">  \r\n\t<h4>Angular 2.0</h4>\r\n    <strong>app.html</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <div>\r\n    \t<todo-list></todo-list>\r\n    \t<new-item></new-item>\r\n    </div>\r\n  \r\n```\r\n\r\n  </div>\r\n\r\n  <div style=\"float: right; width: 48%\">  \r\n    <h4>Aurelia</h4>\r\n    <strong>app.html</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <template>\r\n      <require from=\"./todo-list\"></require>\r\n      <require from=\"./new-item\"></require>\r\n\r\n      <todo-list></todo-list>\r\n      <new-item></new-item>\r\n    </template>\r\n  \r\n```\r\n\r\n  </div>\r\n</div>\r\n\r\n<div style=\"clear: both;\"></div>\r\n</div>\r\n\r\n#### Commentary\r\n\r\nIn order to port the JS code, all we had to do was delete code from the Angular version. This is a nice little example of how Aurelia's support of simple conventions drastically reduces the boiler plate code developers need to write.\r\n\r\nIf you look at the HTML, you'll see that the Aurelia version has a little more markup than the Angular 2.0 version. To understand why, take a look back at the Angular 2.0 JS code. You will see that developers must list all `directives` that their view will use there.\r\n\r\n**Aurelia makes a fundamentally different choice.**\r\n\r\nWith Aurelia, we chose to support Separation of Concerns and believe strongly that details regarding a view's implementation should not be found inside of a Controller or ViewModel.  Aurelia accomplishes this by allowing the view to declare its internal dependencies using `require` elements. There are a number of important positive side-effects from this choice:\r\n\r\n* Separation of Concerns - As already mentioned, the details of a view's implementation stay inside the view and aren't leaked into the Controller or View-Model.\r\n* Multiple Views Per Controller/View-Model- You can now more easily have different views for the same Controller/View-Model and they can be implemented drastically differently, with each one loading only the resources it needs.\r\n* Sharing a View Between Controllers/View-Models - You can more easily have multiple View-Models use the same view. There's no need to duplicate the view's resources in every JS file.\r\n* Improved Readability/Understandability - If you look at a view's source, you know exactly what behaviors are active in that view. You don't have to hunt down a JS file, open it and examine it's directive list and then correlate those back to the view.\r\n\r\nUltimately, this important design difference, placing view resource declaration in the view where it belongs, allows developers greater flexibility, reduction in code duplication and an overall improvement in maintainability.\r\n\r\n*Next we'll look at the \"TodoList\" component:*\r\n\r\n<div>\r\n  <div style=\"float: left; width: 50%\">  \r\n    <h4>Angular 2.0</h4>\r\n    <strong>todo-list.js</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {Component, View, For, If, EventEmitter} from 'angular2/angular2';\r\n    import {Inject, bind} from 'angular2/di';\r\n    import {todoItems} from 'services/todoItems';\r\n\r\n    @Component({\r\n    \tselector: 'todo-list',\r\n      injectables: [\r\n        bind('todoItems').toValue(todoItems)\r\n      ]\r\n    })\r\n    @View({\r\n    \ttemplateUrl: 'components/todo-list.html',\r\n    \tdirectives: [For, If]\r\n    })\r\n    export class TodoList {\r\n      constructor(@Inject('todoItems') todoItems) {\r\n    \t\tthis.items = todoItems;\r\n    \t}\r\n    \tsetCompleted(item, checked) {\r\n    \t\titem.completed = checked;\r\n    \t}\r\n    \tcompleteAll() {\r\n    \t\tthis.items.forEach((item) => {\r\n    \t\t\tthis.setCompleted(item, true);\r\n    \t\t});\r\n    \t}\r\n    \tremoveItem(item) {\r\n    \t\tthis.items.splice(this.items.indexOf(item), 1);\r\n    \t}\r\n    }\r\n\r\n  \r\n```\r\n\r\n  </div>\r\n\r\n  <div style=\"float: right; width: 48%\">  \r\n    <h4>Aurelia</h4>\r\n    <strong>todo-list.js</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {TodoItems} from 'services/todo-items';\r\n\r\n    export class TodoList {\r\n      static inject = [TodoItems];\r\n      constructor(todoitems) {\r\n        this.items = todoitems.items;\r\n      }\r\n      completeAll() {\r\n        this.items.forEach(item => item.completed = true);\r\n      }\r\n      removeItem(item) {\r\n        this.items.splice(this.items.indexOf(item), 1);\r\n      }\r\n    }\r\n  \r\n```\r\n\r\n  </div>\r\n</div>\r\n\r\n<div style=\"clear: both;\"></div>\r\n\r\n<br />\r\n<br />\r\n\r\n<div>\r\n  <div style=\"float: left; width: 50%\">  \r\n    <h4>Angular 2.0</h4>\r\n    <strong>todo-list.html</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <div style=\"margin-bottom:10px\">\r\n    \t<h1>To Do</h1>\r\n    \t<div style=\"padding:5px\" *for=\"var item of items\">\r\n    \t\t\t<input type=\"checkbox\" #chkbox [checked]=\"item.completed\" (click)=\"setCompleted(item, chkbox.value)\">\r\n    \t\t\t{{item.text}} <a class=\"glyphicon glyphicon-remove\" (click)=\"removeItem(item)\"></a>\r\n    \t</div>\r\n    \t<button *if=\"items.length > 1\" class=\"btn btn-xs btn-warning\" (click)=\"completeAll()\">Complete All</button>\r\n    </div>\r\n  \r\n```\r\n\r\n  </div>\r\n\r\n  <div style=\"float: right; width: 48%\">  \r\n    <h4>Aurelia</h4>\r\n    <strong>todo-list.html</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <template style=\"margin-bottom:10px\">\r\n      <h1>To Do</h1>\r\n    <div style=\"padding:5px\" repeat.for=\"item of items\">\r\n          <input type=\"checkbox\" checked.bind=\"item.completed\" />\r\n          ${item.text} <a class=\"glyphicon glyphicon-remove\" click.trigger=\"$parent.removeItem(item)\"></a>\r\n      </div>\r\n      <button if.bind=\"items.length\" class=\"btn btn-xs btn-warning\" click.trigger=\"completeAll()\">Complete All</button>\r\n    </template>\r\n  \r\n```\r\n  </div>\r\n</div>\r\n\r\n<div style=\"clear: both;\"></div>\r\n</div>\r\n\r\n#### Commentary\r\n\r\nAgain, the primary change we made was to delete a bunch of code. Aurelia's conventions just don't require you to do all that work. We were also able to delete the `setCompleted` method, since Aurelia has Two-Way Databinding. The manual synchronization work required by Angular 2.0 can be automatically handled by Aurelia.\r\n\r\nIn this component, you also see the introduction of Dependency Injection. With Aurelia, you can simply create a static member named `inject` to declare your class's dependencies. If you prefer, [you can also use an ES7 decorator to accomplish the same thing](http://blog.durandal.io/2015/04/09/aurelia-update-with-decorators-ie9-and-more/#decorators). In the Angular 2.0 version, for some reason, the DI has to be configured in two places. Once in the Component decorator and once on the constructor.\r\n\r\nLooking at the HTML, we see two completely different approaches to syntax. The Angular 2.0 version relies on special characters: *, (), [] and #. The Aurelia version relies on binding commands, designated with the dot (.) character.\r\n\r\n**Again, this is an important design difference with serious ramifications.**\r\n\r\nWhile the special characters that Angular chooses for its templating language are technically valid in HTML, they are not valid in SVG nor can they be used directly with DOM APIs. The browser will not allow it. To get around this, you have to use a secondary syntax. So, all Angular 2.0 developers must learn two syntaxes for templating instead of one. On the other hand, Aurelia's templating syntax works in all scenarios without any issue: one, consistent syntax for everything. Additionally, using the dot as a separator allows us to make our binding language fully extensible.\r\n\r\nThere's another important side-effect of this design choice as well. If you've never seen Angular 2.0 before, you probably have no clue what those symbols mean. It's cryptic and requires even knowledgable developers to keep a constant mental map between the symbol and it's meaning. Aurelia, on the other hand, uses human-readable binding commands. Even developers who have never seen it before can often understand what it means. This results in improvements in learnability, readability and maintenance.\r\n\r\nA few more quick notes:\r\n\r\n* Angular uses `{{}}` and Aurelia uses `${}`. There's no real technical reason behind Aurelia's difference in choice here. It's more related to consistency. In ES 2015, JavaScript string interpolation is done with the `${}` syntax. Throughout Aurelia, wherever possible, we've constantly tried to adopt the same syntax and concepts as the native platform, including bridging similar ideas into our templating language.\r\n* Aurelia's templating language can leverage Two-Way binding on the `input` element, allowing us to remove Angular's manual event wireup in the view as well as the previously mentioned function from JavaScript.\r\n* We used Aurelia's `trigger` command for events in order to match Angular 2.0 behavior as much as possible. However, particularly in the case of the repeater, we would normally use `delegate` to enable event delegation and reduce event handler wire-ups. I believe that Angular also supports this with the `(^event)` syntax, but that may have changed.\r\n\r\n*Now, let's port the last piece, the NewItem component:*\r\n\r\n<div>\r\n  <div style=\"float: left; width: 50%\">  \r\n    <h4>Angular 2.0</h4>\r\n    <strong>new-item.js</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {Component, View} from 'angular2/angular2';\r\n    import {Inject, bind} from 'angular2/di';\r\n    import {todoItems} from 'services/todoItems';\r\n\r\n    @Component({\r\n    \tselector: 'new-item',\r\n      injectables: [\r\n        bind('todoItems').toValue(todoItems)\r\n      ]\r\n    })\r\n    @View({\r\n    \ttemplateUrl: 'components/new-item.html'\r\n    })\r\n    export class NewItem {\r\n    \tconstructor(@Inject('todoItems') todoItemList) {\r\n        this.items = todoItemList\r\n    \t}\r\n    \tkeyPressed($event, input) {\r\n    \t\tif($event.which === 13) {\r\n    \t\t\tthis.addItem(input);\r\n    \t\t}\r\n    \t}\r\n    \taddItem(input) {\r\n    \t\tthis.items.push({\r\n    \t\t\ttext: input.value,\r\n    \t\t\tcompleted: false\r\n    \t\t})\r\n    \t\tinput.value = '';\r\n    \t}\r\n    }\r\n  \r\n```\r\n\r\n  </div>\r\n\r\n  <div style=\"float: right; width: 48%\">  \r\n    <h4>Aurelia</h4>\r\n    <strong>new-item.js</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {TodoItems} from 'services/todo-items';\r\n\r\n    export class NewItem {\r\n      static inject = [TodoItems];\r\n      constructor(todoitems) {\r\n        this.items = todoitems.items;\r\n      }\r\n      keyPressed($event) {\r\n        if($event.which === 13) {\r\n          this.addItem(this.value);\r\n        }\r\n      }\r\n      addItem(input) {\r\n        this.items.push({\r\n          text: this.value,\r\n          completed: false\r\n        })\r\n        this.value = '';\r\n      }\r\n    }\r\n  \r\n```\r\n\r\n  </div>\r\n</div>\r\n\r\n<div style=\"clear: both;\"></div>\r\n\r\n<br />\r\n<br />\r\n\r\n<div>\r\n  <div style=\"float: left; width: 50%\">  \r\n    <h4>Angular 2.0</h4>\r\n    <strong>new-item.html</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <div class=\"form-inline\">\r\n    \t<div class=\"form-group\">\r\n    \t\t<label for=\"description\">New Item</label>\r\n    \t\t<input id=\"description\" class=\"form-control\" #desc (keyup)=\"keyPressed($event, desc)\">\r\n    \t</div>\r\n    \t<button class=\"btn btn-primary\" type=\"button\" (click)=\"addItem(desc)\">Add Item</button>\r\n    </div>\r\n  \r\n```\r\n\r\n  </div>\r\n\r\n  <div style=\"float: right; width: 48%\">  \r\n    <h4>Aurelia</h4>\r\n    <strong>new-item.html</strong>\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <template>\r\n      <div class=\"form-inline\">\r\n        <div class=\"form-group\">\r\n          <label for=\"description\">New Item</label>\r\n          <input id=\"description\" class=\"form-control\" value.bind=\"value\" keyup.trigger=\"keyPressed($event)\">\r\n        </div>\r\n        <button class=\"btn btn-primary\" type=\"button\" click.trigger=\"addItem()\">Add Item</button>\r\n      </div>\r\n    </template>\r\n  \r\n```\r\n\r\n  </div>\r\n</div>\r\n\r\n<div style=\"clear: both;\"></div>\r\n\r\n#### Commentary\r\n\r\nAs in the previous examples, we begin the porting by deleting a lot of Angular 2.0 code which is just not needed. Dependency Injection takes on the same form here as previously with a single declaration in Aurelia vs. two for Angular.\r\n\r\nThere's a slightly different sort of interplay here between the ways the two versions interact with their views. In the Angular version, there's no Two-Way Databinding, so again the HTML must be manually wired up to shuffle data in both directions. In this case, it creates a direct coupling between the view and view-model in the Angular version because the lack of Two-Way Databinding forces the developer to pass the HTMLInputElement instance to the view-model in order to retrieve it's value. In the Aurelia version, we just bind the value. This results in more re-usable code, but also a much easier to test interface, as no faking/mocking of HTML elements is required for the Aurelia version.\r\n\r\n### Conclusion\r\n\r\nPorting the Angular 2.0 app to Aurelia was pretty straight forward. Aurelia Core Team Member, [Patrick Walters](https://github.com/PWKad), who helped to put this article together, said it took him about 8 minutes to do the port. As you can see, in every case we deleted great swathes of JavaScript code. If you look back over the Aurelia versions, you'll also notice something I think is very important. There's not a single reference to the Aurelia framework in any of the JavaScript. It's all just plain ES2015. No framework intrusion. That's a big contrast to the Angular version.\r\n\r\nHopefully you can also see how Aurelia's templating language ports in a pretty straight forward manner, but that doing so improves the readability and platform compatibility of the markup. Even though this example uses very little in terms of forms input, you can start to get the feel for how modern Two-Way Databinding can also reduce code and markup and simplify the implementation process.\r\n\r\nWe hope this has been informative. We didn't fabricate any examples for this post, but instead started with a recent Angular 2.0 sample app. We then ported it to see what the process was like, hoping to show you the elegance of Aurelia as well as the rationale and side-effects of some of the different design decisions we've made along the way.\r\n\r\n#### Project Links\r\n\r\n* [The Original Angular 2.0 Version](https://github.com/joeeames/ng2-ps-webinar)\r\n* [The Aurelia Port](https://github.com/PWKad/au-ps-comparison)\r\n\r\n#### Footnote\r\n\r\nWe don't intend to constantly do these sorts of Angular comparison posts. It's not fun for us and we don't want to have a reputation for doing this all the time. If you are wondering why we have done this, it's very simple. There's a huge demand for it. We receive a constant stream of requests through email, at conferences and in person to talk about how Aurelia differs from Angular 2.0. We get asked to come to conferences and user groups to speak about this, asked to write blog posts and asked to prepare private internal presentations for various organizations. This post is an attempt to provide some simple answers to a large group of people who has a critical interest in this topic."}