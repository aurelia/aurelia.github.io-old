{"name":"Getting Started with Aurelia and TypeScript","description":"Today, Core Aurelia Team member, Mike Graham, teaches us about combining Aurelia and TypeScript.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2015/5/6/getting-started-with-aurelia-and-typescript","html":"blog/2015/5/6/getting-started-with-aurelia-and-typescript/index.html","fragment":"blog/2015/5/6/getting-started-with-aurelia-and-typescript/index-fragment.html","self":"blog/2015/5/6/getting-started-with-aurelia-and-typescript/index.json"},"content":"\r\nToday, Core Aurelia Team member, Mike Graham, teaches us about combining Aurelia and TypeScript.\r\n\r\n### About The Author\r\n\r\nMike Graham (@cmichaelgraham) is a software architect with 25 years of experience designing and building extensible visualization platforms and solutions for the energy industry. He is working to help make Aurelia a first class development environment for building mapping applications using TypeScript.\r\n\r\n## Introduction\r\n\r\nToday, we will see how easy it is to get started developing on the Aurelia platform and how to leverage the power of TypeScript, a free and open source programming language developed and maintained by Microsoft.  We will focus on the main benefits and how to efficiently get going.\r\n\r\nAs a note before we get started, one of the truly great things about the Aurelia platform is its ability to support a wide variety of development scenarios.  Choosing the TypeScript language for Aurelia development is one of several great development language choices.\r\n\r\n## TypeScript Benefits\r\n\r\nIn case you are wondering why you would want to look at using TypeScript, lets explore some of the features it provides.\r\n\r\n### JavaScript IS TypeScript\r\n\r\nIt is super easy to get started with TypeScript because JavaScript IS TypeScript.  This means we can just rename our `.js` files to `.ts` files and we are off and running.\r\n\r\nWe will then immediately see TypeScript benefits before we've done anything to our code.\r\n\r\n### The Integrated Development Environment (or IDE)\r\n\r\nTypeScript benefits show up at design time, when we are actually writing and compiling our code.  We gain access to these benefits through `tooling` exposed by the IDE of your choice.  We have many excellent choices for our IDE.  Here is a short list of options:\r\n\r\n1. <a href=\"https://atom.io/\" target=\"_blank\">Atom</a> IDE with the [Atom-TypeScript](https://github.com/TypeStrong/atom-typescript) extension\r\n1. [WebStorm](https://www.jetbrains.com/webstorm/) IDE\r\n1. [Sublime Text](http://www.sublimetext.com/) IDE with the [Sublime-TypeScript](https://github.com/Microsoft/TypeScript-Sublime-Plugin) extension\r\n1. [Eclipse](https://www.eclipse.org/downloads/) IDE with the [Eclipse-TypeScript](https://github.com/palantir/eclipse-typescript) extension\r\n1. [Visual Studio 2013](https://msdn.microsoft.com/en-us/library/dd831853.aspx) IDE\r\n1. [Visual Studio 2015](https://www.visualstudio.com/en-us/downloads/visual-studio-2015-ctp-vs.aspx) IDE\r\n1. [Visual Studio Code](https://code.visualstudio.com//) IDE\r\n\r\n### Type Inference\r\n\r\nThe TypeScript language service (which is leveraged by the IDE), can use [type inference](https://github.com/Microsoft/TypeScript/wiki/Type-Inference) to make intelligent observations about our code and its expected types, before we ever add any type information ourselves.\r\n\r\nSome of the benefits are possible because there is additional information that the IDE tooling has about the code.\r\n\r\nType inference might be relatively simple, like picking up the type of a constant that is assigned to a variable at initialization, and flowing that type through a function return.\r\n\r\nIt may also be quite sophisticated like picking up a function signature from assignment to a known callback type, defined in a type definition file.\r\n\r\n### IntelliSense\r\n\r\nWhen the IDE knows type information, it can offer statement completion, reducing typos and also making platforms like Aurelia EVEN easier to learn and use (we'll see examples of this when we start developing our application).  \r\n\r\nThe statement completion pop-up choices also includes any inline doc comments like descriptions, parameters and parameter descriptions and return types.\r\n\r\nIt makes it so easy for developers to explore, experiment with, and discover the features of an API.\r\n\r\n### Intelligent Refactoring\r\n\r\nAs an application grows in size, renaming and other refactoring operations become necessary.  Without type information, error-prone search and replace options must be used, but with TypeScript, the language service knows where the renaming should occur and where it is a different identifier that happens to have the same name.\r\n\r\n### Code Generation\r\n\r\nTypeScript type annotations `evaporate` when the code is compiled.  The generated JavaScript is canonical JavaScript, well formatted, and what an expert would write to implement the corresponding patterns.\r\n\r\n### Type Definition Files\r\n\r\nOne very important capability of TypeScript is the ability to wrap the API of an existing JavaScript library with defined types.  This is done by creating a file with a `.d.ts` extension that declares the types a developer can expect from the API.  Many, many JavaScript libraries have been wrapped by `.d.ts` files, created by the open source community and housed at [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped).\r\n\r\nEach Aurelia repo has a corresponding `.d.ts` file, as seen [here](https://github.com/cmichaelgraham/aurelia-typescript-atom/tree/900655787fc7775d87e79e061eb1539415b3b856/skel-nav-ts/typings/aurelia).\r\n\r\n## Aurelia TypeScript Application\r\n\r\nGreat!  You made it this far, and hopefully by now you're convinced that TypeScript might be able to help you.\r\n\r\nIf you want to follow along, building and running as we go, you can read the [steps outlined here](https://github.com/cmichaelgraham/aurelia-typescript-atom).  If not, no worries; you can just look at the code and screen shots below to get a more concrete feel for the benefits obtained by using TypeScript to build Aurelia applications.\r\n\r\nIf you have trouble adapting the sample to your particular development environment, feel free to engage with the Aurelia community's vibrant [gitter channel](https://gitter.im/Aurelia/Discuss) or post questions on [Stack Overflow](http://stackoverflow.com/questions/tagged/aurelia), using the `aurelia` tag.\r\n\r\nThere is an excellent [getting started](https://player.vimeo.com/video/117778145) video that shows the basics of getting an Aurelia application up an running using ES6 development.\r\n\r\nLets dive in and look at some code.\r\n\r\n### main.ts\r\n\r\nThe role of the `main.ts` file is to initialize Aurelia and then start up with the `app` view and view model.\r\n\r\nThe first thing to notice is that the [TypeScript version](https://github.com/cmichaelgraham/aurelia-typescript-atom/tree/900655787fc7775d87e79e061eb1539415b3b856/skel-nav-ts/views/main.ts) of this code and the [JavaScript version](http://aurelia.io/docs.html#startup-and-configuration) are identical.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    export function configure(aurelia) {\r\n      aurelia.use\r\n        .standardConfiguration()\r\n        .developmentLogging();\r\n    \r\n      aurelia.start().then(a => a.setRoot());\r\n    }\r\n  \r\n```\r\n\r\nThe reason this works is because JavaScript IS TypeScript.\r\n\r\nBut now lets pretend that we didn't have the code to paste in from the Aurelia documentation.  This is where TypeScript begins to shine.\r\n\r\nNotice that the configure function accepts an `Aurelia` object as its parameter.  At this point no type has been specified, so the IDE tooling can't help us figure out how to use the object we've been passed.\r\n\r\nTo obtain the `Aurelia` type, we need to import it from the `aurelia-framework` repo.  As we type the import statement, the IDE tooling suggests possible imports we might want:\r\n\r\n![main01](/content/images/2015/05/main-01.jpg)\r\n\r\nNow we can fill in the actual type we want to pull in from the `aurelia-framework` repo.  Again the IDE tooling leads the way, showing us the repo's exports, and helping us pick the one we are seeking:\r\n\r\n![main 02](/content/images/2015/05/main-02.jpg)\r\n\r\nThe fact that we're picking the name from a list and not typing it out manually reduces typos.  But lets say we're feeling pretty good about our typing, and ignore the IDE tooling's helpful suggestion.  If we do make a typo, a friendly, unobtrusive red squiggly underline is presented to us.\r\n\r\n![main 02B](/content/images/2015/05/Main-02B.jpg)\r\n\r\nSo at this point we have successfully imported the `Aurelia` type, and can now use it to annotate the parameter type in the `configure` function as shown below.  Type annotation allows the IDE tooling to help us discover and chose valid members of the object.\r\n\r\n![main 03](/content/images/2015/05/main-03.jpg)\r\n\r\nAt this point you may be wondering how the IDE actually knew about the types in the `aurelia-framework` import.  Let's talk about that next.\r\n\r\n### TypeScript Type Definition (`.d.ts`) Files\r\n\r\nEach Aurelia repo has a corresponding `.d.ts` file that declares the type information exposed by that repo's public API.  Our project's Aurelia `.d.ts` files can be found [here](https://github.com/cmichaelgraham/aurelia-typescript/tree/master/master/typings/aurelia).\r\n\r\nYou can inspect the [`aurelia-framework.d.ts` file](https://github.com/cmichaelgraham/aurelia-typescript/blob/master/master/typings/aurelia/aurelia-framework.d.ts) if you'd like a glimpse at the syntax that defined the `Aurelia` type we used in our example above. \r\n\r\nBut how does the IDE know which `.d.ts` files to include in our project?  The next section explains that very mechanism.\r\n\r\n### The `tsconfig.json` Project File\r\n\r\nThe `tsconfig.json` file is a universal project format for TypeScript.  Our project's `tsconfig.json` file is located [here](https://github.com/cmichaelgraham/aurelia-typescript-atom/tree/900655787fc7775d87e79e061eb1539415b3b856/skel-nav-ts/tsconfig.json).\r\n\r\nThis is the tsconfig.json file in our project (with the files property stripped down to save space).\r\n\r\n\r\n\r\n  ```JavaScript\r\n    {\r\n        \"version\": \"1.5.1\",\r\n        \"compilerOptions\": {\r\n            \"target\": \"es5\",\r\n            \"module\": \"amd\",\r\n            \"declaration\": false,\r\n            \"noImplicitAny\": false,\r\n            \"removeComments\": false,\r\n            \"noLib\": true,\r\n            \"emitDecoratorMetadata\": true\r\n        },\r\n        \"filesGlob\": [\r\n            \"./**/*.ts\",\r\n            \"!./node_modules/**/*.ts\"\r\n        ],\r\n        \"files\": [\r\n            // ...\r\n        ]\r\n    }\r\n  \r\n```\r\n\r\nThe `files` property is filled in automatically by Atom-TypeScript using the `filesGlob` property's patterns.  This occurs when saving `tsconfig.json`.\r\n\r\nFor a description of the `compilerOptions`, please refer to the [TypeScript wiki Compiler-Options page](https://github.com/Microsoft/TypeScript/wiki/Compiler-Options).  `emitDecoratorMetadata` is an experimental compiler option that allows the @autoinject decorator to do its job (described in the next section).\r\n\r\nAtom-TypeScript has an excellent description of the tsconfig.json details [here](https://github.com/TypeStrong/atom-typescript/blob/master/docs/tsconfig.md)\r\n\r\nSo the answer to the question about how Atom-TypeScript knows which files to include comes from (in our case) the expression: `./**/*.ts`, which says start in the root folder of the project and pull in any files ending in `.ts` (which includes files that end in `.d.ts`), so all of our `.d.ts` files in the typings folder will be included.\r\n\r\nThe final concept we'll explore before we wrap up (and provide you with a list related resources), is the topic of `decorators`\r\n\r\n### Decorators\r\n\r\nFrom the excellent [decorator description](https://github.com/wycats/javascript-decorators) by Mr. [Yehuda Katz](http://yehudakatz.com/): \r\n\r\n> Decorators make it possible to annotate and modify classes and properties at design time.\r\n>\r\n> While ES5 object literals support arbitrary expressions in the value position, ES6 classes only support literal functions as values. Decorators restore the ability to run code at design time, while maintaining a declarative syntax.\r\n>\r\n> A decorator is:\r\n\r\n> * an expression\r\n> * that evaluates to a function\r\n> * that takes the target, name, and property descriptor as arguments and\r\n> * optionally returns a property descriptor to install on the target object\r\n\r\nLets make that abstract concept more concrete by looking at some specific ways that Aurelia uses decorators.\r\n\r\nFirst off, decorators are actually part of the ES7 (a.k.a ES2016) spec, but are available for your use today through the the TypeScript 1.5 Compiler (here's a TypeScript [roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap#15)).\r\n\r\nNow lets look at some code that shows how easy it is for you to use decorators.\r\n\r\n#### dependency injection\r\n\r\nWe are going to look at a simple example of dependency injection. You may be very familiar with the concept of dependency injection, but if you're not, think about the flickr view and view model in our sample application.  The view model needs to retrieve a collection of images from the Flickr web services.\r\n\r\n![flickr ui](/content/images/2015/05/flickr-ui.jpg)\r\n\r\nWe are going to \"separate our concerns\" into separate responsibilities - our flickr view model will worry only about how to display the results that come back from the web service, and the Aurelia `HttpClient` will be responsible for managing the HTTP retrieval of data from the web service.\r\n\r\nWe really don't want our flickr view model to even worry about how to obtain the Aurelia `HttpClient`.  We just want to specify in our constructor that we need it and we'll let the framework take care of the rest.\r\n\r\nAll we have to do to get the Aurelia framework to \"inject\" the Aurelia Http Client into our constructor is to first import and then place the `@autoinject` decorator on the class.\r\n\r\nIntelliSense will help us discover and correctly type the text as before.\r\n\r\n![autoinject intellisense](/content/images/2015/05/autoinject-decorator.jpg)\r\n\r\nSo you can see, we just ask for the `HttpClient` and then we use its public API.  In fact, our flickr view model will be happy with any object that provides the same (polymorphic) API - that is one of the very powerful aspects of dependency injection.\r\n\r\n![autoinject 2](/content/images/2015/05/autoinject-decorator-2-1.jpg)\r\n\r\nNow lets dive a little deeper.  Don't worry if you don't understand everything going on in the next section as we talk about the decorator called `bindable`.\r\n\r\n#### bindable\r\n\r\nBefore we talk about the `bindable` decorator, we'll need a little bit of background.\r\n\r\nFirst, a `custom element` is a reusable view / view model pair that can be embedded in another view.\r\n\r\nIn our sample project, we have a `custom element` called `nav-bar`:\r\n\r\n![nav-bar](/content/images/2015/05/nav-bar.jpg)\r\n\r\nThe `nav-bar` custom element gives us a great way to \"encapsulate\" the layout and functionality of our navigation menu in a single unit that can be included with a clean, understandable syntax:\r\n  \r\n![nav-bar binding 2](/content/images/2015/05/nav-bar-binding-2.jpg)\r\n\r\nNotice in the code above that our `custom element` (the `nav-bar`) has a router property that we are able to set (`bind`) to the router in our main application.  This works because the Aurelia framework supports bindable properties in `custom elements`.  But how does the Aurelia framework know which properties are to be exposed as such?  (hopefully you are thinking DECORATORS !!).\r\n\r\nWithin the `nav-bar` view model, the `@bindable` decorator is used to alert the Aurelia framework that we want the `router` property to be bindable.\r\n\r\n![bindable decorator](/content/images/2015/05/bindable-decorator.jpg)\r\n\r\nSo in the outer code that embeds the `nav-bar`, we bound it to the router, and now router is accessible to the `nav-bar`'s view.  Notice how clean and expressive the `nav-bar`'s view template is, when referencing the router object's properties:\r\n\r\n![nav-bar binding](/content/images/2015/05/nav-bar-binding-1.jpg)\r\n\r\nI'm sure at this point you're ready to start building great applications in TypeScript and Aurelia.  Here are a few resources you can utilize as you start down the path.  Thanks for your interest and we look forward to seeing you online !!\r\n\r\n### Resources\r\n\r\n* [TypeScript Website](http://www.typescriptlang.org/)\r\n* [TypeScript on GitHub](https://github.com/microsoft/TypeScript)\r\n* [TypeScript Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap#15)\r\n* [Aurelia TypeScript Samples](https://github.com/cmichaelgraham/aurelia-typescript#aurelia-typescript)\r\n* [Aurelia Gitter Channel](https://gitter.im/Aurelia/Discuss)\r\n* [Aurelia Website](http://aurelia.io/)\r\n* [Aurelia Docs](http://aurelia.io/docs.html)\r\n* [Aurelia Blog](http://blog.durandal.io/)\r\n\r\n## Editor's Note\r\n\r\nThanks Mike for sharing with us about using TypeScript with Aurelia today!\r\n\r\nNow, let me extend an invitation to our community to help us by providing some additional feedback. One thing that helps to make TypeScript development much nicer is having a TypeScript Definition File. These can be tedious and time-consuming to create, especially when you want them to be accurate across multiple libraries and releases. Our current definition files are manually synced and lack some of the type information we think would be nice to have. We are investigating several options to improve this. Here are a few things we could do:\r\n\r\n* **Convert to TypeScript** - We could convert Aurelia's codebase to TypeScript. This would allow us to use the TypeScript compiler to generate pure ES5 output code in the same way that we use Babel today, but we would also be able to generate a good Definition File.\r\n* **Leverage Flow Types + Babel Plugin** - We could keep our existing ES6/7 codebase and continue to compile it with Babel, but we can decorate the code with [Flow](http://flowtype.org/) types. A community member has written a Babel plugin that can generate a TypeScript definition file using the ES6 code and Flow type annotations.\r\n* **Dual Compilation** - Write Aurelia in a way that it can be compiled by both Babel and TypeScript. Babel can ignore Flow types and interfaces, so this should be possible. Then, we can use the Babel compiler to generate our JavaScript build and the TypeScript compiler to generate the Definition Files.\r\n\r\nNote, that none of these options affects how you, developers of apps, write your code. It only affects the development of Aurelia itself. We'd love to hear what you think of these options and/or if you have any ideas of your own. Thanks!"}