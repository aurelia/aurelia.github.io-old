{"name":"New Validation Alpha is Here!","description":"We've been working hard on a validation rewrite and today we're excited to announce the Aurelia validation libraries are in alpha! Read on to get the scoop from core team member Jeremy Danyow...","author":{"name":"AureliaEffect"},"links":{"static":"blog/2016/6/14/new-validation-alpha-is-here","html":"blog/2016/6/14/new-validation-alpha-is-here/index.html","fragment":"blog/2016/6/14/new-validation-alpha-is-here/index-fragment.html","self":"blog/2016/6/14/new-validation-alpha-is-here/index.json"},"content":"\r\nWe've been working hard on a validation rewrite and today we're excited to announce the Aurelia validation libraries are in alpha! Read on to get the scoop from core team member Jeremy Danyow...\r\n\r\nAfter gathering all your feedback and use-cases we've refactored validation into two separate libraries with a robust set of standard behaviors and a simpler, more flexible API surface for easier customization:\r\n\r\n* `aurelia-validation` - a generic validation library that provides a `ValidationController`, a `validate` binding behavior, a `Validator` interface and more.\r\n* `aurelia-validatejs` - a [validatejs](https://validatejs.org/) powered implementation of the `Validator` interface along with fluent and decorator based APIs for defining rules for your components and data.\r\n \r\n## Example\r\n\r\nLet's put together a simple registration form to demonstrate the new validation APIs.\r\n\r\n#### 1) Create a new module that exports a `RegistrationForm` class:\r\n\r\n*registration-form.js*\r\n\r\n\r\n\r\n  ```JavaScript\r\n    export class RegistrationForm {\r\n      firstName = '';\r\n      lastName = '';\r\n      email = '';\r\n    \r\n      submit() {\r\n        // todo: call server...\r\n      }\r\n    }\r\n  \r\n```\r\n<br/>\r\n\r\n#### 2) Create a registration form view:\r\n\r\n> NOTE: I'm using bootstrap markup in this example.  Bootstrap is not required.  You can use whatever you want.\r\n\r\n*registration-form.html*\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <template>\r\n      <form submit.delegate=\"submit()\">\r\n    \r\n        <div class=\"form-group\">\r\n          <label class=\"control-label\" for=\"first\">First Name</label>\r\n          <input type=\"text\" class=\"form-control\" id=\"first\" placeholder=\"First Name\"\r\n                 value.bind=\"firstName\">\r\n        </div>\r\n    \r\n        <div class=\"form-group\">\r\n          <label class=\"control-label\" for=\"last\">Last Name</label>\r\n          <input type=\"text\" class=\"form-control\" id=\"last\" placeholder=\"Last Name\"\r\n                 value.bind=\"lastName\">\r\n        </div>\r\n    \r\n        <div class=\"form-group\">\r\n          <label class=\"control-label\" for=\"email\">Email</label>\r\n          <input type=\"text\" class=\"form-control\" id=\"email\" placeholder=\"Email\"\r\n                 value.bind=\"email\">\r\n        </div>\r\n    \r\n        <button type=\"submit\" class=\"btn btn-primary\">Submit</button>\r\n      </form>\r\n    </template>\r\n  \r\n```\r\n<br/>\r\n\r\n#### 3) Install `aurelia-validation`:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    jspm install aurelia-validation\r\n  \r\n```\r\n<br/>\r\n\r\n#### 4) Give our view-model an instance of a `ValidationController`:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {inject, NewInstance} from 'aurelia-dependency-injection';\r\n    import {ValidationController} from 'aurelia-validation';\r\n    \r\n    @inject(NewInstance.of(ValidationController))\r\n    export class RegistrationForm {\r\n      constructor(controller) {\r\n        this.controller = controller;\r\n      }\r\n  \r\n```\r\n\r\nThe `ValidationController` manages a set of bindings and a set of renderers, controlling when to tell the renderers to render or unrender validation errors.  The `@inject(NewInstance.of(ValidationController))` line of code is important.  I'm going to skip discussing it for now and revisit it later in this post.\r\n\r\n#### 5) Configure the `ValidationController`:\r\n\r\nThe default \"trigger\" that tells the validation controller to validate bindings is the DOM `blur` event.  All in all there are three standard \"validation triggers\" to choose from:\r\n\r\n1. `blur`: Validate the binding when the binding's target element fires a DOM \"blur\" event. \r\n2. `change`: Validate the binding when it updates the model due to a change in the view.\r\n3. `manual`: Manual validation.  Use the controller's `validate()` and  `reset()` methods to validate all bindings.\r\n\r\nTo configure the controller's validateTrigger trigger, import the `validateTrigger` enum: `import {validateTrigger} from 'aurelia-validation';` and assign the controller's `validateTrigger ` property:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    controller.validateTrigger = validateTrigger.manual;\r\n  \r\n```\r\n<br/>\r\n\r\n#### 6) Implement the view-model's submit method.\r\n\r\nNo matter which validation trigger you chose, you're probably going to want to validate all bindings when the form is submitted.  Use the controller's `validate()` method to do this:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    submit() {\r\n      let errors = this.controller.validate();\r\n      ...\r\n    }\r\n  \r\n```\r\n<br/>\r\n\r\n#### 7) Define validation rules:\r\n\r\nAt this point your view-model should look like this:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {inject, NewInstance} from 'aurelia-dependency-injection';\r\n    import {ValidationController} from 'aurelia-validation';\r\n    \r\n    @inject(NewInstance.of(ValidationController))\r\n    export class RegistrationForm {\r\n      firstName = '';\r\n      lastName = '';\r\n      email = '';\r\n    \r\n      constructor(controller) {\r\n        this.controller = controller;\r\n      }\r\n    \r\n      submit() {\r\n        let errors = this.controller.validate();\r\n        // todo: call server...\r\n      }\r\n    }\r\n  \r\n```\r\n\r\nLet's bring in the `aurelia-validatejs` plugin which has APIs for defining rules and an implementation of the `Validator` interface that the `ValidationController` depends on to validate bindings.  You can of course build your own implementation of `Validator`; one is in the works for breeze.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    jspm install aurelia-validatejs\r\n  \r\n```\r\n\r\nNow lets define some rules on our RegistrationForm class.  You could use the decorator API:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {required, email} from 'aurelia-validatejs'\r\n    ...\r\n    ...\r\n    export class RegistrationForm {\r\n      @required\r\n      firstName = '';\r\n    \r\n      @required\r\n      lastName = '';\r\n    \r\n      @required\r\n      @email\r\n      email = '';\r\n    \r\n  \r\n```\r\n\r\nOr you can use the fluent API:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {ValidationRules} from 'aurelia-validatejs'\r\n    ...\r\n    ...\r\n    export class RegistrationForm {\r\n      ...\r\n    }\r\n    \r\n    ValidationRules\r\n      .ensure('firstName').required()\r\n      .ensure('lastName').required()\r\n      .ensure('email').required().email()\r\n      .on(RegistrationForm);\r\n  \r\n```\r\n<br/>\r\n\r\n#### 8) Add validation to our bindings\r\n\r\nNow that the view-model has been implemented and rules are defined, it's time to add validation to the view.\r\n\r\nFirst, let's use the `validate` binding behavior to all of the input value bindings on our form to indicate these bindings require validation...\r\n\r\nChange `value.bind=\"someProperty\"` to `value.bind=\"someProperty & validate\"`.\r\n\r\nThe binding behavior will obey the controller's validation trigger configuration and notify the controller when the binding instance requires validation.  In turn, the controller will validate the object/property combination used in the binding and instruct the renderers to render or unrender errors accordingly.\r\n\r\n#### 9) Create a ValidationRenderer\r\n\r\nWe're almost done.  One of the last things we need to do is define how validation errors will be rendered.  This is done by creating one or more [`ValidationRenderer`](https://github.com/aurelia/validation/blob/master/src/validation-renderer.js) implementations.  A validation renderer implements a simple API `render(error, target)` and `unrender(error, target)` (error is a [`ValidationError`](https://github.com/aurelia/validation/blob/master/src/validation-error.js) instance and target is the binding's DOM element).\r\n\r\nSince we're using bootstrap, we'll create a renderer that adds the `has-error` css class to the `form-group` div of fields that have errors.  We'll also add a `<span class=\"help-text\">` elements to the form-group div, listing each of the field's errors.  [Here's](https://gist.github.com/jdanyow/ea843c24956cfffff48bb21776291f6a) the BootstrapFormValidationRenderer code and this is what a rendered error will look like:\r\n\r\n![last name is required](http://i.imgur.com/1igykkW.png)\r\n\r\n\r\n##### 10) Register the validation renderer with the component's controller.\r\n\r\nNow that we have a render implementation we need to tell the controller to use the renderer.  The `aurelia-validate` library ships with a `validation-renderer` custom attribute you can use for this purpose:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <form submit.delegate=\"submit()\"\r\n          validation-renderer=\"bootstrap-form\">\r\n  \r\n```\r\n\r\nYou give the attribute the name of a renderer registration and it will resolve the renderer from the container and register it with the nearest controller instance.\r\n\r\nAt this point the view looks like this:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <template>\r\n      <form submit.delegate=\"submit()\"\r\n            validation-renderer=\"bootstrap-form\">\r\n    \r\n        <div class=\"form-group\">\r\n          <label class=\"control-label\" for=\"first\">First Name</label>\r\n          <input type=\"text\" class=\"form-control\" id=\"first\" placeholder=\"First Name\"\r\n                 value.bind=\"firstName & validate\">\r\n        </div>\r\n    \r\n        <div class=\"form-group\">\r\n          <label class=\"control-label\" for=\"last\">Last Name</label>\r\n          <input type=\"text\" class=\"form-control\" id=\"last\" placeholder=\"Last Name\"\r\n                 value.bind=\"lastName & validate\">\r\n        </div>\r\n    \r\n        <div class=\"form-group\">\r\n          <label class=\"control-label\" for=\"email\">Email</label>\r\n          <input type=\"email\" class=\"form-control\" id=\"email\" placeholder=\"Email\"\r\n                 value.bind=\"email & validate\">\r\n        </div>\r\n    \r\n        <button type=\"submit\" class=\"btn btn-primary\">Submit</button>\r\n      </form>\r\n    </template>\r\n  \r\n```\r\n<br/>\r\n\r\n## Try It\r\n\r\nHere's a live demo that includes an example  \"validation summary\" component using aurelia-validation.\r\n\r\nExercises for the reader:\r\n\r\n1. Edit registration-form.js... uncomment the code to change the validation trigger to \"manual\" or \"change\"\r\n2. In registration-form.js, remove the validation decorators on the class properties and uncomment the fluent rule definitions at the bottom of the file.\r\n\r\n<iframe src=\"https://gist.run/embed.html?id=381fdb1a4b0865a4c25026187db865ce\" frameborder=\"0\" width=\"100%\" height=\"550\"></iframe>\r\n\r\n---\r\n\r\n\r\n# Further Reading\r\n\r\nWe'll be providing more in-depth information in the docs however there's a few more things I want to cover in this post:\r\n\r\n### Fluent rule definition\r\n\r\nThe sample above demonstrates the fluent API and applying the rules to a class definition using the `.on(RegistrationForm)` method.  You can also use the `.on()` method with POJOs:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    let person = {\r\n      firstName: '',\r\n      lastName: '',\r\n      email: ''\r\n    };\r\n    \r\n    ValidationRules\r\n      .ensure('firstName').required()\r\n      .ensure('lastName').required()\r\n      .ensure('email').required().email()\r\n      .on(person);  // <-- define rules on the instance\r\n  \r\n```\r\n\r\nThere's no requirement to use the `.on()` method however.  You can capture the ruleset in a property and pass it into the `validate` decorator as a parameter if you prefer:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    export class RegistrationForm {\r\n      rules = ValidationRules\r\n        .ensure('firstName').required()\r\n        .ensure('lastName').required()\r\n        .ensure('email').required().email();\r\n        \r\n      person = {\r\n        firstName: '',\r\n        lastName: '',\r\n        email: ''\r\n      };\r\n    }\r\n  \r\n```\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <!-- pass ruleset to decorator via parameter: -->\r\n    <input value.bind=\"person.firstName & validate:rules\">\r\n  \r\n```\r\n<br/>\r\n\r\n### The `validation-errors` attribute\r\n\r\nYou may want to data-bind to the current set of \"broken rules\".  The `aurelia-validation` library ships with a custom attribute called `validation-errors` that will populate the property it's bound to with the current set of validation errors.\r\n\r\nHere's how you could use the `validation-errors` attribute to display the list of errors with links that will focus the input element that has the error.\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <template>\r\n      <form validation-errors.bind=\"myErrors\">\r\n        <ul>\r\n          <li repeat.for=\"errorInfo of myErrors\">\r\n            ${errorInfo.error.message}\r\n            <a href=\"#\" click.delegate=\"errorInfo.target.focus()\"> Fix it</a>\r\n          </li>\r\n        </ul>\r\n        ...\r\n    </template>\r\n  \r\n```\r\n<br/>\r\n\r\n### What is `NewInstance.of(ValidationController)` ???\r\n\r\n`NewInstance.of` is a dependency-injection **resolver** that ships with `aurelia-dependency-injection`.  Resolvers tell the container *how* to resolve a particular key.  In this case it's telling the container to always retrieve a *new instance* of a ValidationController.  This does a couple things:\r\n\r\n  1. It ensures the registration form gets it's own instance of a ValidationController rather than sharing one with another component.  Most of the time this is the behavior you'll want.\r\n\r\n  2. When Aurelia instantiates components it uses *a child container of the outer component*.  This is important because it means behind your component hierarchy is a hierarchy of container instances.  Our validation controller instance is installed in that hierarchy, making it easy for downstream renderer instances and validate binding behaviors to locate the relevant validation controller.\r\n\r\n### My form inputs are custom elements... is that supported?\r\n\r\n**Yes**.  The `validate` binding behavior works with custom elements however there are a couple best practices:\r\n\r\n1. If you're using `validateTrigger.blur` (the default), you'll want to make sure your custom element publishes DOM `blur` events.\r\n2. Your custom element should expose a `focus` method *on it's DOM element* if you plan on building a validation summary that calls `focus()` on the validation error's target element.\r\n\r\nHere's an example of a widget that might appear in a form:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <widget id=\"first\" label=\"First Name\"\r\n            value.bind=\"firstName & validate\">\r\n    </widget>\r\n  \r\n```\r\n\r\nA widget implementation that would work well with the validation system would look like this:\r\n\r\n\r\n\r\n  ```JavaScript\r\n    <template>\r\n      <div class=\"form-group\">\r\n        <label class=\"control-label\" for=\"${id}\">${label}</label>\r\n        <input type=\"text\" class=\"form-control\"\r\n               id=\"${id}\" ref=\"input\" placeholder=\"${label}\"\r\n               value.two-way=\"value\"\r\n               blur.trigger=\"blur()\">\r\n      </div>\r\n    </template>\r\n  \r\n```\r\n\r\n\r\n\r\n  ```JavaScript\r\n    import {bindable, inject, DOM} from 'aurelia-framework';\r\n    \r\n    @inject(Element)\r\n    export class Widget {\r\n      @bindable id;\r\n      @bindable label;\r\n      @bindable value;\r\n    \r\n      constructor(element) {\r\n        this.element = element;\r\n    \r\n        // ensure the element exposes a \"focus\" method\r\n        element.focus = () => this.input.focus();\r\n      }\r\n    \r\n      blur() {\r\n        // forward \"blur\" events to the custom element\r\n        const event = DOM.createCustomEvent('blur');\r\n        this.element.dispatchEvent(event);\r\n      }\r\n    }\r\n  \r\n```\r\n<br/>\r\n\r\n### I don't like the way all this works.  It's not meeting my requirements.\r\n\r\nLet us know!  File a github issue.  Worst case scenario is you'll need to implement your own `validate` binding behavior, which isn't hard to do.\r\n\r\n# Next Steps\r\n\r\nWe're going to be working on **more docs**, **localization/i18n** and cleaning up the list of **issues** in the validation repositories.  Keep sending your feedback!"}