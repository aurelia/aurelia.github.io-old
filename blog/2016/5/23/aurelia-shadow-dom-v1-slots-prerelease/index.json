{"name":"Aurelia Shadow DOM v1 Slots Prerelease","description":"The open web and web standards have always been an important part of Aurelia. We don't want to abstract the web away from you, but rather enable you to use cutting edge web technology in a practical way while building applications. Our commitment to these principles brings the Aurelia community the first implementation of Shadow DOM v1 Slots. It's an awesome piece of technology and we look forward to seeing how you leverage it to build amazing apps.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2016/5/23/aurelia-shadow-dom-v1-slots-prerelease","html":"blog/2016/5/23/aurelia-shadow-dom-v1-slots-prerelease/index.html","fragment":"blog/2016/5/23/aurelia-shadow-dom-v1-slots-prerelease/index-fragment.html","self":"blog/2016/5/23/aurelia-shadow-dom-v1-slots-prerelease/index.json"},"content":"\r\nThe open web and web standards have always been an important part of Aurelia. We don't want to abstract the web away from you, but rather enable you to use cutting edge web technology in a practical way while building applications. Our commitment to these principles brings the Aurelia community the first implementation of Shadow DOM v1 Slots. It's an awesome piece of technology and we look forward to seeing how you leverage it to build amazing apps.\r\n\r\n## What is Shadow DOM v1 Slots?\r\n\r\nThe *slot* mechanism of [the Shadow DOM v1 spec](http://w3c.github.io/webcomponents/spec/shadow/) is used to declare how two separate DOM trees can be merged together to produce a single visual representation. Why is this important? Well, when creating custom elements, your custom element often has a set of DOM nodes that represent the view of the element. Then, when a developer uses the custom element, that developer may also place HTML inside the content of the element. This results in two DOM trees that must be merged together to produce the final visual.\r\n\r\nTo illustrate this, imagine an Aurelia `name-tag` HTML component implemented like this:\r\n\r\n\r\n\r\n  ```HTML\r\n    <template bindable=\"color\" css=\"background: ${color}\">\r\n      <require from=\"./name-tag.css\"></require>\r\n    \r\n      <div class=\"header\">\r\n        <h3>HELLO</h3>\r\n        <h4>my name is</h4>\r\n      </div>\r\n    \r\n      <div class=\"body\">\r\n        <slot></slot>\r\n      </div>\r\n    \r\n      <div class=\"footer\"></div>\r\n    </template>\r\n  \r\n```\r\n\r\nNow, in another view, you want to use this `name-tag`, providing different names as content:\r\n\r\n\r\n\r\n  ```HTML\r\n    <template>\r\n      <require from=\"./name-tag.html\"></require>\r\n    \r\n      <name-tag color=\"red\">John</name-tag>\r\n      <name-tag color=\"blue\">Bob</name-tag>\r\n    </template>\r\n  \r\n```\r\n\r\nLook back up at the `name-tag` view. Do you see the `slot` element? This tells the renderer where to \"project\" the content that is placed inside of the `name-tag`. So, in the first case, the text \"John\" will be rendered at the location of the `slot`. At runtime, the composed DOM tree will look something like this:\r\n\r\n\r\n\r\n  ```HTML\r\n    <name-tag>\r\n      <div class=\"header\">\r\n        <h3>HELLO</h3>\r\n        <h4>my name is</h4>\r\n      </div>\r\n    \r\n      <div class=\"body\">\r\n        John\r\n      </div>\r\n    \r\n      <div class=\"footer\"></div>\r\n    </name-tag>\r\n  \r\n```\r\n\r\n## What Else Can It Do?\r\n\r\nThe scenario above uses a \"default\" slot because the `slot` has no `name` attribute. In Shadow DOM, you can create as many slots as you want, provided that you give them different names. Then, the content that gets projected into the Shadow DOM must specify which slot it wants using a `slot` attribute. If it indicates no particular slot (or is plain text) it will get projected into the default slot. Here's an example of named slots:\r\n\r\n**Shadow DOM Tree for a named-slot Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <template>\r\n      <div>\r\n        The first slot:\r\n        <div>\r\n          <slot name=\"slot1\"></slot>\r\n        </div>\r\n        The second slot:\r\n        <div>\r\n          <slot name=\"slot2\"></slot>\r\n        </div>\r\n      </div>\r\n    </template>\r\n  \r\n```\r\n\r\n**Using the named-slot Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <named-slot>\r\n      <div slot=\"slot1\">\r\n        This Goes in Slot 1\r\n      </div>\r\n    \r\n      <div slot=\"slot2\">\r\n        This Goes in Slot 2\r\n      </div>\r\n    </named-slot>\r\n  \r\n```\r\n\r\n**The Composed Visual Tree**\r\n\r\n\r\n\r\n  ```HTML\r\n    <named-slot>\r\n      <div>\r\n        The first slot:\r\n        <div>\r\n          <div slot=\"slot1\">\r\n            This Goes in Slot 1\r\n          </div>\r\n        </div>\r\n        The second slot:\r\n        <div>\r\n          <div slot=\"slot2\">\r\n            This Goes in Slot 2\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </named-slot>\r\n  \r\n```\r\n\r\nA nice feature of slots is that they can have fallback content. If nothing gets projected into the slot, the slot will render its fallback content:\r\n\r\n**Shadow DOM Tree for a fallback-content Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <template>\r\n      <div>\r\n        The first slot:\r\n        <div>\r\n          <slot name=\"slot1\"></slot>\r\n        </div>\r\n        The second slot:\r\n        <div>\r\n          <slot name=\"slot2\">This is some fallback content for slot 2...</slot>\r\n        </div>\r\n      </div>\r\n    </template>\r\n  \r\n```\r\n\r\n**Using the fallback-content Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <fallback-content>\r\n      <div slot=\"slot1\">\r\n        This Goes in Slot 1\r\n      </div>\r\n    </fallback-content>\r\n  \r\n```\r\n\r\n**The Composed Visual Tree**\r\n\r\n\r\n\r\n  ```HTML\r\n    <named-slot>\r\n      <div>\r\n        The first slot:\r\n        <div>\r\n          <div slot=\"slot1\">\r\n            This Goes in Slot 1\r\n          </div>\r\n        </div>\r\n        The second slot:\r\n        <div>\r\n          This is some fallback content for slot 2...\r\n        </div>\r\n      </div>\r\n    </named-slot>\r\n  \r\n```\r\n\r\nOk, now it's time to get crazy. What if the fallback content generates more slots!? Those fallback slots can be targeted by the content. Here's an example based on [a post from the WebKit team](https://webkit.org/blog/4096/introducing-shadow-dom-api/):\r\n\r\n**Shadow DOM Tree for a contact-card Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <template>\r\n      <b>Name</b>:\r\n      <slot name=\"fullName\">\r\n        <slot name=\"firstName\"></slot>\r\n        <slot name=\"lastName\"></slot>\r\n      </slot><br>\r\n      \r\n      <b>Email</b>:\r\n      <slot name=\"email\">Unknown</slot><br>\r\n      \r\n      <b>Address</b>:\r\n      <slot name=\"address\">Unknown</slot>\r\n    </template>\r\n  \r\n```\r\n\r\n**Using the contact-card Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <contact-card>\r\n      <span slot=\"fullName\">John Doe</span>\r\n      <span slot=\"address\">123 Main Street</span>\r\n    </contact-card>\r\n    \r\n    <contact-card>\r\n      <span slot=\"firstName\">Billy</span>\r\n      <span slot=\"lastName\">Bob</span>\r\n      <span slot=\"email\">billy@bob.com</span>\r\n    </contact-card>\r\n  \r\n```\r\n\r\n**The Composed Visual Tree**\r\n\r\n\r\n\r\n  ```HTML\r\n    <contact-card>\r\n      <b>Name</b>:\r\n      <span slot=\"fullName\">John Doe</span><br>\r\n      \r\n      <b>Email</b>:\r\n      Unknown<br>\r\n      \r\n      <b>Address</b>:\r\n      <span slot=\"address\">123 Main Street</span>\r\n    </contact-card>\r\n    \r\n    <contact-card>\r\n      <b>Name</b>:\r\n      <span slot=\"firstName\">Billy</span>\r\n      <span slot=\"lastName\">Bob</span><br>\r\n      \r\n      <b>Email</b>:\r\n      <span slot=\"email\">billy@bob.com</span><br>\r\n      \r\n      <b>Address</b>:\r\n      Unknown\r\n    </contact-card>\r\n  \r\n```\r\n\r\nThat was fun! Ok, what about slots, that target other slots with fallback content that generates slots...\r\n\r\n\r\n**Shadow DOM Tree for mixed-slot Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <template>\r\n      <div>\r\n        The first slot:\r\n        <div>\r\n          <slot name=\"slot1\">\r\n            Default content for Slot 1\r\n          </slot>\r\n        </div>\r\n        The default slot:\r\n        <div>\r\n          <slot>\r\n            Default Content for the Default Slot\r\n          </slot>\r\n        </div>\r\n        The second slot:\r\n        <div>\r\n          <slot name=\"slot2\">\r\n            The first fallback slot:\r\n            <div>\r\n              <slot name=\"fallbackSlot1\">\r\n                Default Content for Fallback Slot 1\r\n              </slot>\r\n            </div>\r\n            The second fallback slot:\r\n            <div>\r\n              <slot name=\"fallbackSlot2\"></slot>\r\n            </div>\r\n          </slot>\r\n        </div>\r\n      </div>\r\n    </template>\r\n  \r\n```\r\n\r\n**Shadow DOM Tree for slot-to-mixed-slot Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <template>\r\n      <require from=\"./mixed-slot\"></require>\r\n    \r\n      <div>\r\n        <mixed-slot>\r\n          <slot name=\"slot1\" slot=\"slot1\">Fallback Content for Projected Slot 1</slot>\r\n          <slot name=\"slot2\" slot=\"fallbackSlot2\">Fallback Content for Projected Slot 2</slot>\r\n        </mixed-slot>\r\n      </div>\r\n    </template>\r\n  \r\n```\r\n\r\n**Using the slot-to-mixed-slot Element**\r\n\r\n\r\n\r\n  ```HTML\r\n    <slot-to-mixed-slot>\r\n      <div slot=\"slot2\">This is user content for slot 2. (should appear in fallbackSlot2)</div>\r\n    </slot-to-mixed-slot>\r\n  \r\n```\r\n\r\n**The Composed Visual Tree**\r\n\r\n\r\n\r\n  ```HTML\r\n    <slot-to-mixed-slot>\r\n      <div>\r\n        The first slot:\r\n        <div>\r\n          Fallback Content for Projected Slot 1\r\n        </div>\r\n        The default slot:\r\n        <div>\r\n          Default Content for the Default Slot\r\n        </div>\r\n        The second slot:\r\n        <div>\r\n          <slot name=\"slot2\">\r\n            The first fallback slot:\r\n            <div>\r\n              Default Content for Fallback Slot 1\r\n            </div>\r\n            The second fallback slot:\r\n            <div>\r\n              <div slot=\"slot2\">This is user content for slot 2. (appearing in fallbackSlot2)</div>\r\n            </div>\r\n          </slot>\r\n        </div>\r\n      </div>\r\n    </slot-to-mixed-slot>\r\n  \r\n```\r\n\r\n## Implementation Limitations\r\n\r\nAll the above is implemented with Aurelia. It also works with *template controllers* such as `if` and `repeat` which can dynamically generate content. We've fixed up our `@child` and `@children` decorators to understand the new model as well.\r\n\r\nThe only known limitations of our implementation are as follows:\r\n\r\n* You cannot data-bind the slot's `name` attribute.\r\n* You cannot data-bind the `slot` attribute.\r\n\r\nWe will investigate lifting these restrictions in the future, but they aren't something you'd want to do in most cases as changes in these attributes would result in a full Shadow DOM re-projection, which wouldn't be the most \"slick\" thing for your users.\r\n\r\nOne final note about our implementation: We haven't attempted to create a \"generic\" polyfill designed to be used outside of Aurelia. Our slots implementation is baked into Aurelia's templating compiler and renderer so that it can provide maximum performance and meet the needs of our community. We haven't attempted to implement all the APIs of the spec, but rather to emulate the declarative rendering capabilities of slots. By programming against Aurelia in this way, you don't need to worry about whether or not your browser does or does not support slots natively. Aurelia will take care of it for you.\r\n\r\n## Performance\r\n\r\nThe good news is that Shadow DOM v1 no longer relies on CSS selectors for projection. The simple named slot mechanism allows us to do fast key/value lookup, enabling the new implementation to perform better than our previous v0 implementation. Additionally, in order to implement some of the Shadow DOM features, we did some reworking to how custom element content was compiled, resulting in a more light-weight process. This means that performance of custom element rendering is improved across the board.\r\n\r\nThe performance of default and named slots, as well as fallback content is very good. In general, performance is going to be directly tied to the complexities of the projections involved. Because fallback content can generate more slots, which can generate more slots which can pass-through to other slots...it's quite possible to create a complex performance nightmare for yourself. You know what you are doing though, so we didn't want to limit you, especially since the spec really is this flexible. Just keep in mind that you'll want to consider carefully how you leverage these features, not only to maintain good performance, but also for your own sanity.\r\n\r\n## Other Improvements\r\n\r\nWhile we were working on Shadow DOM, we took time to reduce duplication of code in several places, improve the techniques used for custom element content in general and cleanup the DOM structures we were using to track views. This all results in a faster and more memory efficient runtime.\r\n\r\n## How Do I Try It Out?\r\n\r\nWe're releasing the new Shadow DOM v1 Slot support as an out-of-band release. If you want to start using it now, you will need to install directly from the Github releases. You need two libraries:\r\n\r\n* [aurelia-pal-browser](https://github.com/aurelia/pal-browser/releases)\r\n* [aurelia-templating](https://github.com/aurelia/templating/releases)\r\n\r\nWe'd like to encourage you to try updating your existing projects early if you can. It will help us to track down any bugs our tests didn't account for and get you moving ahead earlier towards v1 compatibility. We'll release this update through our main release channel as part of the upcoming Release Candidate.\r\n\r\n## Summary\r\n\r\nToday we're excited to announce a pre-release version of our templating engine which includes a full working version of Web Components Shadow DOM v1 Slots. This is the first full implementation in any framework or library and it's our last major milestone on the journey towards Release Candidate."}