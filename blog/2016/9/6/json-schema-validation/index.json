{"name":"json-schema validation","description":"Like many of you, I have been keeping a close eye on the development of Aurelia's validation plugin(s) for some time now. This truly was the last missing piece of the puzzle for me in terms of being able to fully drop external JavaScript dependencies, and a notable gap in Aurelia's stable offering during the 1.0 release.","author":{"name":"AureliaEffect"},"links":{"static":"blog/2016/9/6/json-schema-validation","html":"blog/2016/9/6/json-schema-validation/index.html","fragment":"blog/2016/9/6/json-schema-validation/index-fragment.html","self":"blog/2016/9/6/json-schema-validation/index.json"},"content":"\nLike many of you, I have been keeping a close eye on the development of Aurelia's validation plugin(s) for some time now. This truly was the last missing piece of the puzzle for me in terms of being able to fully drop external JavaScript dependencies, and a notable gap in Aurelia's stable offering during the 1.0 release.\n\nSo it was a pleasant surprise to receive a gitter notification last weekend about a new release of the plugin. Recently I have been using a lot of [json-schema](http://json-schema.org/) for data validation before dumping it into a NoSQL database ([RethinkDB](https://rethinkdb.com/)), so I decided to see how hard it would be to implement an `aurelia-validation` plugin using [ajv](https://github.com/epoberezkin/ajv).\n\nTurns out it was delightfully easy! Below is the code in its nascent form. It took about 10 minutes to implement and it \"Just Workedâ„¢\".\n\n\n<code-listing>\n  <source-code lang=\"JavaScript\">\n    import {ValidationError} from 'aurelia-validation';\n\n    export class AjvValidator {\n      cache = new Map;\n      ajv = new Ajv({ v5: true, allErrors: true, format: 'full' });\n\n      validateObject(object) {\n        this.parseSchema(object);\n        let schemaId = this._schemaId(object);\n        if (!this.cache.has(schemaId)) {\n          console.warn('no schema defined for object');\n          return [];\n        }\n\n        let validate = this.cache.get(schemaId).validate;\n        let valid = validate(data);\n        return valid ? [] : validate.errors\n          .map(({ dataPath, keyword, message, params, schemaPath }) =>\n            new ValidationError(dataPath, message, object, propertyName));\n      }\n\n      validateProperty(object, propertyName) {\n        this.parseSchema(object);\n        let schemaId = this._schemaId(object);\n        if (!this.cache.has(schemaId)) {\n          console.warn('no schema defined for object');\n          return [];\n        }\n\n        if (!this.cache.get(schemaId).hasOwnProperty(propertyName)) {\n          console.warn('property not defined in schema: ', propertyName);\n          return [];\n        }\n\n        let definition = this.cache.get(schemaId);\n        let validate = definition[propertyName];\n        let valid = validate({ [propertyName]: object[propertyName] });\n        return valid ? [] : validate.errors\n          .map(({ dataPath, keyword, message, params, schemaPath }) =>\n            new ValidationError(dataPath, message, object, propertyName));\n      }\n\n      _schemaId(object) {\n        return (!object.schema.hasOwnProperty('id')) ?\n          object.constructor.name : object.schema.id;\n      }\n\n      parseSchema(object) {\n        let schema = object.schema;\n        if (schema === undefined || schema === null) {\n          throw new Error('object lacks schema');\n        }\n\n        let schemaId = this._schemaId(object);\n        if (this.cache.has(schemaId)) {\n          // schema has already been parsed\n          return;\n        }\n\n        if (!schema.hasOwnProperty('properties')) {\n          throw new Error('only object schemas are current supported');\n        }\n\n        let definition = {};\n        definition.validate = this.ajv.compile(schema);\n\n        // split schema into individual properties\n        let required = schema.required || [];\n        for (let property in schema.properties) {\n          let subSchema = { type: 'object', properties: {} };\n          subSchema.properties[property] = schema.properties[property];\n          if (required.indexOf(property) !== -1) subSchema.required = [ property ];\n          let validator = this.ajv.compile(subSchema);\n          definition[property] = validator;\n        }\n\n        this.cache.set(schemaId, definition);\n      }\n    }\n  </source-code>\n</code-listing>\n\nHere's a live [demo](https://gist.run/?id=4bec1022baac829e236e35892408ca67) to play around with.\n\n( Many thanks to core member [@jdanyow](https://github.com/jdanyow) for putting together the initial [gist.run](https://gist.run/) I based this off of. Have you taken a second today to thank him? You should! )\n\nThat the implementation was so straightforward immediately indicates to me that `aurelia-validation` has finally found its legs. I had been a (somewhat passive) participant in a number of design discussions during the development of `aurelia-validation`, and was very pleased to see all of my concerns had been addressed in this release.\n\nSpecifically, in previous iterations it would have been difficult to implement this plugin because it doesn't necessarily \"play by the rules\":\n\n* validators are all self-contained in `ajv`, so completely opting out of the validators provided by Aurelia is a requirement\n\n* \"rules\" here are just JSON objects, rather than annotations on properties, so this required a separation of concerns not previously possible with earlier versions of `aurelia-validation` (perhaps the biggest gripe/blocker/unicorn)\n\n* `ajv` has no concept of property-level validation, nor any plans to support such a feature, so the interface had to be flexible enough to allow me to implement that myself\n\nAdmittedly some of this was possible before but it was not obvious, and the implementations of `aurelia-validation` and `aurelia-validatejs` were closely coupled in a way that was difficult to reason about. No such trouble with this release! The new design is very intuitive and really comes down to implementing two functions. Rad.\n\nA few notes about the current implementation:\n\n* Rules are currently defined as a property called `schema` on the object being validated. This will likely be moved over to using the new `Rules` metadata introduced in this [commit](https://github.com/aurelia/validation/commit/01d85010e7f435ebc4065257808f835c7a2a6a0e)\n\n* `aurelia-validation`s default validator implementation uses a concept of `ValidationRules` to compile validators for your data. You'll note that for my initial implementation I chose to lazily compile validators at the moment of validation. There is definitely room for improvement here, and might actually be a use case for abstracting `ValidationRules` and providing them as a top-level export of the `aurelia-validation` plugin.\n\n* I mentioned before that `ajv` does not support property-level validation out of the box, rather the suggested approach is to use subschemas for individual properties. I've provided a naive implementation of programmatically splitting a JSON schema into subschemas for this demo, however it is far from complete and will likely fail in more complicated cases. There is a lot of work to be done here, and I would love feedback from the community to develop the feature.\n\nI hope this gives you a taste of how powerful the new `aurelia-validation` is. I'm eager to hear back from you all about how this plugin might be of use, and ideally how we might collaboratively improve it - so please leave your comments below or reach out on the project's gitter channels.\n\nAll in all I'm quite pleased with the state of the art today, the new version of `aurelia-validation` is a powerful tool for an already great framework.\n\n_Matt Broadstone is a Lead Software Architect for [hiveIO](https://hive-io.com/), a NYC-based cloud computing company specializing in software-defined virtual infrastructure. Interested in aurelia, virtualization or node.js? We're [hiring](mailto:info@hive-io.com)!_"}