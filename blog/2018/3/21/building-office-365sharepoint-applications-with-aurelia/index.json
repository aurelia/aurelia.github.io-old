{"name":"Building Office 365/SharePoint Applications with Aurelia","description":"This week, please welcome community member Magnus Danielson to share a little bit about Aurelia and Office 365. Take it away Magnus!","author":{"name":"Magnus Danielson","url":"magnus@dunite.se"},"links":{"static":"blog/2018/3/21/building-office-365sharepoint-applications-with-aurelia","html":"blog/2018/3/21/building-office-365sharepoint-applications-with-aurelia/index.html","fragment":"blog/2018/3/21/building-office-365sharepoint-applications-with-aurelia/index-fragment.html","self":"blog/2018/3/21/building-office-365sharepoint-applications-with-aurelia/index.json"},"content":"\r\nThis week, please welcome community member Magnus Danielson to share a little bit about Aurelia and Office 365. Take it away Magnus!\r\n\r\n## Why care about Microsoft Office 365 anyway?\r\n\r\nMicrosoft has been very successful in moving customers to their cloud offering: Microsoft Office 365. There are more than 100 million potential end users in the Microsoft cloud. All these users create, share, and collaborate on documents and information critical to their own success. They use Mac or PC on any web browser or any mobile device. The foundation is in place for building great business applications that help these customers to be even more productive, smarter and more agile. Microsoft provides ways to add functionality in many ways and an API to reach and interact with the user’s data. It is now up to you and your customers to build smart, snappy and sleek applications that live and run on top of Microsoft Office 365.\r\n\r\n## What are my options and how can it be done?\r\n\r\nSo now all you need is a way to build a great user experience and call back-end services. Since you are an expert on Aurelia, of course you know that it is the way forward.\r\n\r\nThere are several ways of adding functionality to SharePoint online, the collaboration offering in Office 365. For simplicity the four choices below are the ones you will care about.\r\n\r\n1.\tFull immersive add-in running on your own hosted web server\r\n2.\tJavaScript injected into the SharePoint page itself\r\n3.\tModern Client side webparts built with SPFx\r\n4.\tAdding UI commands\r\n\r\nChoices 1, 2 and 3 can be built with Aurelia. Adding UI commands, number 4, is only the means for opening your UI that is built via 1, 2 or 3. In this post I will focus on number 3, building modern client side webparts with SPFx and Aurelia.\r\n\r\n## SPFx and Aurelia\r\n\r\nThe SharePoint Framework (SPFx) is a page and web part model that provides full support for client-side SharePoint development, easy integration with SharePoint data, and support for open source tooling. This means that your code runs in the browser in the context of the user. It is easy to call the SharePoint API and it is easy to build a modern responsive experience.\r\n\r\nThe tooling you need on your local developer machine is Node, NPM and an editor of your choice. The code is written in TypeScript. SPFx is released to NPM and you use Yeoman to create your project. When you build your project, there is a gulp task that dynamically builds a WebPack configuration file that is then used by WebPack for building and bundling.\r\n\r\nFortunately, Microsoft encourages developers to extend the build process, so I have adapted the build process for Aurelia developers. As always, my work stands on the shoulders of earlier work such as the Aurelia WebPack plugin.\r\n\r\n## Getting Started\r\n\r\nIf you are eager just to try it out, download [the Aurelia Navigation Skeleton from my GitHub](https://github.com/magnusdanielson/spfx-aurelia) It is important to verify your version of Node and NPM. These version dependencies are related to SPFx and not to Aurelia itself:\r\n\r\n```Shell\r\nnpm --v\r\n3.10.8\r\n\r\nnode -v\r\nv6.11.5\r\n```\r\n\r\nWhen you have verified your versions, just install everything you need with:\r\n\r\n```Shell\r\nnpm install\r\n```\r\n\r\nYou can then admire the beauty of Aurelia Navigation Skeleton in the SharePoint Workbench. Notice that the Office 365 top menu is hidden with the Bootstrap navigation menu. This is something you would never do in any real application but I wanted to stick as close as possible to the Aurelia Navigation Skeleton example, and therefor I did not touch the CSS in any way.\r\n\r\n## The Details of Aurelia and SPFx\r\n\r\nWhen you create your client-side webpart with SPFx, you get a complete project structure with all the things you need to build and run the app. To use Aurelia in the webpart there are a few things you need to do. First, run the Yeoman template with all default choices but most importantly 'No JavaScript framework'.\r\n\r\nNext, add dependencies to the following packages:\r\n\r\n```Shell\r\nnpm install aurelia-bootstrapper@2.1.1 --save\r\nnpm install aurelia-fetch-client@1.1.2 --save\r\nnpm install bluebird@3.5.0 --save\r\n```\r\n\r\nAurelia fetch is needed if you want to talk to any back-end server, and since you always want that, you should include it. Bluebird is there to polyfill Promise functionality for IE and Edge.\r\n\r\nThen, add developer dependencies to the following packages:\r\n\r\n```Shell\r\nnpm install aurelia-webpack-plugin@2.0.0-rc.5 --save-dev\r\nnpm install expose-loader --save-dev\r\n```\r\n\r\nThe Aurelia-WebPack plugin is there to make sure the dynamic nature of Aurelia works with WebPack's loaders. There are some configuration options that you can dive into about the plugin, but we won’t go into details about that now. We will save that for a later post. After this, add the following function to the gulp.js file that is already created in your project, just before the call to `build.initialize(gulp);`:\r\n\r\n```JavaScript\r\nconst { AureliaPlugin } = require(\"aurelia-webpack-plugin\");\r\n\r\nbuild.configureWebpack.mergeConfig({\r\n  additionalConfiguration: generatedConfiguration => {\r\n    //generatedConfiguration.resolve.modules.push(\"src\");\r\n    generatedConfiguration.module.rules[0].issuer = {\r\n      // only when the issuer is a .js/.ts file, so the loaders are not applied inside templates\r\n      test: /\\.[tj]s$/i,\r\n    };\r\n\r\n    var rule1 = { test: /\\.css$/i,issuer: [{ test: /\\.html$/i }], use: \"css-loader\"} ;\r\n    generatedConfiguration.module.rules.push(rule1)\r\n\r\n    var rule2 = { test: /\\.ts$/i, use: \"ts-loader\" };\r\n    generatedConfiguration.module.rules.push(rule2);\r\n\r\n    var rule3 = { test: /[\\/\\\\]node_modules[\\/\\\\]bluebird[\\/\\\\].+\\.js$/, loader: 'expose-loader?Promise' };\r\n    generatedConfiguration.module.rules.push(rule3);\r\n\r\n    generatedConfiguration.plugins.push(new AureliaPlugin({\r\n      aureliaApp: undefined\r\n    }));\r\n\r\n    return generatedConfiguration;\r\n  }\r\n});\r\n```\r\n\r\nThe MergeConfig function is called from the WebPack gulp task when you run for example gulp serve. It is our chance to inject our custom configuration before WebPack starts.\r\n\r\nAdd the setting below to the tsconfig.json file in the `compilerOptions` section. (I don’t really like this addition but is solves some problems with the TypeScript lint gulp task.)\r\n\r\n```javascript\r\n\"skipLibCheck\": true\r\n```\r\n\r\nAdd the following imports to the HelloWorldWebPart.ts\r\n\r\n```JavaScript\r\nimport { Aurelia } from 'aurelia-framework';\r\nimport { PLATFORM } from \"aurelia-pal\";\r\nimport * as Bluebird from 'bluebird';\r\n```\r\n\r\nNext add a constructor to the same file to configure Bluebird as early as possible.\r\n\r\n```JavaScript\r\nconstructor() {\r\n  super();\r\n  Bluebird.config({ warnings: { wForgottenReturn: false } });\r\n}\r\n```\r\n\r\nReplace the render() function with below:\r\n\r\n```JavaScript\r\nrender() {\r\n  this.domElement.innerHTML = `<div id=\"${this.instanceId}\" class=\"${this.instanceId}\"  >Loading...</div>`;\r\n\r\n  require(['aurelia-bootstrapper'], au => {\r\n    au.bootstrap(aurelia => {\r\n        aurelia.use\r\n          .standardConfiguration()\r\n          .developmentLogging();\r\n\r\n        var el = document.getElementById(this.instanceId);\r\n        aurelia.start().then(() => aurelia.setRoot(PLATFORM.moduleName('webparts/helloWorld/myapp'), el));\r\n      }\r\n    );\r\n  });\r\n}\r\n```\r\n\r\nNotice that we just add one div tag and no Aurelia-app attribute. We do that so we can control how Aurelia starts the app. If we would just inject an Aurelia-app attribute it would work but we would get in all sorts of problems when the next webpart of the same type is added. We now control the start by requiring Aurelia-bootstrapper and then manually start the app. InstanceId is unique for every webpart added to the page, so we are sure there is no conflict between them.\r\n\r\nNow add a simple myapp.ts file and a myapp.html file in the helloWorld folder.\r\n\r\n```JavaScript\r\nexport class myapp {\r\n  message = \"World\";\r\n}\r\n```\r\n\r\n```HTML\r\n<template>\r\n  Hello ${message}\r\n</template>\r\n```\r\n\r\n## Summary\r\n\r\nAurelia works great with modern SharePoint. My plan is to write more posts about both modern and old school SharePoint with Aurelia. Checkout [http://www.dunite.se] for more posts or my twitter account @magnusdanielson."}