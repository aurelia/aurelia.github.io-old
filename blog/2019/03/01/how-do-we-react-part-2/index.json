{"name":"How do we React? - Part 2","description":"This is part 2 of 3 in a series titled \"How do we React?\" in which I discuss how Aurelia handles common React scenarios. In this post, we'll cover Render Props.","author":{"name":"Rob Eisenberg"},"links":{"static":"blog/2019/03/01/how-do-we-react-part-2","html":"blog/2019/03/01/how-do-we-react-part-2/index.html","fragment":"blog/2019/03/01/how-do-we-react-part-2/index-fragment.html","self":"blog/2019/03/01/how-do-we-react-part-2/index.json"},"content":"\nThis is part 2 of 3 in a series titled \"How do we React?\" in which I discuss how Aurelia handles common React scenarios.\n\nThe other week [Sebastian MarkbÃ¥ge](https://twitter.com/sebmarkbage) posted [the following tweet](https://twitter.com/sebmarkbage/status/1098310123796062209):\n\n> You may have noticed that most other frameworks don't have HoCs, render props or anything like React.Children. These account for a lot the differences between React and other frameworks. How would you solve these use cases if you had to switch to [other framework]?\n\n**In this post, we'll cover Render Props.** For a discussion of how Aurelia handles typical HoC scenarios, [please see part 1](blog/2019/02/21/how-do-we-react-part-1).\n\n## Render Props\n\nThe React site [defines render prop](https://reactjs.org/docs/render-props.html) as follows:\n\n> The term \"render prop\" refers to a technique for sharing code between React components using a prop whose value is a function.\n\nIn React practice, the consumer of a component passes a function along to the component which will later be called by that component to customize rendering inside that component. Ultimately, this is a functional technique similar to the OOP [template method pattern](https://www.oodesign.com/template-method-pattern.html) that is used to allow end users to customize how a component renders.\n\n**So, how does Aurelia support templatization of component rendering?**\n\n## Slots\n\nIn Aurelia, a component is typically made up of two parts: a plain JS class that forms the view-model of the component and a web standards-based HTML template that forms its view. Because Aurelia adopts and champions the use of web standards wherever possible, its templates support Shadow DOM slots.\n\nIn case you aren't familiar with or haven't worked with slot-based composition before, I'll provide a brief explanation. Let's say you want to create a \"dialog\" component. It's a simple component that displays a modal dialog UI, wrapping arbitrary content, and providing an optional header. Our view model might look something like this:\n\n```JavaScript modal-dialog.js\nimport { bindable } from 'aurelia-framework';\n\nexport class ModalDialog {\n  @bindable title;\n}\n```\n\nThis view model would be paired with the following view:\n\n```HTML modal-dialog.html\n<template>\n  <div>\n    <div if.bind=\"title\">${title}</div>\n    <div>\n      <slot></slot>    \n    </div>\n  </div>\n</template>\n```\n\nAnd you would use it like this:\n\n```HTML app.html\n<modal-dialog title=\"Aurelia\">\n  <span>Any HTML you want goes here, including custom components.</span>\n</modal-dialog>\n```\n\nNow, when I use `modal-dialog`, the content of the element, in this case the `span`, will be rendered at the location of the `slot`. The two DOM trees are affectively composed together into the following visual tree:\n\n```HTML The Composed Light and Shadow DOMs\n<modal-dialog>\n  <div>\n    <div>Aurelia</div>\n    <div>\n      <span>Any HTML you want goes here, including custom components.</span>  \n    </div>\n  </div>\n</modal-dialog>\n```\n\nIf you're familiar with React, then you know that one way this type of thing can be accomplished is through a Render prop. In React's case, the `modal-dialog` component would expect a function-type prop to be passed which it would then invoke during its render method, to provide the custom content. With Aurelia, it's all declarative HTML. Simply use a `slot` element to mark the location where the consumer's content should be rendered, and the consumer just uses your element like a normal HTML element. Any content placed inside its tag automatically gets \"projected\" to the slot's location.\n\n> Info\n> In React, an alternative approach to handling this scenario is through `props.children`. We'll be covering that in part 3 of this series.\n\nShadow DOM slots (and thus Aurelia) can do much more than this though. What if we wanted the end user to be able to provide arbitrary HTML for the `title` as well, but still allow for a simple text property to be set? We just change the template to use a named slot with fallback content.\n\n```HTML modal-dialog.html\n<template>\n  <div>\n    <slot>\n      <div if.bind=\"title\">${title}</div>\n    </slot>\n    <div>\n      <slot></slot>    \n    </div>\n  </div>\n</template>\n```\n\nWe could then use it like this:\n\n```HTML app.html\n<modal-dialog>\n  <span slot=\"title\">Any HTML for the title goes here.</span>\n  Any HTML for the content goes here, including custom components.\n</modal-dialog>\n```\n\nWith the above, we can render custom HTML content into the \"title\" slot. However, if we don't provide \"title\" slot HTML, the Aurelia template will fallback to rendering the default title `div` which has its content bound to the `title` property.\n\nAll of this is standards-based, accomplishable through declarative HTML, and merely scratches the surface of what slots can do. By combining default and named slots, fallback content, and even the ability to project slots through to other slots, the possibilities are virtually limitless.\n\n### Influences\n\nIt's not quite correct to say that Aurelia is influenced by Shadow DOM. Rather, Aurelia has adopted the Shadow DOM standard as a core feature of its component composition model. We've worked hard to provide slots in their pure form, not altering their behavior from the standard as a couple other frameworks do. This means that if you learn how slots work in Aurelia, you're also correctly learning web standards, investing in your long-term technical knowledge and growth, which is great for your career, even if you aren't working with Aurelia yet in your day job.\n\nIt's worth mentioning Xaml-based UI frameworks, such as Windows Presentation Foundation, Silverlight, and Microsoft's UWP platform, have an earlier manifestation of this same concept. The Xaml [ContentPresenter](https://docs.microsoft.com/en-us/dotnet/api/system.windows.controls.contentpresenter) functions almost like a default slot, designating where in the visual tree any element content should be rendered. It even has the notion of a `ContentSource`, which provides a mechanism similar to named slots. Similarly, the [ItemsPresenter](https://docs.microsoft.com/en-us/dotnet/api/system.windows.controls.itemspresenter) handles rendering multiple content elements, including the ability to determine their layout and even wrap them with custom wrapper templates. The Web's Shadow DOM spec doesn't have something quite like this, but Aurelia does, which leads me to *template parts*...\n\n## Template Parts\n\nShadow DOM slot projection is powerful, but it doesn't handle all the scenarios an app might require. For example, imagine that instead of projecting content, you want to pass a template through to another element, so that this other element can use your template to render conditionally or repeatedly. This is something that React uses render props for, but Aurelia accomplishes this with declarative template parts.\n\nAs an example, let's imagine we're building a custom drop-down component. This component will display a list of items, based on data, and then track which item is selected by the user. To make things reusable, we want the consumer of our drop-down to be able to provide a template that can be used to render each item in the list. Here's an abbreviated version of what our drop-down component's view-model might look like:\n\n```JavaScript drop-down.js\nexport class DropDown {\n  @bindable items;\n  @bindable selectedItem;\n  listIsOpen = false;\n\n  // behavior elided\n}\n```\n\nWe pair that with this HTML view:\n\n```HTML drop-down.html\n<template>\n  <div>\n    ..elided...\n\n    <div if.bind=\"listIsOpen\">\n      <ul>\n        <li repeat.for=\"item of items\">\n          <div replaceable part=\"list-item-template\">\n            ${item.toString()}\n          </div>\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n```\n\nNow, if we wanted to use this to render a drop down list of people, we would do it like this:\n\n```HTML app.html\n<drop-down items.bind=\"people\"\n           selected-item.bind=\"selectedPerson\">\n  <template replace-part=\"list-item-template\">\n    <span>${item.lastName}, ${item.firstName}</span>\n  </template>\n</drop-down>\n```\n\nNormally, the drop-down list would render a `div` for each person, with that `div`'s content set to whatever `toString()` resulted in for each person. However, because we marked the `div` with the attribute `replaceable` and then gave it a `part` name, the consumer of the drop-down can easily provide their own replacement for that part of the component's view by specifying a template and telling it to replace the part with the same name. Nice!\n\nYou can have any number of template parts in an Aurelia component, as long as you give each a unique name. Furthermore, each template part gets access to the binding scope of the part it's replacing (e.g. the current item during a list render) along with the lexical scope in which the replacement part is declared. This allows for providing list item templates that have interaction behaviors that are also supplied by the consumer. All that's required is a couple of HTML attributes.\n\n### Influences\n\nThe chief inspiration for this again comes from Xaml. It's partially inspired by what the above-mentioned `ItemsPresenter` can do, but also by a feature of the same name, template parts, in Xaml itself, which was designed to enable designers to completely re-skin components with a new view, without having to re-write all the behavior.\n\nCollectively, Shadow DOM slots and Aurelia template parts handle nearly all the scenarios that Render props are typically used for. But, Aurelia has a few more related items that are worth mentioning.\n\n## The Call Binding\n\nAs it turns out, you can always directly pass a function into an Aurelia component as well, to do just about anything you need. We do this with the `call` binding. One interesting use case for this can be seen in Aurelia's [virtual repeater](https://aurelia.io/docs/plugins/virtualization#infinite-scroll). This is an official Aurelia plugin that enables efficient rendering of hundreds of thousands of data elements, by utilizing UI virtualization techniques. This plugin can also handle infinite scrolling scenarios. All you have to do is provide it with a function to \"call\" whenever it needs to load your next set of data elements. Here's how it's used:\n\n```HTML app.html\n <template>\n  <div virtual-repeat.for=\"person of people\" infinite-scroll-next.call=\"getMore($scrollContext)\">\n    ${$index}. ${person.lastName}, ${person.firstName}\n  </div>\n</template>\n```\n\nIn this case, we display the index of each person, along with their last and first names. We may have thousands of elements in our database, but we probably only want to load the first few dozen to populate the `people` list. However, as the user scrolls, we want to load successive pages. The `virtual-repeat` handles all the complexities and the `call` binding enables the consumer to pass a function reference to the `virtual-repeat` which it can then *call* whenever it needs the next set of items. Notice also that the `virtual-repeat` can define custom variables, such as `$scrollContext` which it can pass to your function, to give you the proper contextual information you need to load the right page of data.\n\n## The Compose Element\n\nI wanted to share one more related feature of Aurelia: the `compose` element. This feature could have been discussed in our post on [how Aurelia handles React HoC scenarios](blog/2019/02/21/how-do-we-react-part-1), but I wanted to wait until now, so our readers could see how `compose` can enable both HoC and Render Prop scenarios.\n\nSo, what is this `compose` thing? Well, it's a special component that Aurelia ships with out-of-the-box, that enables dynamic rendering of other components, based on data. Over the years, I've sometimes referred to this as \"polymorphic UI composition\".\n\nImagine that you've got a heterogeneous list of data items that you want to render, but each one of them needs to be rendered with a different component. Perhaps which component renders each item is dependent on the type of the data. For many programmers, their first inclination is to reach for an if/else or switch/case, but that leads to a system that isn't naturally open for extension. What this means is that any time you add a new type to your data model, you've got to go modify the existing set of if/else or switch/case statements. Generally speaking, you should build systems that enable you to avoid ever modifying working code. Making changes to things that work is a fantastic way to introduce bugs and regressions.\n\nWith compose, you can simply loop over the heterogeneous list, \"composing\" each item in the list, which allows it to polymorphically render itself, based on type and convention. Let's say we have an app with a list of shapes like this:\n\n```JavaScript app.js\nexport class App {\n  shapes = [\n    {\n      type: 'circle',\n      radius: '10px'\n    },\n    {\n      type: 'rectangle',\n      width: '10px',\n      height: '5px'\n    }\n  ];\n}\n```\n\nWe could render it polymorphically by using `compose` in its view, like this:\n\n```HTML app.html\n<template>\n  <ul>\n    <li repeat.for=\"shape of shapes\">\n      <compose view-model=\"shapes/${shape.type}\" model.bind=\"shape\"></compose>\n    </li>\n  </ul>\n</template>\n```\n\nNow, if we've got a shape with type \"circle\" we'll render it with the \"circle\" component in the \"shapes\" folder. If we've got a shape with a type of \"rectangle\", then that gets rendered with a \"rectangle\" component. Each component also gets passed the shape data model instance. To extend the system, we never need to modify this code; we only need to add new components for new types. Hopefully you can see this as a nice example of [the open-closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle). It's particularly handy for building dashboard apps, where the user has a configurable set of \"widgets\" which are loaded from a database, but I've found this to be an elegant solution for many seeming complex challenges.\n\n### Influences\n\nAurelia's `compose` element is based on a feature from an earlier framework of mine called Caliburn, which I first started working on in 2005. Caliburn was a WPF framework that had a special Xaml attached property called `View.Model` which you could bind to any object. Based on the object's type, it would polymorphically render the data using the correct view or view/view-model pair. It was at this time that I started to leverage the MVVM pattern extensively by composing view models upon view models. The net effect of this was that you could write your entire application in a \"headless\" way, with no dependency on the front-end framework or UI toolkit. You would end up with a plain set of classes/objects that represented everything the app could do, all composed together. I've sometimes referred to this as \"hierarchical view models\" or \"composite presentation model\". A side benefit of this approach is that it's amazingly easy to test and you wind up with a full automation API and plugin model for your app as a side-effect. The architecture also scales linearly to any application and team size. The `View.Model` property of Caliburn and the `compose` element of Aurelia are the primary framework features that have enabled this architectural style over the years. Discovering these patterns in the early days of WPF completely changed the way I think about building front-ends.\n\n## Wrapping Up\n\nShadow DOM slots, template parts, the `call` binding, and the `compose` element are all tools that enable Aurelia developers to handle the same scenarios as React render props (and HoCs too). I've consistently used these and similar techniques for over a decade (along with thousands of other engineers) to build countless front-ends, both simple and extremely complex, and they've held up time and time again.\n\nI hope you've enjoyed seeing how Aurelia provides its own approaches to the scenarios typically handled by React render props. Stay tuned for Part 3 of this series, when we discuss Aurelia's approach to React.Children. If you look back over this post, you might already have some ideas about how that might be done :)\n\nSee ya next time!"}