{"name":"How do we React?","description":"This is part 1 of 3 in a series titled \"How do we React?\" in which I discuss how Aurelia handles common React scenarios. In this post, we'll cover HoCs.","author":{"name":"Rob Eisenberg"},"links":{"static":"blog/2019/2/22/how-do-we-react-part-1","html":"blog/2019/2/22/how-do-we-react-part-1/index.html","fragment":"blog/2019/2/22/how-do-we-react-part-1/index-fragment.html","self":"blog/2019/2/22/how-do-we-react-part-1/index.json"},"content":"\nThis is part 1 of 3 in a series titled \"How do we React?\" in which I discuss how Aurelia handles common React scenarios.\n\nThe other day [Sebastian Markbåge](https://twitter.com/sebmarkbage) posted [the following tweet](https://twitter.com/sebmarkbage/status/1098310123796062209):\n\n> You may have noticed that most other frameworks don't have HoCs, render props or anything like React.Children. These account for a lot the differences between React and other frameworks. How would you solve these use cases if you had to switch to [other framework]?\n\nGreat question Sebastian! We're glad you asked. In this blog, we'd like to take some time to begin walking through each of these React capabilities, discussing how Aurelia addresses the same set of scenarios. **In this post, we'll cover HoCs.** For a discussion of how Aurelia handles render props, [please see part 2](blog/2019/03/01/how-do-we-react-part-2) or for information on how we handle React.Children, [see part 3](blog/2019/03/12/how-do-we-react-part-3).\n\n### Sidebar\n\nBefore Sebastian posed the question, he made the following statement: \"You may have noticed that most other frameworks don't have HoCs, render props or anything like React.Children.\" Some have interpreted this statement negatively and have become offended. I'm going to take Sebastian [at face value](https://twitter.com/sebmarkbage/status/1098406928986759168) and assume he means no harm and has an honest curiosity.\n\nThat said, I do want to point out that I think this statement isn't quite correct. Most of the frameworks I've worked with, not just for web but also in the native desktop and gaming spaces, have built-in capabilities that address these scenarios. I'm not going to fully defend this assertion here, as it would take considerable space. However, as I walk through Aurelia's approach, I'll point out other technology that has influenced Aurelia, hoping to give our readers some other fun avenues to explore, should they take interest in the broader space of UI frameworks and architectures.\n\n## HoCs\n\nThe React site [defines HoC](https://reactjs.org/docs/higher-order-components.html) as follows:\n\n> A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.\n\nIn React practice, a higher-order component involves using a function that creates a new component by wrapping itself around an existing component, applying new behavior as part of the wrapping process. Ultimately, it's a functional technique targeted at enabling reuse and composition.\n\n**So, how does Aurelia enable reuse and composition?**\n\n## Custom Attributes\n\nIn Aurelia, we have the ability to create custom HTML attributes which extend an HTML node with new behavior. For example, have a look at this HTML:\n\n```HTML app.html\n<template>\n  <div interact-draggable.bind=\"actionOptions\"></div>\n</template>\n```\n\nIn this example, `interact-draggable` is a custom attribute that can be attached to any HTML node, including an Aurelia custom element. When added, it enables advanced drag/drop capabilities, utilizing the [interact](http://interactjs.io) library internally.\n\nCreating a custom attribute is as simple as authoring a vanilla JS class, following our naming convention, and implementing appropriate component lifecycle hook methods:\n\n```JavaScript interact-draggable.js\nexport class InteractDraggableCustomAttribute {\n  static inject = [Element];\n\n  constructor(element) {\n    this.element = element;\n  }\n\n  attached() {\n    // Use InteractJS on target element here.\n  }\n}\n```\n\nHere's another example of how we can use custom attributes to take advantage of portals:\n\n```HTML combobox.html\n<template>\n  <div>\n    <input value.bind=\"filterText\" />\n  <div>\n  <ul portal>\n    <li repeat.for=\"item of items | filter: filterText\">${item.name}</li>\n  </ul>\n</template>\n```\n\nIn this case, simply applying the `portal` attribute to the `ul` causes it to be rendered in the portal space, rather than in the current DOM flow.\n\nAurelia Custom Attributes provide near limitless ways to encapsulate functionality for reuse across your project. Since a custom attribute is just a plain class, it's easy to share with other Aurelia developers too. In fact, you can find [the interact attribute](https://github.com/eriklieben/aurelia-interactjs) and [the portal attribute](https://github.com/bigopon/aurelia-portal-attribute) on GitHub.\n\n### Influences\n\nThis idea is not new and does not originate with Aurelia. In fact, it goes back at least 13 years. That's the first time I used it myself when building the behaviors implementation for my first front-end framework, [Caliburn](https://github.com/CaliburnFx/Caliburn), which was designed for WPF apps. At that time, I used this idea to implement some messaging ideas I liked from Smalltalk, which I re-imagined as attachable binding behaviors in Xaml. Around the same time I was working on that, similar patterns of use began in other areas of the Xaml community and round about 2009 Microsoft released an official implementation known as Expression Blend Behaviors. If you're interested, [have a read through this early blog post](https://www.wpftutorial.net/Behaviors.html). I think you'll see some similarities.\n\nThis idea is also present in the popular [Unity3D](https://unity3d.com/) game engine. In fact, it's central to the extensibility model of the Unity scene graph and the core enabler of its amazing ecosystem and marketplace. Unity emerged around 2005 and you can read more about its MonoBehavior [here](https://unity3d.com/learn/tutorials/modules/beginner/scripting/scripts-as-behaviour-components).\n\n## Dependency Injection\n\nIt should be clear by now that Aurelia is a framework that favors an object oriented approach. As such, Aurelia developers are free to leverage all the patterns, practices and tools for OOP composition that have evolved over the last several decades. A particular tool that enables powerful, composition at any level of granularity, is a dependency injection framework. In Aurelia's case, dependency injection is baked deep into its core. You've already seen it above, where we injected the target HTML `Element` into a custom attribute, but it can be used for so much more.\n\n### Sidebar: What is dependency injection and why should I use it?\n\nAs a system increases in complexity, it becomes more and more important to break complex code down into groups of smaller, collaborating functions or objects. However, once we've broken down a problem/solution into smaller pieces, we have then introduced a new problem: how do we put the pieces together?\n\nOne approach is to have the controlling function or object directly instantiate all its dependencies. This is tedious, but also introduces the bigger problem of tight coupling and muddies the primary responsibility of the controller by forcing upon it a secondary concern of locating and creating all dependencies. To address these issues, the practice of Inversion of Control (IoC) can be employed. Simply put, the responsibility for locating and/or instantiating collaborators is removed from the controlling function/object and delegated to a 3rd party (the control is inverted). Typically, this means that all dependencies become parameters of the function or object constructor, making every function/object implemented this way not only decoupled but open for extension through providing different implementations of the dependencies. The process of providing these dependencies to the controller is known as Dependency Injection (DI).\n\nOnce again, we’re back at our original problem: how do we put all these pieces together? With the control merely inverted and open for injection, we are now stuck having to manually instantiate or locate all dependencies and supply them before calling the function or creating the object, but now we must do this at every function call-site or every place that the object is instanced. It seems as if this may be a bigger maintenance problem than we started with!\n\nFortunately, there is a battle-tested solution to this problem. We can use a Dependency Injection Container. With a DI container, a class can declare its dependencies, and allow the container to locate the dependencies and provide them to the class. Because the container manages locating and providing dependencies, it can also manage the lifetime of objects, enabling singleton, transient, and object pooling patterns without consumers needing to be aware of these details.\n\n### DI in Aurelia\n\nSo, how does this play out in Aurelia? Let's say that you have a component that needs to use an `HttpClient` to request data, and then in response to that, it wants to ask the `Router` to navigate to a particular URL. Also, the original request is parameterized based on the user from the current `Session`. Here's what that would look like:\n\n```JavaScript\nexport class MyComponent {\n  static inject = [Session, HttpClient, Router];\n\n  constructor(session, http, router) {\n    this.session = session;\n    this.http = http;\n    this.router = router;\n  }\n\n  async activate() {\n    const result = await this.http.get(`api/user/${this.session.user.id}`);\n\n    if (result.needsPowerfulComposition) {\n      this.router.navigateToRoute('aurelia');\n    }\n  }\n}\n```\n\nHere we have a vanilla JS component (HTML view not shown) that has declared its dependency on `Session`, `HttpClient` and `Router`. When `MyComponent` is instantiated by the framework, Aurelia will ensure that those dependencies are supplied to the constructor and are ready for use within that component immediately.\n\n> Info\n> This example also shows how Aurelia's async navigation lifecycle methods make it really easy to fetch data and optionally pause rendering until async data is ready. In our next major release of Aurelia, we're planning to extend this capability to standard component lifecycle methods as well.\n\n### Influences\n\nDependency injection frameworks have been around a long time. It's even been used in UI frameworks for quite some time. The original version of Caliburn that I started work on in 2005/2006 leveraged DI internally to enable C# view-models to be composed, similar to above. A year or two later, Microsoft released [Prism](https://github.com/PrismLibrary/Prism), which also enabled the use of DI in WPF applications, along with a number of other UI composition patterns.\n\n> Info\n> If you really want to have some fun, you can try and dig up info on Microsoft's Apollo WPF framework (killed before release) and going back even further, check out Microsoft's Composite Application Block (CAB). In my opinion, both are pretty awful, but you can still see some similar scenarios and earlier design evolution, though much less elegant.\n\n## Decorators\n\nDecorators aren't something specific to Aurelia at all. It's a very old idea implemented in the syntax of some languages, like Python, and implemented as a pattern in other languages, like C++, Java, and C#. Fortunately for web developers, decorators are coming to JavaScript as a language feature. In the JavaScript incarnation, the decorator construct enables a form of declarative meta-programming for classes. Through a decorator, you can dynamically inherit the decorated class from a generated base class, add methods and properties to the target class, define getters/setters, and do just about anything you can think of. Aurelia leverages decorators to mix in metadata and functionality to a class. For example:\n\n```JavaScript my-component.js\n@useShadowDOM\nexport class MyComponent {\n\n}\n```\n\nSimply adding this decorator \"mixes in\" the native Shadow DOM behavior to `MyComponent`.\n\nAurelia provides a number of decorators like this, but due to our framework's core design, Aurelia developers can use any vanilla JS decorator with their components to mix in any type of functionality needed. One custom example is the way [the Aurelia store plugin](https://aurelia.io/docs/plugins/store) uses decorators to help with state management:\n\n```JavaScript app.js\nimport { connectTo } from 'aurelia-store';\n  \n@connectTo()\nexport class App {\n\n}\n```\n\nThis decorator connects the `App` component to the application's state instance, and handles all subscription to state changes as well as disposal of the listener at the correct time within Aurelia's component lifecycle. Hopefully those of you who have used [Redux](https://redux.js.org/) can see how this common React HoC scenario is handled in our case.\n\n## Wrapping Up\n\nCustom attributes, dependency injection, and decorators are just a few of the ways that Aurelia enables the same reuse and composition scenarios that a React HoC does. We feel that these techniques enable a nice combination of control with the proper granularity for re-mixing behavior, making complex scenarios simple and maintainable. Of course, if you really like HoCs, [you can create Aurelia HoCs too](https://www.sitepoint.com/state-aurelia-higher-order-components/). We're cool with that.\n\nI hope you've enjoyed seeing how Aurelia provides its own approaches to the scenarios typically handled by a React HoC. If you did, [check out Part 2 of this series](blog/2019/03/01/how-do-we-react-part-2), where we discuss Aurelia's approach to React render props. I think you're really going to enjoy it."}