{"name":"Case Study: Codeline and Aurelia","description":"Today we're please to introduce one of our Aurelia community members, Giray Temel, to share with you about Codeline's choice of and experience with Aurelia. Take it away Giray!","author":{"name":"Giray Temel"},"links":{"static":"blog/2019/2/10/case-study-codeline-aurelia","html":"blog/2019/2/10/case-study-codeline-aurelia/index.html","fragment":"blog/2019/2/10/case-study-codeline-aurelia/index-fragment.html","self":"blog/2019/2/10/case-study-codeline-aurelia/index.json"},"content":"\r\nToday we're please to introduce one of our Aurelia community members, Giray Temel, to share with you about Codeline's choice of and experience with Aurelia. Take it away Giray!\r\n\r\n## What is Codeline?\r\n\r\n[Codeline](https://codeline.io/) is an on demand software development platform. It offers an alternative to those who seek development services. Instead of turning to freelancing sites, posting jobs, and going through applications, you can bring your project to Codeline and we'll get experienced developers started on your tasks in no time.\r\n\r\nCodeline is an enterprise grade software product that contains real-time project management, timers and budgeting tools, finance, invoicing and payroll modules, an integrated payment system, a hiring pipeline, and more. We have a PHP / Laravel backend and a Socket.io setup for real-time functionality. **Our entire front-end is written in Aurelia.**\r\n\r\n<video width=\"100%\" height=\"100%\" controls>\r\n  <source src=\"../styles/images/blog/case-study-codeline-aurelia/CodelineVideo.mp4\" type=\"video/mp4\">\r\n</video>\r\n\r\n## Choosing Aurelia\r\n\r\nTo build Codeline, we needed to choose a modular, modern client-side framework that lends itself to robust single-page application development. Codeline is a data intensive, real-time software application. Therefore responsiveness, managing data flow, and handling complex routing were key concerns for us.\r\n\r\nBeing already familiar with Aurelia from a previous client project, we knew the framework's strengths, extensibility, and ease with which it can be customized.\r\n\r\nWe initially went for a Typescript + SystemJS setup. After the framework matured and the Aurelia CLI was released, we switched to that. Our build pipeline is now very simple and highly functional.\r\n\r\n## Less Constraints, More Customization\r\n\r\nMost frameworks require you to write code in a certain format. Vue has `.vue` files, React has `JSX.` On the other hand, in the Aurelia framework the `ViewController` is just a simple class. You don't need to extend a parent component class. There are no contrived `data()` or `methods()` methods. Your logic and your view live in two different files for each module. If there's no particular logic, you can even leave out the ViewController and just write the template.\r\n\r\nIn our case, this flexibility allowed for a comprehensible architecture, enabled better separation of concerns, and resulted in a cleaner codebase.\r\n\r\n## Models and Role Based Authorization\r\n\r\nEvery client app needs to talk to the server and Codeline is no exception. These exchanges must be authenticated and authorized based on the active user.\r\n\r\nIn our case, the business rules around what actions can be taken on which models are very complex. Clients can create new tasks, but they can't run timers on them. A developer cannot delete a task, only a project manager is able to do that.\r\n\r\n![Codeline Project View](../styles/images/blog/case-study-codeline-aurelia/projectview.png)\r\n\r\nWhen you consider the size of Codeline and the dozens of models we have, it's obvious that we needed a better solution than *if else*'ing all over the codebase. Plus, we had no intention of maintaining two copies of the same logic both on the server and the client-side.\r\n\r\nOur client-side strategy for authentication and authorization with Aurelia framework consists of these components:\r\n\r\n### 1. Revive HTTP responses as Models\r\n\r\nA model is nothing but a simple class. We simply take the response from the backend and instantiate the relevant Model class with this data.\r\n\r\nOne obvious advantage of this is being able to enrich the plain data with additional methods and getters. For instance, we have a `Notification` model and notifications come in levels. 1 is an info, 2 is a warning and 3 is an alert. In the UI, we display corresponding icons for each level. So we added a simple transformer to our Notification model that returns the CSS class of the icon dynamically.\r\n\r\n```TypeScript\r\n@transient()\r\nexport class Notification extends Model {\r\n  ...\r\n\r\n  level: number;\r\n\r\n  private levelIcons: any = {\r\n    1: \"info-circle\",\r\n    2: \"warning\",\r\n    3: \"alert-circle\",\r\n  };\r\n\r\n  get levelIcon() {\r\n    return this.levelIcons[this.level];\r\n  }\r\n  \r\n  ...\r\n}\r\n```\r\n\r\nThis way, we can simply do this in any of our views:\r\n\r\n```HTML\r\n<i class=\"${notification.levelIcon}\"></i> ${notification.text}\r\n```\r\n\r\n### 2. Can Method on the Base Model\r\n\r\nThe more interesting upside is that our base model (the parent class for all models) presents a `can(action: string): boolean` method. Using this, we can check if an action is authorized on the given model anywhere in the codebase. To pull this off, we include an `actions` array in the data returned by the server. It looks something like this: `['start', 'edit', 'delete']` Then the `can(action)` method simply checks if this array contains the given string.\r\n\r\nIn our views, it looks something like this:\r\n\r\n```HTML\r\n<timer-start-button if.bind=\"timer.can('start')\"></timer-start-button>\r\n```\r\n\r\n### 3. User Model and Role Checks\r\n\r\nThe authenticated user's data is also revived as a User model and this instance exposes a `hasRole` method, much similar to the `can` method we mentioned earlier. We also added shortcut methods that just call `hasRole` for us with specific combinations, such as `isEmployee` and `isClient`.\r\n\r\n## Customizing Aurelia's Router\r\n\r\nCodeline has unique needs when it comes to routing. The layout of the app is quite versatile and dynamic. Thankfully, Aurelia's powerful router went above and beyond our expectations when it came to customization.\r\n\r\nFirst, let's take a look at Codeline's full layout:\r\n\r\n```Shell\r\n_______________ Top Bar ________________\r\n_______________ Nav Bar ________________\r\n\r\n| Left Menu   | Main View | Right Pane |\r\n________________________________________\r\n```\r\n\r\nHere's where it gets tricky:\r\n\r\n* We want the left menu to be displayed only for certain routes. We couldn't include the left menu with each view as this would cause unnecessary loads or jumps in scroll position. It had to stay in place and must be toggled based on the active route.\r\n* The right pane, which we call the \"viewbar\", is also only displayed with certain routes. It's basically a little view that slides in from the right and is typically used for quickly creating or updating records. We already had a jQuery plugin for this but we needed to keep it open when the page is refreshed, or hide it dynamically when the user navigates away to another page.\r\n* Routes need to be authorized. We don't want our clients to access the administrative routes.\r\n\r\nWith all of these custom requirements in mind, we devised the following interface:\r\n\r\n```TypeScript\r\nexport interface RouteConfig {\r\n  name: string;\r\n  title?: string;\r\n  icon?: string; // Icon displayed in the navbar\r\n  nav?: boolean; // Should the route appear in the navbar?\r\n  viewbar?: string; // Path to the viewbar module. Null hides it.\r\n  hasLeftMenu?: boolean; // Show/hide the left menu. Hidden by default.\r\n  roles?: Array<string>; // List of roles to access route. Null allows everyone.\r\n  login?: boolean; // Null allows everyone. True: users only, False: guests only.\r\n}\r\n```\r\n\r\n### Route Authorization\r\n\r\nWhen adding routes, we make sure that the settings property of the route complies with the above interface.\r\n\r\nTo authorize the routes, we created a pipeline step called `AuthorizeRoutes` and added it to our `configureRouter` in `app.ts` like this:\r\n\r\n```TypeScript\r\nimport { AuthorizeRoutes } from \"./core/auth/auth-middleware\";\r\n...\r\nclass App {\r\n\tconfigureRouter() {\r\n\t\tconfig.addPipelineStep(\"authorize\", AuthorizeRoutes);\r\n\t}\r\n}\r\n```\r\n\r\nAnd `auth-middleware.ts` looks like this:\r\n\r\n```TypeScript\r\nimport {inject} from \"aurelia-dependency-injection\";\r\nimport {NavigationInstruction, Redirect} from \"aurelia-router\";\r\n\r\nimport {Auth} from \"./auth\";\r\n\r\n@inject(Auth)\r\nexport class AuthorizeRoutes {\r\n  constructor(private auth: Auth) { }\r\n\r\n  run(navigationInstruction: NavigationInstruction, next: any) {\r\n    // Check if the route has an \"auth\" key\r\n    // The reason for using `getAllInstructions()` is to check all the child routes\r\n    const allInstructions = navigationInstruction.getAllInstructions();\r\n\r\n    if (allInstructions.some(i => this.requiresAuthMode(i.config.settings.login))) {\r\n      if (!this.auth.check()) {\r\n        // User needs to login\r\n        // Redirect to login...\r\n      }\r\n\r\n      let roles = navigationInstruction.config.settings.roles;\r\n\r\n      if (roles.length && !this.auth.user().hasRole(roles.join('|'))) {\r\n        // Not authorized to access\r\n        // Redirect to home page\r\n      }\r\n    }\r\n\r\n    if (allInstructions.some(i => this.requiresGuestMode(i.config.settings.login))) {\r\n        // Must be a guest to view...\r\n        // Redirect to home page\r\n    }\r\n\r\n    return next();\r\n  }\r\n\r\n  private requiresAuthMode(login) {\r\n    return login === true;\r\n  }\r\n\r\n  private requiresGuestMode(login) {\r\n    return login === false;\r\n  }    \r\n}\r\n```\r\n\r\n### Toggling the Left Menu Based on Active Route\r\n\r\nIn our `app.html` we check if the left menu should be visible based on the current route:\r\n\r\n```HTML\r\n<div class=\"page scrollable\" id=\"mainPageContainer\">\r\n  <div class=\"page-aside\" if.bind=\"router.currentInstruction.config.hasLeftMenu\">\r\n    <compose view-model=\"modules/left-menu/left-menu\"></compose>\r\n  </div>\r\n  <div class=\"page-main\">\r\n    <div class=\"page-content\">\r\n      <router-view swap-order=\"after\"></router-view>\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n### Using Aurelia's Enhance to Integrate jQuery With Aurelia\r\n\r\nOur right pane implementation had to work with the existing jQuery plugin as it already had the CSS animations we wanted. One problem with it was we needed to load Aurelia views using the plugin, not just static HTML. Aurelia had a solution ready for this, too. As Aurelia is a modular framework, you are able to leverage the functionality in each module individually to create any custom implementation you can imagine.\r\n\r\nOur solution works in two steps:\r\n\r\n1. Listening to `router:navigation:success` to capture page changes.\r\n2. If the activated route has the `viewbar` setting defined, trigger the jQuery plugin and load the relevant module inside the right pane.\r\n\r\nThe first part is done through the event aggregator package that ships with Aurelia. The router package will emit useful events that let you hook into the router lifecycle. [Here is a very useful article](https://ilikekillnerds.com/2015/09/understanding-aurelia-router-events/) that lists all of these events.\r\n\r\n```TypeScript\r\nthis.eventAggregator.subscribe(\r\n\t'router:navigation:success',\r\n\tthis.onNavigationSuccess\r\n)\r\n```\r\n\r\nThe second step is to get the router instruction from the event and handle it:\r\n\r\n```TypeScript\r\nonNavigationSuccess($event) {\r\n\tconst {viewbar} = $event.instruction\r\n    .getAllInstructions()\r\n    .pop()\r\n    .config.settings\r\n   \r\n\t$.slidePanel.show({\r\n\t\tcontent: '<compose view-model=\"' + viewbar + '\" containerless></compose>'\r\n\t}, {\r\n\t\tafterLoad: () => this.enhance()\r\n\t});\r\n}\r\n\r\nenhance() {\r\n\t// We get the main DIV to be enhanced,\r\n\t// Binding context is basically the view model (data) exposed to your view.\r\n\tthis.viewbarView = this.templating.enhance({\r\n\t\telement: $(\".slidePanel\").get(0),\r\n\t\tbindingContext: {\r\n\t\t\t...\r\n\t\t},\r\n\t})\r\n\t// As lifecycle methods are not called after manually enhancing,\r\n\t// Call the attached method yourself.\r\n\tif (\"attached\" in this.viewbarView) {\r\n\t\tthis.viewbarView.attached()\r\n\t}\r\n}\r\n```\r\n\r\n## Conclusion\r\n\r\nThere are loads of other awesome features in Aurelia framework that made the process of developing Codeline really fun: value converters, custom elements and attributes, embedded event system and cutting edge templating features, to name a few. Aurelia is different from other frameworks in how customizable and versatile it is. You feel closer to the metal, as you simply write regular JavaScript classes. You don't have to jump through any hoops to satisfy any arbitrary syntax or structure determined by the framework. Aurelia packs great power inside its well-written and tested modules to satisfy your expectations out of a modern JavaScript framework. As Codeline, we are a proud supporter of Aurelia and we are happy to see the framework get better and better."}