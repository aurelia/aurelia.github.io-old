{"name":"Advanced i18n with Aurelia and Net at Work GmbH","description":"Net at Work GmbH [https://www.netatwork.de/] is a product-based consultancy company with a glowing feather in its cap: NoSpamProxy [https://www.nospamproxy.de/en/]. NoSpamProxy is a multi-faceted secure email gateway solution aimed at providing powerful anti-spam and anti-malware capabilities. Moreover, it provides a number of other functionalities such as email encryption, large file transmission, and email disclaimer management.","author":{"name":"Net at Work GmbH"},"links":{"static":"blog/2019/08/04/advanced-i18n-with-aurelia-and-net-at-work-gmbh","html":"blog/2019/08/04/advanced-i18n-with-aurelia-and-net-at-work-gmbh/index.html","fragment":"blog/2019/08/04/advanced-i18n-with-aurelia-and-net-at-work-gmbh/index-fragment.html","self":"blog/2019/08/04/advanced-i18n-with-aurelia-and-net-at-work-gmbh/index.json"},"content":"\n[Net at Work GmbH](https://www.netatwork.de/) is a product-based consultancy company with a glowing feather in its cap: [NoSpamProxy](https://www.nospamproxy.de/en/). NoSpamProxy is a multi-faceted secure email gateway solution aimed at providing powerful anti-spam and anti-malware capabilities. Moreover, it provides a number of other functionalities such as email encryption, large file transmission, and email disclaimer management.\r\n\r\n## Background\r\n\r\nThe [NoSpamProxy](https://www.nospamproxy.de/en/) user interface was originally created using a WPF and XAML-based technology stack. As we have an international clientele, localization of the UI is of utmost importance to us.\r\nTo localize WPF applications we had to translate all texts that were used in the C# code files as well as all texts that are displayed in the WPF UI.\r\nTo achieve these goals we had to ensure that every piece of text used in the application ends up in the compiled assembly, along with a unique ID.\r\nTo this end, all texts from the code files were placed into dedicated resource files of the project.\r\nAdditionally, the [updateuid from MSBuild](https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/how-to-localize-an-application), hooked into a pre-build step, ensures that each text in the UI has a unique ID too.\r\nTherefore, we can extract all properties of these texts from the compiled assembly and localize them as needed. \r\nAn internal tool is then used to manage the translation.\r\nAfter all translations are done, the tool uses the original assemblies and the translations to build a new resource assembly for each locale.\r\n\r\nCurrently we are in the process of migrating part of the solution to the cloud.\r\nFor this, we also need to migrate part of the UI to a web-based solution, which is required to be multi-lingual.\r\nHowever, we quickly realized that we were missing the whole ecosystem of resource files, along with automatic resource ID generation, extraction, and compilation.\r\nAs a result, we decided to create our own tools. \r\n  \r\n## Localization Made Easy: aurelia-i18n + Net at Work GmbH Toolchain\r\n\r\nAs we use Aurelia for the web app, we leverage the [aurelia-i18n plugin](https://aurelia.io/docs/plugins/i18n#introduction) greatly to facilitate the localization of the app.\r\nInternally, the plugin uses [i18next](https://www.i18next.com/) to provide the translation service.\r\nIn very simple terms, using the plugin is a two-step process.\r\nFirstly, you need to mark the elements and attributes in the HTML templates that need to be translated, using the localization attributes such as `t`, and a unique value for the attribute.\r\nYou then must initialize the `i18next` instance with the localization resource, which in this case is a JSON object, where the `key` is the value of the `t` attribute, and the `value` is the translation.\r\n\r\n```JavaScript\r\naurelia.use\r\n  .plugin(\"aurelia-i18n\", (instance) => {\r\n    let aliases = [\"t\"];\r\n    // ...rest\r\n    return instance.setup({\r\n        attributes: aliases,\r\n        lng: \"en\",\r\n        resources: {\r\n            en: { translation: { key: \"value EN\", ...} },\r\n            de: { translation: { key: \"value DE\", ...} },\r\n            //... other languages\r\n        }\r\n        // ...rest\r\n    });\r\n  })\r\n```\r\n\r\nThe code snippet above shows a very simplistic usage of the plugin, where the translation JSON objects are directly fed to the `i18next` instance.\r\nIf you are using webpack, and supporting too many languages, the setup shown above can increase your bundle size unnecessarily.\r\nIn that case, you are better off using a backend service as shown in the official documentation of the plugin.\r\nSuch a service can also be helpful in pre-processing the resources, such as merging resources from different sources in runtime.\r\nOnce these resources are fed to the plugin, Aurelia will update the translations on the fly, whenever the active locale is changed by calling `i18n.setLocale('...')`.\r\n\r\nLet us now focus on the fact that to use `aurelia-i18n` we need to have the resources marked with unique keys along with those JSON objects / files for every locale supported.\r\nYou may attempt to create the keys by hand.\r\nHowever, that is an error-prone process as you have to ensure that keys are unique on a global level.\r\nMoreover, creating and maintaining the files manually is a tedious job that gets exponentially harder with the number of locales supported increasing.\r\nTherefore, the idea is to semi-automate the process as much as possible.\r\n\r\nIn order to do that, let us first understand the steps involved in the process, which are as follows:\r\n\r\n1. Generating the `i18n` keys for the HTML templates.\r\n1. Extracting the keys, and values to a central external resource.\r\n1. Updating the central translation resource with the translations of the values for different languages.\r\n1. Compiling the translations to generate individual locale files for different languages that can be consumed by `i18next`.\r\n\r\nWe strongly believe that the quality of expert human translation is still unmatched.\r\nTherefore, apart from the third step, all the other steps can be automated by using the toolchain offered by our company.\r\nUsing these packages, a gulp task can be composed easily to automate the process.\r\nLet us take a look at these tools below.\r\n\r\nFor the purpose of this example, assume that all of our HTML templates are under `src` directory.\r\nAdditionally, JSON files can also be used as external resource files, which are distinguished in this example by the `.r.json` extension (more on this later).\r\nUsing this information, first setup some constants which are used later by the tasks.\r\n\r\n```JavaScript GulpFile.js\r\nconst path = require(\"path\");\r\n\r\nconst src = path.resolve(__dirname, \"src\"),\r\n    json = path.resolve(src, \"*.r.json\"),\r\n    html = path.resolve(src, \"*.html\");\r\n```\r\n\r\n### ID Generation\r\n\r\nThis is the first step in the process.\r\nIn this step, we identify and mark the text in the HTML templates that needs to be translated, using the [gulp-i18n-update-localization-ids](https://github.com/Netatwork-de/gulp-i18n-update-localization-ids) package.\r\nThis is done by using an array of whitelisted HTML tags as well as the attributes.\r\nThe package then generates the `t` attributes (or the configured localization attributes) with unique values for the elements and the associated attributes as found in the HTML templates.\r\nThese values act as `i18n` keys later.\r\n\r\n```JavaScript GulpFile.js\r\nconst updateLocalizationIds = require('gulp-i18n-update-localization-ids');\r\n\r\nconst i18nGlobalPrefixes = new Map();\r\nconst generateI18nKeys = function () {\r\n  return gulp.src(html, { since: gulp.lastRun(generateI18nKeys) })\r\n    .pipe(updateLocalizationIds({\r\n      emit: 'onChangeOnly',\r\n      ignore: [{\r\n        content: v => v.startsWith('${') && v.endsWith('}')\r\n      }],\r\n      idTemplate: updateLocalizationIds.prefixFilename(i18nGlobalPrefixes),\r\n      whitelist: [\r\n        {\r\n          tagName: 'h2'\r\n        },\r\n        {\r\n          tagName: 'my-custom-el',\r\n          attrs: ['some-value']\r\n        }\r\n      ]\r\n    }))\r\n    .pipe(gulp.dest(src));\r\n}\r\n```\r\n\r\nA simplistic code snippet for generating the `i18n` keys is shown above (for the full set of options please refer to the documentation) .\r\nLet us assume that there are two HTML templates:\r\n\r\n```HTML\r\n<!-- template1.html -->\r\n<template>\r\n  <h2>some text</h2>\r\n  <!-- ... -->\r\n</template>\r\n\r\n<!-- template2.html -->\r\n<template>\r\n  <my-custom-el some-value=\"value for the property in my-custom-el\"></my-custom-el>\r\n  <!-- ... -->\r\n</template>\r\n```\r\n\r\nThe ID generation task transforms those templates into the following.\r\n\r\n```HTML\r\n<!-- template1.html -->\r\n<template>\r\n  <h2 t=\"template1.t0\">some text</h2>\r\n  <!-- ... -->\r\n</template>\r\n\r\n<!-- template2.html -->\r\n<template>\r\n  <my-custom-el some-value=\"value for the property in my-custom-el\" t=\"[some-value]template2.t0\"></my-custom-el>\r\n  <!-- ... -->\r\n</template>\r\n```\r\n\r\n### Resource Extraction\r\n\r\nIn the next step, all the keys and the corresponding values need to be extracted to a central JSON file.\r\nThis file needs to be updated with the translation for different languages.\r\nHypothetically, you need to deal with this one file when you translate.\r\nThe JSON file also includes various metadata that can be used to track whether a resource has been changed after the last translation update.\r\n\r\nContextually, we want to emphasize that HTML files are not the sole source of translation resources.\r\nExternal JSON files can also be utilized to provide translation resources.\r\nThis might look familiar if you are acquainted with the resource files in .NET. \r\nSome of the use cases for such files are as follows:\r\n\r\n- Providing translation via code. For example, locale-specific validation failure message using [withMessageKey](https://aurelia.io/docs/plugins/validation#defining-rules)\r\n- Providing context-specific translations\r\n  - using `t=\"template2.r.Status\" t-params.bind=\"{context: item.status}\"`, \r\n  - using interpolation `t=\"template2.r.Status.${item.Status}\"`, or\r\n  - by [pluralization](https://www.i18next.com/translation-function/plurals).\r\n\r\nWe use a convention to mark such external resource JSON files with `.r.json` extension (optional).\r\nNaturally, we also need to translate those resource files for every supported locale.\r\n\r\nUsing [gulp-i18n-extract](https://github.com/Netatwork-de/gulp-i18n-extract) the resources can be extracted from both the HTML templates and the JSON files.\r\nA minimalist code snippet is shown below.\r\n\r\n```javascript GulpFile.js\r\nconst i18nExtract = require('gulp-i18n-extract');\r\n\r\n// path to the central translation file\r\nconst translations = path.resolve(__dirname, \"translations/i18n.json\");\r\n\r\nconst i18nExtractOptions = {\r\n  // here we are saying that we want to extract resources from both HTML and JSON files\r\n  plugIns: [\r\n    new i18nExtract.html(),\r\n    new i18nExtract.json()\r\n  ],\r\n  markUpdates: true,\r\n  defaultLanguages: ['de', \"fr\"] // <-- here goes the list of supported languages\r\n};\r\n\r\nconst extractI18n = function () {\r\n  return gulp.src([html, json])\r\n    .pipe(i18nExtract.extract(translations, i18nExtractOptions))\r\n    .pipe(gulp.dest(\".\"));\r\n}\r\n```\r\n\r\nThis task generates a file that looks similiar to the file shown below:\r\n\r\n```JSON i18n.json\r\n{\r\n  \"template1\": {\r\n    \"content\": {\r\n      \"template1.t0\": {\r\n        \"content\": \"some text\",\r\n        \"lastModified\": \"2019-06-20T16:23:42.306Z\",\r\n        \"needsUpdate\": true,\r\n        \"translations\": {\r\n          \"de\": {\r\n            \"content\": \"\",\r\n            \"lastModified\": \"\"\r\n          },\r\n          \"fr\": {\r\n            \"content\": \"\",\r\n            \"lastModified\": \"\"\r\n          }\r\n        }\r\n      },\r\n    },\r\n    \"src\": \"src\\\\template1.html\"\r\n  },\r\n  \"template2\": {\r\n    \"content\": {\r\n      \"template2.t0\": {\r\n      \"content\": \"value for the property in my-custom-el\",\r\n      \"lastModified\": \"2019-06-20T16:23:42.316Z\",\r\n      \"needsUpdate\": true,\r\n      \"translations\": {\r\n        \"de\": {\r\n          \"content\": \"\",\r\n          \"lastModified\": \"\"\r\n        },\r\n        \"fr\": {\r\n          \"content\": \"\",\r\n          \"lastModified\": \"\"\r\n        }\r\n      }\r\n      }\r\n    },\r\n    \"src\": \"src\\\\template2.html\"\r\n  },\r\n  \"template2.r\": {\r\n    \"content\": {\r\n      \"template2.r.external\": {\r\n      \"content\": \"this is an external resource\",\r\n      \"lastModified\": \"2019-06-20T16:23:42.318Z\",\r\n      \"needsUpdate\": true,\r\n      \"translations\": {\r\n        \"de\": {\r\n          \"content\": \"\",\r\n          \"lastModified\": \"\"\r\n        },\r\n        \"fr\": {\r\n          \"content\": \"\",\r\n          \"lastModified\": \"\"\r\n        }\r\n      }\r\n      }\r\n    },\r\n    \"src\": \"src\\\\template2.r.json\"\r\n  }\r\n}\r\n```\r\n\r\nYou can now update this file with the translation for various languages.\r\nThis file needs to be put under source control to track the changes.\r\nIt will later be used to generate the final translation files for every locale.\r\n\r\n### Compile\r\n\r\nAfter the `i18n.json` file has been updated with translations, the last step is to compile the file to produce individual locale files.\r\nWe do this using the [gulp-i18n-compile2](https://github.com/Netatwork-de/gulp-i18n-compile2) package.\r\n\r\n```JavaScript GulpFile.js\r\nconst i18nCompile = require('gulp-i18n-compile2');\r\n\r\n// destination directory for the locale files\r\nconst locales = path.resolve(__dirname, \"locales\");\r\n\r\nconst compileOptions = {\r\n  fileName: \"translation.json\", // <-- name of the file to generate\r\n  defaultLanguage: \"en\"\r\n};\r\n\r\nconst compileI18n = function () {\r\n  return gulp.src(translations) // <-- this is the path to the 'i18n.json' generated in the previous step\r\n    .pipe(i18nCompile(compileOptions))\r\n    .pipe(gulp.dest(locales));\r\n}\r\n```\r\n\r\nThis task produces the following result:\r\n\r\n```Shell\r\n.\r\n+───locales\r\n│   +───de\r\n│   │   +───translation.json\r\n│   │\r\n│   ├───en\r\n│   │   +───translation.json\r\n.   │\r\n.   └───fr\r\n.       +───translation.json\r\n```\r\n\r\nThe content of these files looks as follows:\r\n\r\n```json\r\n{\r\n  \"template1\": {\r\n    \"t0\": \"some text\",\r\n  },\r\n  \"template2\": {\r\n    \"t0\": \"value for the property in my-custom-el\",\r\n    \"r\": {\r\n      \"external\": \"this is an external resource\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThese files can be directly fed to the `i18next` instance to provide the runtime translation resources.\r\nThere is no need to source control these files as these can be produced every time you build.\r\n\r\n### Putting It All Together\r\n\r\nUsing the tasks described above, you can compose a gulp task like below and use it in your CI/CD.\r\n\r\n```JavaScript\r\ngulp.task(\"i18n\", gulp.series(generateI18nKeys, extractI18n, compileI18n));\r\n```\r\n\r\n## Summary\r\n\r\nWe at Net at Work GmbH consider localization to be an integral aspect of the user interface as it increases inclusion, broadens our client base, and helps to improve the general usability.\r\nMaintaining the localization correctly is a painstaking task, which is why feel pride in ourselves that we have contributed to make that task easier.\r\nAs shown above, the packages can be easily used to compose a task to semi-automate the process of localization.\r\n\r\nThank you for reading. We hope this will be useful for you."}