{"name":"How do we React? - Part 3","description":"This is part 3 of 3 in a series titled \"How do we React?\" in which I conclude our discussion of how Aurelia handles common React scenarios.","author":{"name":"Rob Eisenberg"},"links":{"static":"blog/2019/3/13/how-do-we-react-part-3","html":"blog/2019/3/13/how-do-we-react-part-3/index.html","fragment":"blog/2019/3/13/how-do-we-react-part-3/index-fragment.html","self":"blog/2019/3/13/how-do-we-react-part-3/index.json"},"content":"\nThis is part 3 of 3 in a series titled \"How do we React?\" in which I conclude our discussion of how Aurelia handles common React scenarios.\n\nThe other week [Sebastian Markbåge](https://twitter.com/sebmarkbage) posted [the following tweet](https://twitter.com/sebmarkbage/status/1098310123796062209):\n\n> You may have noticed that most other frameworks don't have HoCs, render props or anything like React.Children. These account for a lot the differences between React and other frameworks. How would you solve these use cases if you had to switch to [other framework]?\n\n**In this post, we'll cover React.Children** For a discussion of how Aurelia handles typical HoC scenarios, [please see part 1](blog/2019/02/21/how-do-we-react-part-1) or for information on how we handle render props, [see part 2](blog/2019/03/01/how-do-we-react-part-2).\n\n\n## React.Children\n\nFrom Sebastian's original tweet, it wasn't clear to me whether he was referring to the [React.Children](https://reactjs.org/docs/react-api.html#reactchildren) helper or to a React component's [props.children](https://reactjs.org/docs/composition-vs-inheritance.html). The utility seems less essential to me, so I'll focus primarily on [props.children](https://reactjs.org/docs/composition-vs-inheritance.html) here, but I'll also make a few notes relating to `React.Children`.\n\nThe React site [states](https://reactjs.org/docs/composition-vs-inheritance.html):\n\n> Some components don’t know their children ahead of time. This is especially common for components like `Sidebar` or `Dialog` that represent generic \"boxes\". We recommend that such components use the special `children` prop to pass children elements directly into their output.\n\n## Slots\n\nIf you've read [part 2 of this series](blog/2019/03/01/how-do-we-react-part-2), then you may have already realized that this is handled quite simply by Aurelia's adoption of the Shadow DOM web standard. As an example, the `FancyBorder` component shown on the React site can be authored in Aurelia like this:\n\n```HTML fancy-border.html\n<template bindable=\"color\" class=\"fancy-border-${color}\">\n  <slot></slot>\n</template>\n```\n\nIn fact, we don't even need to write any JavaScript at all to implement this. Because these types of container components are so common, Aurelia provides a mechanism for creating HTML-only components, which is what I've shown above. Here's how it's used:\n\n```HTML app.html\n<fancy-border color=\"red\">\n  Hello from Aurelia!\n</fancy-border>\n```\n\nAs a reminder, or if you aren't familiar with Shadow DOM, the HTML child nodes of the `fancy-border` element will automatically be projected into the location of the `slot` element. That's all there is to it.\n\nBecause we've adopted the Shadow DOM slot composition model, we can also declaratively use named slots, slot fallback content, and re-project children from a slot in one element to a slot in a nested component. All that comes for free.\n\n> Info: Web Standards\n> A core value of Aurelia has always been to be as standards compliant as possible. Besides the natural benefit of working with browsers rather than against them, anyone who knows the standards already knows most of Aurelia. And those who are less familiar with the standards will learn many of them while using Aurelia, which is an excellent career side-effect for any front-end engineer.\n\n## The @children Decorator\n\nFor the most part, something like [React.Children](https://reactjs.org/docs/react-api.html#reactchildren) isn't needed in Aurelia, since developers are typically working with slot-based composition or simple collections of plain JavaScript objects.\n\nThat said, you may wonder how a container component would gain access to its child components directly, so that it can manipulate them, query them, or build other UI based on them. If you have that scenario in Aurelia, all you need to do is decorate a property with the `@children` decorator. You can optionally specify a CSS selector, to filter which children you want to work with. For example, if you were building a tab control, you could do something like this:\n\n```JavaScript tab-control.js\nexport class TabControl {\n  @children('tab-item') items;\n\n  selectTab(item) {\n    // ellided\n  }\n}\n```\n\nWith this in place, you have a live list of all the component view models for `tab-item` components that are children of a `tab-control`. So, you could build a view for the `tab-control` like this:\n\n```HTML tab-control.html\n<template>\n  <ul class=\"tab-strip\">\n    <li repeat.for=\"item of items\">\n      <a click.trigger=\"selectTab(item)\">${item.heading}</a>\n    </li>\n  </ul>\n\n  <div class=\"tab-items\">\n    <slot></slot>\n  <div>\n</template>\n```\n\nWith the view above, the `tab-item` components will be rendered at the location of the `slot`. However, in addition to that, an `li` will be rendered for every `tab-item` child, with the text content of the `a` set to the `heading` property of the item.\n\nIn other words, you could write this...\n\n```HTML app.html\n<template>\n  <tab-control>\n    <tab-item heading=\"Tab 1\">\n      Content of tab 1.\n    </tab-item>\n    <tab-item heading=\"Tab 2\">\n      Content of tab 2.\n    </tab-item>\n    <tab-item heading=\"Tab 3\">\n      Content of tab 3.\n    </tab-item>\n  </tab-control>\n</template>\n```\n\nAnd it would render something like this:\n\n```HTML app.html\n<tab-control>\n  <ul class=\"tab-strip\">\n    <li>\n      <a>Tab 1</a>\n    </li>\n    <li>\n      <a>Tab 2</a>\n    </li>\n    <li>\n      <a>Tab 3</a>\n    </li>\n  </ul>\n\n  <div class=\"tab-items\">\n    <tab-item heading=\"Tab 1\">\n      Content of tab 1.\n    </tab-item>\n    <tab-item heading=\"Tab 2\">\n      Content of tab 2.\n    </tab-item>\n    <tab-item heading=\"Tab 3\">\n      Content of tab 3.\n    </tab-item>\n  <div>\n</tab-control>\n```\n\nBecause Aurelia's templating and binding systems are deeply integrated, you could drive the entire tab control with data also, like this:\n\n```HTML app.html\n<template>\n  <tab-control>\n    <tab-item repeat.for=\"n of 3\" heading=\"Tab ${n}\">\n      Content of tab ${n}.\n    </tab-item>\n  </tab-control>\n</template>\n```\n\nThis would result in the same final HTML composition as the static version above.\n\n## Wrapping Up\n\nThis post was quite a bit shorter than part 2, primarily because much of what we covered in part 2 also addresses the scenarios for `React.Children` and `props.children`. Aurelia's standards-based slot composition model, combined with powerful decorators like `@children` enable a very declarative model for what would otherwise be complex UI patterns.\n\nWe hope you've enjoyed this three part series and now have a better idea of how Aurelia provides its own approaches to various React scenarios. If you're curious to see what Aurelia vNext has in store, or to learn more about Aurelia and how it compares to other frameworks, please subscribe to this blog. There's much more goodness to come.\n\nCheers!"}