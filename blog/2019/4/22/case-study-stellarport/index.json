{"name":"Case Study: Stellarport","description":"Today, I'm pleased to introduce Ishai Strauss from Stellarport to talk about how they've built their product with Aurelia. Read on to hear from Ishai about Stellarport's experiences integrating Redux with Aurelia and leveraging decorator-based composition with Aurelia's Fetch client.","author":{"name":"Ishai Strauss"},"links":{"static":"blog/2019/4/22/case-study-stellarport","html":"blog/2019/4/22/case-study-stellarport/index.html","fragment":"blog/2019/4/22/case-study-stellarport/index-fragment.html","self":"blog/2019/4/22/case-study-stellarport/index.json"},"content":"\r\nToday, I'm pleased to introduce Ishai Strauss from Stellarport to talk about how they've built their product with Aurelia. Read on to hear from Ishai about Stellarport's experiences integrating Redux with Aurelia and leveraging decorator-based composition with Aurelia's Fetch client.\r\n\r\n## What is Stellarport?\r\n\r\n[Stellarport](https://stellarport.io) is a decentralized wallet and trading client, based on the [Stellar](https://stellar.org) network. Users can create and manage wallets that they have cryptographic control over as well as trade in real time directly to and from the wallet. Trading on Stellarport is all done via blockchain technology (using the Stellar protocol). While the backend of Stellarport is written in a variety of languages and frameworks, the front end is written in just one (our favorite) - **Aurelia**.\r\n\r\n## Why Aurelia?\r\n\r\nWe've been Aurelia fans for a long time, ever since the beta in fact. We'd already used Aurelia in production in conjunction with Redux with great success. Because Aurelia keeps it simple and focuses on doing its job simply, reliably, and in a modular way, plugging in Redux was easily done.\r\n\r\nWhen beginning work on Stellarport, we knew that state management and reliability were going to be important factors to be taken seriously from the get go. It was an easy choice to use Aurelia + Redux.\r\n\r\n## Using Aurelia\r\n\r\nBecause Aurelia is so uncomplicated and modular, we've been able to customize it in a variety of very useful ways. Below, I will talk about some of the ways, we at Stellarport, have used Aurelia effectively.\r\n\r\n### Aurelia and Redux\r\n\r\nAs previously mentioned, one thing we focus on is state management. With a product like a real-time trading client, there is lots of data to keep track of and in sync. We wouldn't want different parts of the website showing different prices or market sizes for example. To ensure data synchronization, we store much of the data, especially in some of the more complicated parts of the website, in Redux.\r\n\r\nBecause Aurelia's view models are just classes, integrating Redux with Aurelia can be done by using a custom `@connected` decorator. Here is an example:\r\n\r\n```JavaScript\r\nimport BigNumber from 'bignumber.js';\r\nimport { computedFrom, bindable } from 'aurelia-framework';\r\nimport { connected } from 'aurelia-redux-connect';\r\n\r\nexport class OrderbookCustomElement {\r\n    @bindable()\r\n    currentTab;\r\n\r\n    @connected('myAccount')\r\n    account;\r\n\r\n    @connected('exchange.assetPair')\r\n    assetPair;\r\n\r\n    @connected('exchange.orderbook')\r\n    orderbook;\r\n\r\n    @computedFrom('orderbook')\r\n    get bids() {\r\n        return this.orderbook ? this.orderbook.bids : [];\r\n    }\r\n\r\n    @computedFrom('orderbook')\r\n    get asks() {\r\n        return this.orderbook ? this.orderbook.asks : [];\r\n    }\r\n\r\n    @computedFrom('orderbook')\r\n    get spread() {\r\n        if (!this.orderbook || this.orderbook.bids.length === 0 || this.orderbook.asks.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const topAsk = this.priceFromFraction(this.orderbook.asks[0]);\r\n        const topBid = this.priceFromFraction(this.orderbook.bids[0]);\r\n\r\n        return {\r\n            raw: (new BigNumber(topAsk)).minus(topBid).toString(10),\r\n            percent: (new BigNumber(topAsk)).dividedBy(topBid).minus(1).times(100).toString(10)\r\n        };\r\n    }\r\n\r\n    priceFromFraction(order) {\r\n        return order ? new BigNumber(order.priceNumerator).dividedBy(order.priceDenominator).toString(10) : '';\r\n    }\r\n}\r\n```\r\n\r\nIn the example, there are a few things to note:\r\n\r\n1. Notice how simple this view model looks. All the properties are simply getters. The view model is just the glue between the view and the model. The code is clear, maintainable, and reliable.\r\n2. We use the `@connected` decorator to connect the view model to Redux (passing in the object path required to access the desired value). The connected decorator will update the view model when the store changes.\r\n3. Because Redux is a state store, it is best to store the state in a fairly normalized way. This results in often needing values that are derived from the stored values, rather than the raw stored values. With Aurelia, this is easy with `@computedFrom`. Aurelia will automatically update `@computedFrom` bindings when the `@connected` dependencies update.\r\n\r\nOur aurelia/redux integration is [available on npm](https://www.npmjs.com/package/aurelia-redux-connect).\r\n\r\n### CRUD With Aurelia\r\n\r\nStellarport requires data from multiple data sources. One of Aurelia's strong points is its modular architecture. In our case, CRUD becomes easy with Aurelia's Fetch client. Because we are fetching data from multiple sources in different forms, we need multiple fetch clients each with a slightly different configuration. With Aurelia's DI, we can just inherit and then mixin functionality. Each inherited fetch client will be stored as a separate singleton inside of Aurelia's DI.\r\n\r\nTo do this we start with some decorators we can mixin to our clients. Let's start with a decorator that adds a baseUrl to a client:\r\n\r\n```JavaScript\r\nexport function withBaseUrl(baseUrl) {\r\n    return function(target) {\r\n        const addBaseUrl = function(config) {\r\n            return config\r\n                .withBaseUrl(baseUrl);\r\n        };\r\n\r\n        const previousModifyConfiguation = target.prototype.modifyConfiguration || function(config) { return config; };\r\n\r\n        target.prototype.modifyConfiguration = function(config) {\r\n            return addBaseUrl(\r\n                previousModifyConfiguation.call(this, config)\r\n            );\r\n        };\r\n    };\r\n}\r\n```\r\n\r\nand then a decorator that adds the content type to the client's requests:\r\n\r\n```JavaScript\r\nexport function sendJson() {\r\n    return function(target) {\r\n        const addContentTypeJsonHeader = function(config) {\r\n            const defaults = config.defaults || {};\r\n\r\n            return config\r\n                .withDefaults(\r\n                    _merge(\r\n                        defaults,\r\n                        {\r\n                            headers: {\r\n                                'content-type': 'application/json'\r\n                            }\r\n                        }\r\n                    )\r\n                );\r\n        };\r\n\r\n        const previousModifyConfiguation = target.prototype.modifyConfiguration || function(config) { return config; };\r\n\r\n        target.prototype.modifyConfiguration = function(config) {\r\n            return addContentTypeJsonHeader(\r\n                previousModifyConfiguation.call(this, config)\r\n            );\r\n        };\r\n    };\r\n}\r\n```\r\n\r\nFinally, let's add a (slightly more complicated) decorator that adds an authentication token to the request headers (JWT):\r\n\r\n```JavaScript\r\nexport function withBearerToken() {\r\n    return function(target) {\r\n        if (!target.prototype.acquireToken) {\r\n            throw new Error(target.name + ' is decorated with @withBearerToken() but does not have an implemented acquireToken method.');\r\n        }\r\n\r\n        const addBearerTokenInerceptor = function(context, config) {\r\n            return config\r\n                .withInterceptor(bearerTokenInterceptorFactory(context));\r\n        };\r\n\r\n        const previousModifyConfiguation = target.prototype.modifyConfiguration || function(config) {return config;};\r\n\r\n        target.prototype.modifyConfiguration = function(config) {\r\n            return addBearerTokenInerceptor(\r\n                this,\r\n                previousModifyConfiguation.call(this, config)\r\n            );\r\n        };\r\n    };\r\n}\r\n\r\nfunction bearerTokenInterceptorFactory(context) {\r\n    return {\r\n        request: function(request) {\r\n            return context.acquireToken(request)\r\n                .then(token => {\r\n                    if (token) {\r\n                        request.headers.append('Authorization', 'Bearer ' + token);\r\n                    }\r\n                    return request;\r\n                })\r\n                .catch(err => {\r\n                    if (context.acquireTokenError) {\r\n                        context.acquireTokenError(err);\r\n                    }\r\n                    throw err;\r\n                });\r\n        }.bind(this)\r\n    };\r\n}\r\n```\r\n\r\nNow, we can use these to build up different HTTP clients:\r\n\r\n```JavaScript\r\n@withBaseUrl(window.stellarport.urls.aCoolAPI)\r\n@acceptAll()\r\n@sendJson()\r\n@withBearerToken()\r\nexport class AuthCoolApiClient extends HttpClient {\r\n    acquireToken() {\r\n        ...\r\n    }\r\n}\r\n\r\n@withBaseUrl(window.stellarport.urls.anotherAPI)\r\n@acceptAll()\r\n@sendJson()\r\nexport class AnotherApiClient extends HttpClient {}\r\n```\r\n\r\nFinally, we initialize our api clients on app startup like so:\r\n\r\n```JavaScript\r\nauthCoolApiClient.configure(config => authCoolApiClient.modifyConfiguration(config));\r\nanotherApiClient.configure(config => anotherApiClient.modifyConfiguration(config));\r\n```\r\n\r\nHere we have different API clients, with different base urls, one authenticated and one not. Aurelia makes it super easy.\r\n\r\n## Conclusion\r\n\r\nUsing Aurelia is a pleasure. It is simple, intuitive, and flexible. At Stellarport, we're sure we made the right choice building on Aurelia."}